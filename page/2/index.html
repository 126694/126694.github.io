<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="akurisu">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="akurisu">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>akurisu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">akurisu</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/29/%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/29/%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">字符串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-29 23:47:44" itemprop="dateCreated datePublished" datetime="2022-03-29T23:47:44+08:00">2022-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-05 20:39:42" itemprop="dateModified" datetime="2022-05-05T20:39:42+08:00">2022-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Leetcode344-反转字符串"><a href="#Leetcode344-反转字符串" class="headerlink" title="Leetcode344 反转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-string/">Leetcode344 反转字符串</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE/image-20220427153338500.png" alt="image-20220427153338500"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = s.length - <span class="number">1</span>; i &lt; j; i++, j--)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s[i];</span><br><span class="line">            s[i] = s[j];</span><br><span class="line">            s[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode541-反转字符串-II"><a href="#Leetcode541-反转字符串-II" class="headerlink" title="Leetcode541 反转字符串 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-string-ii/">Leetcode541 反转字符串 II</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE/image-20220427154700220.png" alt="image-20220427154700220"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i += <span class="number">2</span> * k)&#123;</span><br><span class="line">             <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">             <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> Math.min(s.length() - <span class="number">1</span>, start + k - <span class="number">1</span>);</span><br><span class="line">             <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">                 <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> ch[start];</span><br><span class="line">                 ch[start] = ch[end];</span><br><span class="line">                 ch[end] = temp;</span><br><span class="line">                 end--;</span><br><span class="line">                 start++;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE/image-20220428090941069.png" alt="image-20220428090941069"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">      <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n,j = s.length() - <span class="number">1</span>; i &lt; j; i++, j--)&#123;</span><br><span class="line">          <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> ch[i];</span><br><span class="line">          ch[i] = ch[j];</span><br><span class="line">          ch[j] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = n - <span class="number">1</span>; i &lt; j ; i++, j--)&#123;</span><br><span class="line">          <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> ch[i];</span><br><span class="line">          ch[i] = ch[j];</span><br><span class="line">          ch[j] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = ch.length - <span class="number">1</span>; i &lt; j; i++, j--)&#123;</span><br><span class="line">          <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> ch[i];</span><br><span class="line">          ch[i] = ch[j];</span><br><span class="line">          ch[j] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/29/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/29/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">回溯算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-29 23:47:44" itemprop="dateCreated datePublished" datetime="2022-03-29T23:47:44+08:00">2022-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-10 14:28:51" itemprop="dateModified" datetime="2022-05-10T14:28:51+08:00">2022-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="回溯法解决的问题"><a href="#回溯法解决的问题" class="headerlink" title="回溯法解决的问题"></a>回溯法解决的问题</h2><p>回溯法，一般可以解决如下几种问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<h2 id="Leetcode77-组合"><a href="#Leetcode77-组合" class="headerlink" title="Leetcode77 组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/">Leetcode77 组合</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220509183145708.png" alt="image-20220509183145708"></p>
<p>普通解法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">          dfs(n, k, <span class="number">1</span>);</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n; i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            dfs(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>减枝优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">          dfs(n, k, <span class="number">1</span>);</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            dfs(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Leetcode216-组合总和-III"><a href="#Leetcode216-组合总和-III" class="headerlink" title="Leetcode216 组合总和 III"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/">Leetcode216 组合总和 III</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220509191922603.png" alt="image-20220509191922603"></p>
<p>朴素解法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">          dfs(k, n, <span class="number">1</span>);</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(n &lt; <span class="number">0</span> || path.size() &gt; k)&#123;</span><br><span class="line">              <span class="keyword">return</span> ;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(n == <span class="number">0</span>  &amp;&amp; path.size() == k)&#123;</span><br><span class="line">              result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">              <span class="keyword">return</span> ;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= <span class="number">9</span>; i++)&#123;</span><br><span class="line">              path.add(i);</span><br><span class="line">              dfs(k, n - i, i + <span class="number">1</span>);</span><br><span class="line">              path.removeLast();</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>减枝优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">          dfs(k, n, <span class="number">1</span>);</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(n &lt; <span class="number">0</span> || path.size() &gt; k)&#123;</span><br><span class="line">              <span class="keyword">return</span> ;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(n == <span class="number">0</span>  &amp;&amp; path.size() == k)&#123;</span><br><span class="line">              result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">              <span class="keyword">return</span> ;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= <span class="number">9</span> - (k - path.size()) + <span class="number">1</span>; i++)&#123;  <span class="comment">//减枝过程在这里</span></span><br><span class="line">              path.add(i);</span><br><span class="line">              dfs(k, n - i, i + <span class="number">1</span>);</span><br><span class="line">              path.removeLast();</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode17-电话号码的字母组合"><a href="#Leetcode17-电话号码的字母组合" class="headerlink" title="Leetcode17 电话号码的字母组合"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">Leetcode17 电话号码的字母组合</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220509193331855.png" alt="image-20220509193331855"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] map = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">        dfs(digits, map, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String digits, String[] map, <span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startIndex == digits.length())&#123;</span><br><span class="line">            result.add(tmp.toString());</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> map[digits.charAt(startIndex) - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            tmp.append(str.charAt(i));</span><br><span class="line">            dfs(digits, map, startIndex+<span class="number">1</span>);</span><br><span class="line">            tmp.deleteCharAt(tmp.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Leetcode39-组合总和"><a href="#Leetcode39-组合总和" class="headerlink" title="Leetcode39 组合总和"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">Leetcode39 组合总和</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220510074123834.png" alt="image-20220510074123834"></p>
<p>朴素做法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">         trackBacking(candidates, target, <span class="number">0</span>);</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trackBacking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            trackBacking(candidates, target - candidates[i], i);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剪枝优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">         Arrays.sort(candidates); <span class="comment">//需要排序，使得当当前位置超过target时，后面的for循环不会被执行</span></span><br><span class="line">         trackBacking(candidates, target, <span class="number">0</span>);</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trackBacking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length &amp;&amp; target - candidates[i] &gt;= <span class="number">0</span>; i++)&#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            trackBacking(candidates, target - candidates[i], i);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Leetcode40-组合总和-II"><a href="#Leetcode40-组合总和-II" class="headerlink" title="Leetcode40 组合总和 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/">Leetcode40 组合总和 II</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220510080001392.png" alt="image-20220510080001392"></p>
<p>同一层for循环里不能重复进行选取</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220510080042333.png" alt="image-20220510080042333"></p>
<p>朴素算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] isUsed;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">         isUsed = <span class="keyword">new</span> <span class="title class_">boolean</span>[candidates.length];</span><br><span class="line">         Arrays.sort(candidates);</span><br><span class="line">         trackBacking(candidates, target, <span class="number">0</span>); <span class="comment">//在同一树层上不能选取一样的</span></span><br><span class="line">         <span class="keyword">return</span> result; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trackBacking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; !isUsed[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            isUsed[i] = <span class="literal">true</span>;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            trackBacking(candidates, target - candidates[i], i + <span class="number">1</span>);</span><br><span class="line">            isUsed[i] = <span class="literal">false</span>;</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剪枝算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] isUsed;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">         isUsed = <span class="keyword">new</span> <span class="title class_">boolean</span>[candidates.length];</span><br><span class="line">         Arrays.sort(candidates);</span><br><span class="line">         trackBacking(candidates, target, <span class="number">0</span>); <span class="comment">//在同一树层上不能选取一样的</span></span><br><span class="line">         <span class="keyword">return</span> result; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trackBacking</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//利用target - candidates[i] &gt;= 0进行剪枝优化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length &amp;&amp; target - candidates[i] &gt;= <span class="number">0</span>; i++)&#123; </span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>] &amp;&amp; !isUsed[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            isUsed[i] = <span class="literal">true</span>;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            trackBacking(candidates, target - candidates[i], i + <span class="number">1</span>);</span><br><span class="line">            isUsed[i] = <span class="literal">false</span>;</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode131-分割回文串"><a href="#Leetcode131-分割回文串" class="headerlink" title="Leetcode131 分割回文串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/">Leetcode131 分割回文串</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220510092110529.png" alt="image-20220510092110529"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        trackBacking(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trackBacking</span><span class="params">(String s, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == s.length())&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPalindrome(s, start, i))&#123;</span><br><span class="line">                path.add(s.substring(start, i + <span class="number">1</span>));</span><br><span class="line">                trackBacking(s, i + <span class="number">1</span>);</span><br><span class="line">                path.removeLast();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中心扩散法判断回文</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start, j = end; i &lt;= j; i++, j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != s.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode93-复原-IP-地址"><a href="#Leetcode93-复原-IP-地址" class="headerlink" title="Leetcode93 复原 IP 地址"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/restore-ip-addresses/">Leetcode93 复原 IP 地址</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220510104151445.png" alt="image-20220510104151445"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">         trackBacking(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trackBacking</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> pointNum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pointNum == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(s, start, s.length() - <span class="number">1</span>))&#123;</span><br><span class="line">                result.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(s, start, i))&#123;</span><br><span class="line">                s = s.substring(<span class="number">0</span>, i + <span class="number">1</span>) + <span class="string">&quot;.&quot;</span> + s.substring(i + <span class="number">1</span>);</span><br><span class="line">                pointNum++;</span><br><span class="line">                trackBacking(s, i + <span class="number">2</span>, pointNum);</span><br><span class="line">                pointNum --;</span><br><span class="line">                s = s.substring(<span class="number">0</span>, i + <span class="number">1</span>) + s.substring(i + <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(start) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span> || s.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num * <span class="number">10</span> + (s.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(num &gt; <span class="number">255</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode78-子集"><a href="#Leetcode78-子集" class="headerlink" title="Leetcode78 子集"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">Leetcode78 子集</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220510110717812.png" alt="image-20220510110717812"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        trackBacking(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trackBacking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">        <span class="keyword">if</span>(start == nums.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            trackBacking(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode90-子集-II"><a href="#Leetcode90-子集-II" class="headerlink" title="Leetcode90. 子集 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/">Leetcode90. 子集 II</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220510111010860.png" alt="image-20220510111010860"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">//排序</span></span><br><span class="line">        trackBacking(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trackBacking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            trackBacking(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode491-递增子序列"><a href="#Leetcode491-递增子序列" class="headerlink" title="Leetcode491 递增子序列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/increasing-subsequences/">Leetcode491 递增子序列</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220510112431306.png" alt="image-20220510112431306"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">         trackBacking(nums, <span class="number">0</span>);</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trackBacking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] used = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">201</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//used用于去重，为什么不用邻近是因为求数组顺序不能排序</span></span><br><span class="line">            <span class="keyword">if</span>(!path.isEmpty() &amp;&amp; path.get(path.size() - <span class="number">1</span>) &gt; nums[i] || used[nums[i] + <span class="number">100</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[nums[i] + <span class="number">100</span>] = <span class="number">1</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            trackBacking(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Leetcode46-全排列"><a href="#Leetcode46-全排列" class="headerlink" title="Leetcode46 全排列"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">Leetcode46 全排列</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220510125823839.png" alt="image-20220510125823839"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] isUsed;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        isUsed = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        trackBacking(nums);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trackBacking</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == nums.length)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isUsed[i]) <span class="keyword">continue</span>;</span><br><span class="line">            isUsed[i] = <span class="literal">true</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            trackBacking(nums);</span><br><span class="line">            isUsed[i] = <span class="literal">false</span>;</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode47-全排列-II"><a href="#Leetcode47-全排列-II" class="headerlink" title="Leetcode47 全排列 II"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations-ii/">Leetcode47 全排列 II</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220510125937703.png" alt="image-20220510125937703"></p>
<p>不仅要去重还要把同一层的元素进行去重</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] isUsed = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">21</span>];</span><br><span class="line">        Arrays.fill(isUsed, <span class="literal">false</span>);</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        trackBacking(nums, isUsed);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trackBacking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] isUsed)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == nums.length)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !isUsed[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!isUsed[i])&#123;</span><br><span class="line">                isUsed[i] = <span class="literal">true</span>;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                trackBacking(nums, isUsed);</span><br><span class="line">                path.removeLast();</span><br><span class="line">                isUsed[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode332-重新安排行程"><a href="#Leetcode332-重新安排行程" class="headerlink" title="*Leetcode332 重新安排行程"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reconstruct-itinerary/">*Leetcode332 重新安排行程</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220510131703472.png" alt="image-20220510131703472"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;String&gt; res;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Map&lt;String, Integer&gt;&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> ticketNum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.size() == ticketNum + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">last</span> <span class="operator">=</span> res.getLast();</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(last))&#123;<span class="comment">//防止出现null</span></span><br><span class="line">            <span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; target : map.get(last).entrySet())&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> target.getValue();</span><br><span class="line">                <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    res.add(target.getKey());</span><br><span class="line">                    target.setValue(count - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(backTracking(ticketNum)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    res.removeLast();</span><br><span class="line">                    target.setValue(count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Map&lt;String, Integer&gt;&gt;();</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; t : tickets)&#123;</span><br><span class="line">            Map&lt;String, Integer&gt; temp;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(t.get(<span class="number">0</span>)))&#123;</span><br><span class="line">                temp = map.get(t.get(<span class="number">0</span>));</span><br><span class="line">                temp.put(t.get(<span class="number">1</span>), temp.getOrDefault(t.get(<span class="number">1</span>), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();<span class="comment">//升序Map</span></span><br><span class="line">                temp.put(t.get(<span class="number">1</span>), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(t.get(<span class="number">0</span>), temp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        backTracking(tickets.size());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode51-N-皇后"><a href="#Leetcode51-N-皇后" class="headerlink" title="Leetcode51 N 皇后"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/">Leetcode51 N 皇后</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220510132049606.png" alt="image-20220510132049606"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">         <span class="type">char</span>[][] chessBoard = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">char</span>[] chess : chessBoard)&#123;</span><br><span class="line">             Arrays.fill(chess, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         trackBacking(chessBoard, <span class="number">0</span>, n);</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trackBacking</span><span class="params">(<span class="type">char</span>[][] chessBoard, <span class="type">int</span> row, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == n)&#123;</span><br><span class="line">            result.add(arrayToList(chessBoard));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; n; col ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isTrue(chessBoard, row, col, n))&#123;</span><br><span class="line">                chessBoard[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                trackBacking(chessBoard, row + <span class="number">1</span>, n);</span><br><span class="line">                chessBoard[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List <span class="title function_">arrayToList</span><span class="params">(<span class="type">char</span>[][] chessBoard)</span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c : chessBoard)&#123;</span><br><span class="line">            list.add(String.copyValueOf(c));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isTrue</span><span class="params">(<span class="type">char</span>[][] chessBoard, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chessBoard[i][col] == <span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chessBoard[row][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chessBoard[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chessBoard[i][j] == <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode37-解数独"><a href="#Leetcode37-解数独" class="headerlink" title="*Leetcode37 解数独"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sudoku-solver/">*Leetcode37 解数独</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220510135938518.png" alt="image-20220510135938518"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        trackBacking(board);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">trackBacking</span><span class="params">(<span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(board[i][j] != <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                     <span class="keyword">continue</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">for</span>(<span class="type">char</span> <span class="variable">k</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>; k &lt;= <span class="string">&#x27;9&#x27;</span>; k++)&#123;</span><br><span class="line">                     <span class="keyword">if</span>(isValid(i, j, k, board))&#123;</span><br><span class="line">                         board[i][j] = k;</span><br><span class="line">                         <span class="keyword">if</span>(trackBacking(board))&#123;</span><br><span class="line">                             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                         &#125;</span><br><span class="line">                         board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">char</span> val, <span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] == val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[row][i] == val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rowIndex</span> <span class="operator">=</span> (row / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">colIndex</span> <span class="operator">=</span> (col / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> rowIndex; i &lt; rowIndex + <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> colIndex; j &lt; colIndex + <span class="number">3</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/29/%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/29/%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE/" class="post-title-link" itemprop="url">数组查找</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-29 23:47:44" itemprop="dateCreated datePublished" datetime="2022-03-29T23:47:44+08:00">2022-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-27 15:14:18" itemprop="dateModified" datetime="2022-04-27T15:14:18+08:00">2022-04-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Leetcode704-二分查找-704-二分查找-力扣（LeetCode）-leetcode-cn-com"><a href="#Leetcode704-二分查找-704-二分查找-力扣（LeetCode）-leetcode-cn-com" class="headerlink" title="[Leetcode704 二分查找](704. 二分查找 - 力扣（LeetCode） (leetcode-cn.com))"></a>[Leetcode704 二分查找](<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找 - 力扣（LeetCode） (leetcode-cn.com)</a>)</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE/image-20220426112026398.png" alt="image-20220426112026398"></p>
<p>解法一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = nums.length - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + right + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">if</span>(nums[mid] &lt;= target) left = mid;</span><br><span class="line">               <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> nums[right] == target ? right : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法二</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = nums.length - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">if</span>(nums[mid] &gt;= target) right = mid;</span><br><span class="line">               <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Leetcode27-移除元素-Loading-Question…-力扣（LeetCode）-leetcode-cn-com"><a href="#Leetcode27-移除元素-Loading-Question…-力扣（LeetCode）-leetcode-cn-com" class="headerlink" title="[Leetcode27 移除元素](Loading Question… - 力扣（LeetCode） (leetcode-cn.com))"></a>[Leetcode27 移除元素](<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-element/">Loading Question… - 力扣（LeetCode） (leetcode-cn.com)</a>)</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE/image-20220427110535974.png" alt="image-20220427110535974"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">              <span class="keyword">if</span>(nums[i] != val)&#123;</span><br><span class="line">                  nums[idx++] = nums[i];  <span class="comment">//不同idx才加一，相同直接跳过该元素</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Leetcode977-有序数组的平方-Loading-Question…-力扣（LeetCode）-leetcode-cn-com"><a href="#Leetcode977-有序数组的平方-Loading-Question…-力扣（LeetCode）-leetcode-cn-com" class="headerlink" title="[Leetcode977 有序数组的平方](Loading Question… - 力扣（LeetCode） (leetcode-cn.com))"></a>[Leetcode977 有序数组的平方](<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">Loading Question… - 力扣（LeetCode） (leetcode-cn.com)</a>)</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE/image-20220426112611025.png" alt="image-20220426112611025"></p>
<h4 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h4><p>思路，先将所有平方求出来，然后进行排序，时间复杂度O（nlog n）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">              nums[i] *= nums[i];</span><br><span class="line">          &#125;</span><br><span class="line">          Arrays.sort(nums);</span><br><span class="line">          <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>思路：开辟一个新数组，左右边分别都是大的值，只需把最大的值依次放到从右到左的方向即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length - <span class="number">1</span> ; i &lt;= j ;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] * nums[i] &lt;= nums[j] * nums[j])&#123;</span><br><span class="line">               arr[k--] = nums[j] * nums[j--];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                arr[k--] = nums[i] * nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Leetcode-209-长度最小的子数组"><a href="#Leetcode-209-长度最小的子数组" class="headerlink" title="Leetcode 209 长度最小的子数组"></a>Leetcode 209 长度最小的子数组</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE/image-20220426145829992.png" alt="image-20220426145829992"></p>
<h4 id="双指针-x2F-滑动窗口"><a href="#双指针-x2F-滑动窗口" class="headerlink" title="双指针&#x2F;滑动窗口"></a>双指针&#x2F;滑动窗口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minLength</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;j &lt; nums.length; j++)&#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                minLength = Math.min(minLength, j - i + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">return</span> <span class="variable">minLength</span> <span class="operator">=</span>= Integer.MAX_VALUE ? <span class="number">0</span> : minLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Leetcode59-螺旋矩阵Ⅱ"><a href="#Leetcode59-螺旋矩阵Ⅱ" class="headerlink" title="Leetcode59 螺旋矩阵Ⅱ"></a>Leetcode59 螺旋矩阵Ⅱ</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE/image-20220426151906672.png" alt="image-20220426151906672"></p>
<p>左闭右开的原则进行填充</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> n/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startX</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startY</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> n/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(loop &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startX;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> startY;</span><br><span class="line">            <span class="keyword">for</span>(; j &lt; startY + n - index; j++)&#123;</span><br><span class="line">                res[startX][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(; i &lt; startX + n - index; i++)&#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(; j &gt; startY; j--)&#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(; i &gt; startX; i--)&#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            loop -= <span class="number">1</span>;</span><br><span class="line">            startX += <span class="number">1</span>;</span><br><span class="line">            startY += <span class="number">1</span>;</span><br><span class="line">            index += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            res[mid][mid] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/29/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/29/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">栈与队列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-29 23:47:44" itemprop="dateCreated datePublished" datetime="2022-03-29T23:47:44+08:00">2022-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-09 23:04:24" itemprop="dateModified" datetime="2022-05-09T23:04:24+08:00">2022-05-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Leetcode232-用栈实现队列"><a href="#Leetcode232-用栈实现队列" class="headerlink" title="Leetcode232 用栈实现队列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">Leetcode232 用栈实现队列</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE/image-20220428094417931.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1;  <span class="comment">//用于直接存储数据</span></span><br><span class="line">    Stack&lt;Integer&gt; stack2;  <span class="comment">//用于当作队列使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">          stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="keyword">if</span>(!stack2.isEmpty())&#123;</span><br><span class="line">            result = stack2.pop();   <span class="comment">//如果stack2不为空则说明当前队列里面有元素，不需要新加元素</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop()); <span class="comment">//stack2为空，则把stack1所有元素压入，实现先进先出</span></span><br><span class="line">            &#125;</span><br><span class="line">            result = stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="keyword">if</span>(!stack2.isEmpty())&#123;</span><br><span class="line">            result = stack2.peek();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">            result = stack2.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(stack2.isEmpty() &amp;&amp; stack1.isEmpty()) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//都为空时说明队列内没有元素</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h2 id="Leetcode225-用队列实现栈"><a href="#Leetcode225-用队列实现栈" class="headerlink" title="Leetcode225 用队列实现栈"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-stack-using-queues/">Leetcode225 用队列实现栈</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE/image-20220428100343382.png" alt="image-20220428100343382"></p>
<p>两个队列实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; in;</span><br><span class="line">    Queue&lt;Integer&gt; out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        in =  <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        out = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">       in.offer(x);</span><br><span class="line">       <span class="keyword">while</span>(!out.isEmpty())&#123;</span><br><span class="line">        in.offer(out.poll());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">Queue</span> <span class="variable">temp</span> <span class="operator">=</span> in;   <span class="comment">//out和in进行交换保证栈的实现</span></span><br><span class="line">       in = out; </span><br><span class="line">       out = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> out.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> out.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> in.isEmpty() &amp;&amp; out.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Leetcode20-有效的括号"><a href="#Leetcode20-有效的括号" class="headerlink" title="Leetcode20 有效的括号"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses/">Leetcode20 有效的括号</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220505212936829.png" alt="image-20220505212936829"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="comment">//左边括号直接压栈</span></span><br><span class="line">           <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;(&#x27;</span> || s.charAt(i) == <span class="string">&#x27;&#123;&#x27;</span> || s.charAt(i) == <span class="string">&#x27;[&#x27;</span>)&#123; </span><br><span class="line">               stack.push(s.charAt(i));</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//没有可匹配的不成立</span></span><br><span class="line">               <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">               <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;)&#x27;</span> &amp;&amp; tmp != <span class="string">&#x27;(&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;]&#x27;</span> &amp;&amp; tmp != <span class="string">&#x27;[&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; tmp != <span class="string">&#x27;&#123;&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode1047-删除字符串中的所有相邻重复项"><a href="#Leetcode1047-删除字符串中的所有相邻重复项" class="headerlink" title="Leetcode1047 删除字符串中的所有相邻重复项"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">Leetcode1047 删除字符串中的所有相邻重复项</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220506060549418.png" alt="image-20220506060549418"></p>
<h3 id="传统栈解法"><a href="#传统栈解法" class="headerlink" title="传统栈解法"></a>传统栈解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                stack.push(s.charAt(i));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.peek() == s.charAt(i))&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    stack.push(s.charAt(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">           str += stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str).reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="直接用字符数组解法-与27-移除元素相似"><a href="#直接用字符数组解法-与27-移除元素相似" class="headerlink" title="直接用字符数组解法 与27. 移除元素相似"></a>直接用字符数组解法 与<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-element/">27. 移除元素</a>相似</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ch.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(top == -<span class="number">1</span> || ch[top] != ch[i])&#123;</span><br><span class="line">                ch[++top] = ch[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                top--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(ch, <span class="number">0</span>, top + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode150-逆波兰表达式求值"><a href="#Leetcode150-逆波兰表达式求值" class="headerlink" title="Leetcode150 逆波兰表达式求值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">Leetcode150 逆波兰表达式求值</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220506062656397.png" alt="image-20220506062656397"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(tokens == <span class="literal">null</span> || tokens.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String token : tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(token.equals(<span class="string">&quot;+&quot;</span>) || token.equals(<span class="string">&quot;-&quot;</span>) || token.equals(<span class="string">&quot;*&quot;</span>) || token.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> stack.pop(), b = stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(token.equals(<span class="string">&quot;+&quot;</span>)) b += a;</span><br><span class="line">                <span class="keyword">if</span>(token.equals(<span class="string">&quot;-&quot;</span>)) b -= a;</span><br><span class="line">                <span class="keyword">if</span>(token.equals(<span class="string">&quot;*&quot;</span>)) b *= a;</span><br><span class="line">                <span class="keyword">if</span>(token.equals(<span class="string">&quot;/&quot;</span>)) b /= a;</span><br><span class="line">                stack.push(b); <span class="comment">//更新操作数</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(Integer.parseInt(token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode239-滑动窗口最大值"><a href="#Leetcode239-滑动窗口最大值" class="headerlink" title="Leetcode239 滑动窗口最大值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sliding-window-maximum/">Leetcode239 滑动窗口最大值</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220506062918364.png" alt="image-20220506062918364"></p>
<h4 id="数组模拟单调队列解法"><a href="#数组模拟单调队列解法" class="headerlink" title="数组模拟单调队列解法"></a>数组模拟单调队列解法</h4><p>数组模拟解法在Leetcode中比使用双端队列快三倍</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">hh</span> <span class="operator">=</span> <span class="number">0</span>, tt = -<span class="number">1</span>, n = nums.length;</span><br><span class="line">         <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">         <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">         <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; queue[hh]) hh++;</span><br><span class="line">             <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; nums[queue[tt]] &lt;= nums[i]) tt--;</span><br><span class="line">             queue[++tt] = i; </span><br><span class="line">             <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) a[b++] = nums[queue[hh]];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[b];</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;b; i++)&#123;</span><br><span class="line">             c[i] = a[i];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双端队列解法"><a href="#双端队列解法" class="headerlink" title="双端队列解法"></a>双端队列解法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">         Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">         <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">         <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">         <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">              <span class="comment">//滑到下一个窗口，删除队首</span></span><br><span class="line">              <span class="keyword">if</span>(!queue.isEmpty() &amp;&amp; i - k + <span class="number">1</span> &gt; queue.getFirst()) queue.removeFirst(); </span><br><span class="line">              <span class="comment">//如果当前元素大，删除当前元素</span></span><br><span class="line">              <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; nums[queue.getLast()] &lt;= nums[i]) queue.removeLast(); </span><br><span class="line">              queue.offerLast(i);</span><br><span class="line">              <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) a[b++] = nums[queue.getFirst()];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode347-前-K-个高频元素"><a href="#Leetcode347-前-K-个高频元素" class="headerlink" title="Leetcode347 前 K 个高频元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/top-k-frequent-elements/">Leetcode347 前 K 个高频元素</a></h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220506073522607.png" alt="image-20220506073522607"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//构建一个Freq类来存储元素key与其出现次数times</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Freq</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Freq&gt;&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> key;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> times;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Freq</span><span class="params">(<span class="type">int</span> key,<span class="type">int</span> times)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.times = times;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//实现比较方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Freq o)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.times-o.times;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            map.put(nums[i],<span class="number">1</span>+ map.getOrDefault(nums[i],<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//queue中的每个对象属于Freq类,同时保存key及其出现次数times</span></span><br><span class="line">        PriorityQueue&lt;Freq&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历map,找出前k个高的频率存储到queue中</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry: map.entrySet())&#123;</span><br><span class="line">            <span class="comment">//先随便挑选k个对象入队</span></span><br><span class="line">            <span class="keyword">if</span>(queue.size()&lt;k)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">Freq</span>(entry.getKey(),entry.getValue()));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//比较times,times大于堆顶元素的times则入队,同时堆顶元素出队保证整个队列中只有k个元素</span></span><br><span class="line">                <span class="keyword">if</span>(entry.getValue() &gt; queue.peek().times)&#123;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">Freq</span>(entry.getKey(),entry.getValue()));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ret = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            ret[i] = queue.poll().key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>代码参考[.前K个高频元素 Java](<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/top-k-frequent-elements/solution/by-matousakura-geyc/">347.前K个高频元素 Java - 前 K 个高频元素 - 力扣（LeetCode） (leetcode-cn.com)</a>)</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/29/%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/29/%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">链表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-29 23:47:44" itemprop="dateCreated datePublished" datetime="2022-03-29T23:47:44+08:00">2022-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-27 15:14:55" itemprop="dateModified" datetime="2022-04-27T15:14:55+08:00">2022-04-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Leetcode203-移除链表元素-203-移除链表元素-力扣（LeetCode）-leetcode-cn-com"><a href="#Leetcode203-移除链表元素-203-移除链表元素-力扣（LeetCode）-leetcode-cn-com" class="headerlink" title="[Leetcode203 移除链表元素](203. 移除链表元素 - 力扣（LeetCode） (leetcode-cn.com))"></a>[Leetcode203 移除链表元素](<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203. 移除链表元素 - 力扣（LeetCode） (leetcode-cn.com)</a>)</h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE/image-20220427105845808.png" alt="image-20220427105845808"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">          <span class="type">ListNode</span> <span class="variable">deamon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">          deamon.next=head;   <span class="comment">//哨兵结点，负责防止头指针也需要被删去，或头指针为空状态</span></span><br><span class="line">          <span class="type">ListNode</span> <span class="variable">deamon1</span> <span class="operator">=</span> deamon;</span><br><span class="line">          <span class="keyword">while</span>(deamon.next != <span class="literal">null</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span>(deamon.next.val == val) deamon.next = deamon.next.next;</span><br><span class="line">              <span class="keyword">else</span> deamon = deamon.next;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> deamon1.next;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Leetcode707-设计链表-707-设计链表-力扣（LeetCode）-leetcode-cn-com"><a href="#Leetcode707-设计链表-707-设计链表-力扣（LeetCode）-leetcode-cn-com" class="headerlink" title="[Leetcode707 设计链表](707. 设计链表 - 力扣（LeetCode） (leetcode-cn.com))"></a>[Leetcode707 设计链表](<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/design-linked-list/">707. 设计链表 - 力扣（LeetCode） (leetcode-cn.com)</a>)</h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE/image-20220426155702173.png" alt="image-20220426155702173"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    LinkNode next;</span><br><span class="line">    LinkNode()&#123;&#125;</span><br><span class="line">    LinkNode(<span class="type">int</span> val)&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    LinkNode head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">         size = <span class="number">0</span>;</span><br><span class="line">         head = <span class="keyword">new</span> <span class="title class_">LinkNode</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= size)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LinkNode</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++)&#123;</span><br><span class="line">             prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">         addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">         addAtIndex(size, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">           <span class="keyword">if</span>(index &gt; size)&#123;</span><br><span class="line">               <span class="keyword">return</span> ;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">               index = <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           size++;</span><br><span class="line">           <span class="type">LinkNode</span> <span class="variable">prev</span> <span class="operator">=</span> head;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">               prev = prev.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">LinkNode</span> <span class="variable">toAdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkNode</span>(val);</span><br><span class="line">           toAdd.next = prev.next;</span><br><span class="line">           prev.next = toAdd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="type">LinkNode</span> <span class="variable">pred</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pred.next = pred.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(index);</span></span><br><span class="line"><span class="comment"> * obj.addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj.deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="Leetcode206-反转链表-707-设计链表-力扣（LeetCode）-leetcode-cn-com"><a href="#Leetcode206-反转链表-707-设计链表-力扣（LeetCode）-leetcode-cn-com" class="headerlink" title="[Leetcode206 反转链表](707. 设计链表 - 力扣（LeetCode） (leetcode-cn.com))"></a>[Leetcode206 反转链表](<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/design-linked-list/">707. 设计链表 - 力扣（LeetCode） (leetcode-cn.com)</a>)</h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE/image-20220426203654876.png" alt="image-20220426203654876"></p>
<p>递归版</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">          ListNode p=reverseList(head.next);</span><br><span class="line">          head.next.next=head;</span><br><span class="line">          head.next=<span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;ev</span><br></pre></td></tr></table></figure>

<p>迭代版</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span>(head == <span class="literal">null</span>)  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">          <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">while</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">              <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span>  head.next;</span><br><span class="line">              head.next = newHead;</span><br><span class="line">              newHead = head;</span><br><span class="line">              head = tmp; </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> newHead;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Leetcode24-两两交换链表中的节点-24-两两交换链表中的节点-力扣（LeetCode）-leetcode-cn-com"><a href="#Leetcode24-两两交换链表中的节点-24-两两交换链表中的节点-力扣（LeetCode）-leetcode-cn-com" class="headerlink" title="[Leetcode24 两两交换链表中的节点](24. 两两交换链表中的节点 - 力扣（LeetCode） (leetcode-cn.com))"></a>[Leetcode24 两两交换链表中的节点](<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点 - 力扣（LeetCode） (leetcode-cn.com)</a>)</h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE/image-20220427093501939.png" alt="image-20220427093501939"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    dummyNode.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummyNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (prev.next != <span class="literal">null</span> &amp;&amp; prev.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next.next; <span class="comment">// 缓存 next</span></span><br><span class="line">      prev.next = head.next;          <span class="comment">// 将 prev 的 next 改为 head 的 next 1 </span></span><br><span class="line">      head.next.next = head;          <span class="comment">// 将 head.next(prev.next) 的next，指向 head 2</span></span><br><span class="line">      head.next = temp;               <span class="comment">// 将head 的 next 接上缓存的temp 3</span></span><br><span class="line">      prev = head;                    <span class="comment">// 步进1位 4</span></span><br><span class="line">      head = head.next;               <span class="comment">// 步进1位 4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE/image-20220427091505724.png" alt="image-20220427091505724"></p>
<h2 id="Leetcode19-删除链表的倒数第N个结点-19-删除链表的倒数第-N-个结点-力扣（LeetCode）-leetcode-cn-com"><a href="#Leetcode19-删除链表的倒数第N个结点-19-删除链表的倒数第-N-个结点-力扣（LeetCode）-leetcode-cn-com" class="headerlink" title="[Leetcode19 删除链表的倒数第N个结点](19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode） (leetcode-cn.com))"></a>[Leetcode19 删除链表的倒数第N个结点](<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/submissions/">19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode） (leetcode-cn.com)</a>)</h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE/image-20220427092407759.png" alt="image-20220427092407759"></p>
<p>本质是数学问题，设原结点总数为x，因为加了哨兵结点所以为x+1，走到倒数第n个点需要步数为x-n+1步，所以先让快指针走n步，然后快指针到null还需要x-n+1步，恰好与到倒数第n个点步数相同，因而使用快慢指针，又因为要删除倒数第n个结点，所以只需走到最后一个结点即可（即慢指针会走向要删除结点的前一个结点）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">       dummy.next = head;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dummy;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummy;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">           fast = fast.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span>(fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">           slow = slow.next;</span><br><span class="line">           fast = fast.next;</span><br><span class="line">       &#125;</span><br><span class="line">       slow.next = slow.next.next;</span><br><span class="line">       <span class="keyword">return</span> dummy.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Leetcode160-相交链表-160-相交链表-力扣（LeetCode）-leetcode-cn-com"><a href="#Leetcode160-相交链表-160-相交链表-力扣（LeetCode）-leetcode-cn-com" class="headerlink" title="[Leetcode160 相交链表](160. 相交链表 - 力扣（LeetCode） (leetcode-cn.com))"></a>[Leetcode160 相交链表](<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表 - 力扣（LeetCode） (leetcode-cn.com)</a>)</h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE/image-20220427102016849.png" alt="image-20220427102016849"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span>(headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">         <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> headA;</span><br><span class="line">         <span class="type">ListNode</span> <span class="variable">b</span> <span class="operator">=</span> headB;</span><br><span class="line">         <span class="keyword">while</span>(a != b)&#123;</span><br><span class="line">             a = a == <span class="literal">null</span> ? headB : a.next;  <span class="comment">//走到null，换为B表，否则指向下一个位置</span></span><br><span class="line">             b = b == <span class="literal">null</span> ? headA : b.next;  <span class="comment">//走到null，换为A表，否则指向下一个位置</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE/image-20220427102433788.png" alt="image-20220427102433788"></p>
<p>设相交长度为b，设A链表不相交的长度为a，设C链表不相交的长度为b</p>
<p>A表走到重合处需要步数 a + c + b</p>
<p>B表走到重合处需要步数 c+ b + a</p>
<p>所以一旦A表为null，则走到B表，B表走到null，则指向A表，二者相等即为重合，如果不相等则二者均为null</p>
<h2 id="Leetcode142-环形链表Ⅱ-142-环形链表-II-力扣（LeetCode）-leetcode-cn-com"><a href="#Leetcode142-环形链表Ⅱ-142-环形链表-II-力扣（LeetCode）-leetcode-cn-com" class="headerlink" title="[Leetcode142 环形链表Ⅱ](142. 环形链表 II - 力扣（LeetCode） (leetcode-cn.com))"></a>[Leetcode142 环形链表Ⅱ](<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II - 力扣（LeetCode） (leetcode-cn.com)</a>)</h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE/image-20220427103411343.png" alt="image-20220427103411343"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;<span class="comment">// 有环</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index1</span> <span class="operator">=</span> fast;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index2</span> <span class="operator">=</span> head;</span><br><span class="line">                <span class="comment">// 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口</span></span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE/image-20220427104754167.png" alt="image-20220427104754167"></p>
<p>设成环的长度为c，设快指针走到重合时步数为f，慢指针走到重合时步数为s</p>
<p>则有<br>$$<br>2*s &#x3D; f<br>$$<br>且有<br>$$<br>s + nc &#x3D; f<br>$$<br>合并则有<br>$$<br>s&#x3D;nc<br>$$<br>二者重合时，s&#x3D;nc，所以走了n倍的周长，此时当新指针走向a步时，此时有slow指针走到a+nc，此时两指针重合。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/01/JUC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/01/JUC/" class="post-title-link" itemprop="url">JUC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-01 23:47:44" itemprop="dateCreated datePublished" datetime="2022-03-01T23:47:44+08:00">2022-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-21 13:56:10" itemprop="dateModified" datetime="2022-04-21T13:56:10+08:00">2022-04-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">Java知识</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="线程有哪几种状态"><a href="#线程有哪几种状态" class="headerlink" title="线程有哪几种状态"></a>线程有哪几种状态</h2><p><strong>六种状态及转换</strong></p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831090722658.png" alt="image-20210831090722658"></p>
<p>分别是</p>
<ul>
<li>新建<ul>
<li>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态</li>
<li>此时未与操作系统底层线程关联</li>
</ul>
</li>
<li>可运行<ul>
<li>调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong></li>
<li>此时与底层线程关联，由操作系统调度执行</li>
</ul>
</li>
<li>终结<ul>
<li>线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong></li>
<li>此时会取消与底层线程关联</li>
</ul>
</li>
<li>阻塞<ul>
<li>当获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，此时不占用 cpu 时间</li>
<li>当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</li>
</ul>
</li>
<li>等待<ul>
<li>当获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合<strong>等待</strong>，同样不占用 cpu 时间</li>
<li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>等待</strong>线程，恢复为<strong>可运行</strong>状态</li>
</ul>
</li>
<li>有时限等待<ul>
<li>当获取锁成功后，但由于条件不满足，调用了 wait(long) 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合进行<strong>有时限等待</strong>，同样不占用 cpu 时间</li>
<li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>有时限等待</strong>线程，恢复为<strong>可运行</strong>状态，并重新去竞争锁</li>
<li>如果等待超时，也会从<strong>有时限等待</strong>状态恢复为<strong>可运行</strong>状态，并重新去竞争锁</li>
<li>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，但与 Monitor 无关，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</li>
</ul>
</li>
</ul>
<blockquote>
<p><em><strong>其它情况（只需了解）</strong></em></p>
<ul>
<li>可以用 interrupt() 方法打断<strong>等待</strong>、<strong>有时限等待</strong>的线程，让它们恢复为<strong>可运行</strong>状态</li>
<li>park，unpark 等方法也可以让线程等待和唤醒</li>
</ul>
</blockquote>
<h2 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h2><h3 id="七大参数"><a href="#七大参数" class="headerlink" title="七大参数"></a>七大参数</h3><ol>
<li>corePoolSize 核心线程数目 - 池中会保留的最多线程数</li>
<li>maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目</li>
<li>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</li>
<li>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</li>
<li>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</li>
<li>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li>
<li>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略<ol>
<li>丢弃任务并抛异常 java.util.concurrent.ThreadPoolExecutor.AbortPolicy</li>
<li>由调用者线程执行任务 java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy</li>
<li>丢弃任务并不抛出异常 java.util.concurrent.ThreadPoolExecutor.DiscardPolicy</li>
<li>丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy</li>
</ol>
</li>
</ol>
<h3 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h3><ol>
<li>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</li>
<li>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排<br>队，直到有空闲的线程。</li>
<li>如果队列选择了<strong>有界队列</strong>，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急。</li>
<li>如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 下面的前4 种实现，其它著名框架也提供了实现<ol>
<li>ThreadPoolExecutor.AbortPolicy让调用者抛出 RejectedExecutionException 异常，这是默认策略</li>
<li>ThreadPoolExecutor.CallerRunsPolicy 让调用者运行任务</li>
<li>ThreadPoolExecutor.DiscardPolicy 放弃本次任务</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之</li>
<li>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题</li>
<li>Netty 的实现，是创建一个新线程来执行任务</li>
<li>ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略</li>
<li>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li>
</ol>
</li>
<li>当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由<br>keepAliveTime 和 unit 来控制。</li>
</ol>
<h3 id="三个实现类"><a href="#三个实现类" class="headerlink" title="三个实现类"></a>三个实现类</h3><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><ol>
<li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间</li>
<li>阻塞队列是无界的，可以放任意数量的任务</li>
<li>适用于任务量已知，相对耗时的任务</li>
</ol>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><ol>
<li>核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着<ol>
<li>全部都是救急线程（60s 后可以回收）</li>
<li>救急线程可以无限创建</li>
</ol>
</li>
<li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）SynchronousQueue</li>
</ol>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><p>使用场景：</p>
<ol>
<li><p>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</p>
</li>
<li><p>区别：</p>
<ol>
<li><p>和自己创建单线程执行任务的区别：自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作</p>
</li>
<li><p>Executors.newSingleThreadExecutor() <strong>线程个数始终为1，不能修改</strong></p>
<ol>
<li>FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法</li>
</ol>
</li>
<li><p>和Executors.newFixedThreadPool(1) 初始时为1时的区别：</p>
<p>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改，对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</p>
</li>
</ol>
</li>
</ol>
<p>说白了就是：使用有界队列，控制线程创建数量。</p>
<p>除了避免 OOM 的原因之外，不推荐使用 <code>Executors</code>提供的两种快捷的线程池的原因还有：</p>
<ol>
<li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。</li>
<li>我们应该显示地给我们的线程池命名，这样有助于我们定位问题。</li>
</ol>
<h2 id="wait-vs-sleep"><a href="#wait-vs-sleep" class="headerlink" title="wait vs sleep"></a>wait vs sleep</h2><p><strong>一个共同点，三个不同点</strong></p>
<p>共同点</p>
<ul>
<li>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</li>
</ul>
<p>不同点</p>
<ul>
<li><p>方法归属不同</p>
<ul>
<li>sleep(long) 是 Thread 的静态方法</li>
<li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</li>
</ul>
</li>
<li><p>醒来时机不同</p>
<ul>
<li>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li>
<li>wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</li>
<li>它们都可以被打断唤醒</li>
</ul>
</li>
<li><p>锁特性不同（重点）</p>
<ul>
<li>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</li>
<li>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</li>
<li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</li>
</ul>
</li>
</ul>
<h2 id="lock-vs-synchronized"><a href="#lock-vs-synchronized" class="headerlink" title="lock vs synchronized"></a>lock vs synchronized</h2><p>synchronized</p>
<ul>
<li>对于普通同步方法，锁是当前实例对象</li>
<li>对于静态同步方法，锁是当前类的Class对象</li>
<li>对于同步代码块，锁是Synchronized括号里配置的对象</li>
</ul>
<p><strong>三个层面</strong></p>
<p>不同点</p>
<ul>
<li>语法层面<ul>
<li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现</li>
<li>Lock 是接口，源码由 jdk 提供，用 java 语言实现</li>
<li>使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁</li>
</ul>
</li>
<li>功能层面<ul>
<li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li>
<li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量</li>
<li>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock</li>
<li>snchronized是非公平锁，lock可以设置为公平锁或者非公平锁</li>
<li>synchronized修饰的代码在执行异常时，jdk会自动释放线程占有的锁，不需要程序员去控制释放锁，因此不会导致死锁现象发生；但是，当Lock发生异常时，如果程序没有通过unLock()去释放锁，则很可能造成死锁现象，因此Lock一般都是在finally块中释放锁；</li>
</ul>
</li>
<li>性能层面<ul>
<li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li>
<li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li>
</ul>
</li>
</ul>
<p><strong>公平锁</strong></p>
<ul>
<li>公平锁的公平体现<ul>
<li><strong>已经处在阻塞队列</strong>中的线程（不考虑超时）始终都是公平的，先进先出</li>
<li>公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，如果队列不为空，则老实到队尾等待</li>
<li>非公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，与队列头唤醒的线程去竞争，谁抢到算谁的</li>
</ul>
</li>
<li>公平锁会降低吞吐量，一般不用</li>
</ul>
<p><strong>条件变量</strong></p>
<ul>
<li>ReentrantLock 中的条件变量功能类似于普通 synchronized 的 wait，notify，用在当线程获得锁后，发现条件不满足时，临时等待的链表结构</li>
<li>与 synchronized 的等待集合不同之处在于，ReentrantLock 中的条件变量可以有多个，可以实现更精细的等待、唤醒控制</li>
</ul>
<blockquote>
<p><em><strong>代码说明</strong></em></p>
<ul>
<li>day02.TestReentrantLock 用较为形象的方式演示 ReentrantLock 的内部结构</li>
</ul>
</blockquote>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>线程安全要考虑三个方面</p>
<ol>
<li>可见性：一个线程对共享变量修改，另一个线程能看到最新的结果</li>
<li>有序性：一个线程内代码按编写顺序执行</li>
<li>原子性：一个线程内多行代码以一个整体运行，期间不能有其他的代码插队</li>
</ol>
<p>volatile只能保证共享变量的可见性和有序性，但并不能保证原子性</p>
<p><strong>原子性</strong></p>
<ul>
<li>起因：多线程下，不同线程的<strong>指令发生了交错</strong>导致的共享变量的读写混乱</li>
<li>解决：用悲观锁或乐观锁解决，volatile 并不能解决原子性</li>
</ul>
<p><strong>可见性</strong></p>
<p>JIT把多次运行的代码替换掉，使得每次读取的都为false</p>
<ul>
<li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致的对共享变量所做的修改另外的线程看不到</li>
<li>解决：用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</li>
</ul>
<p><strong>有序性</strong></p>
<ul>
<li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致指令的实际执行顺序与编写顺序不一致</li>
<li>解决：用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</li>
<li>注意：<ul>
<li><strong>volatile 变量写</strong>加的屏障是阻止上方其它写操作越过屏障排到 <strong>volatile 变量写</strong>之下</li>
<li><strong>volatile 变量读</strong>加的屏障是阻止下方其它读操作越过屏障排到 <strong>volatile 变量读</strong>之上</li>
<li>volatile 读写加入的屏障只能防止同一线程内的指令重排</li>
</ul>
</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220322100227889.png" alt="image-20220322100227889"></p>
<h2 id="6-悲观锁-vs-乐观锁"><a href="#6-悲观锁-vs-乐观锁" class="headerlink" title="6. 悲观锁 vs 乐观锁"></a>6. 悲观锁 vs 乐观锁</h2><p><strong>对比悲观锁与乐观锁</strong></p>
<ul>
<li><p>悲观锁的代表是 synchronized 和 Lock 锁</p>
<ul>
<li>其核心思想是【线程只有占有了锁，才能去操作共享变量，每次只有一个线程占锁成功，获取锁失败的线程，都得停下来等待】</li>
<li>线程从运行到阻塞、再从阻塞到唤醒，涉及线程上下文切换，如果频繁发生，影响性能</li>
<li>实际上，线程在获取 synchronized 和 Lock 锁时，如果锁已被占用，都会做几次重试操作，减少阻塞的机会</li>
</ul>
</li>
<li><p>乐观锁的代表是 AtomicInteger，使用 cas 来保证原子性</p>
<ul>
<li>其核心思想是【无需加锁，每次只有一个线程能成功修改共享变量，其它失败的线程不需要停止，不断重试直至成功】</li>
<li>由于线程一直运行，不需要阻塞，因此不涉及线程上下文切换</li>
<li>它需要多核 cpu 支持，且线程数不应超过 cpu 核数</li>
</ul>
</li>
</ul>
<blockquote>
<p><em><strong>代码说明</strong></em></p>
<ul>
<li>day02.SyncVsCas 演示了分别使用乐观锁和悲观锁解决原子赋值</li>
<li>请同时参考视频讲解</li>
</ul>
</blockquote>
<h2 id="7-Hashtable-vs-ConcurrentHashMap"><a href="#7-Hashtable-vs-ConcurrentHashMap" class="headerlink" title="7. Hashtable vs ConcurrentHashMap"></a>7. Hashtable vs ConcurrentHashMap</h2><p><strong>要求</strong></p>
<ul>
<li>掌握 Hashtable 与 ConcurrentHashMap 的区别</li>
<li>掌握 ConcurrentHashMap 在不同版本的实现区别</li>
</ul>
<blockquote>
<p>更形象的演示，见资料中的 hash-demo.jar，运行需要 jdk14 以上环境，进入 jar 包目录，执行下面命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar --add-exports java.base/jdk.internal.misc=ALL-UNNAMED hash-demo.jar</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>Hashtable 对比 ConcurrentHashMap</strong></p>
<ul>
<li>Hashtable 与 ConcurrentHashMap 都是线程安全的 Map 集合</li>
<li>Hashtable 并发度低，整个 Hashtable 对应一把锁，同一时刻，只能有一个线程操作它</li>
<li>ConcurrentHashMap 并发度高，整个 ConcurrentHashMap 对应多把锁，只要线程访问的是不同锁，那么不会冲突</li>
</ul>
<p>HashTable每次扩容2*n+1</p>
<p><strong>ConcurrentHashMap 1.7</strong></p>
<ul>
<li>数据结构：<code>Segment(大数组容量clevel并发度不能扩容) + HashEntry(小数组) + 链表</code>，每个 Segment 对应一把锁，如果多个线程访问不同的 Segment，则不会冲突</li>
<li>*<em>capacity</em>loadfactor 为小数组的扩容值，一旦大于就扩容，各自小数组分别扩容，小数组等价于原来的HashMap的数组，<img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220322111243513.png" alt="image-20220322111243513">，初始segmment[0]小数组的容量为capacity&#x2F;clevel（最小值为2)**，其他小数组初始化根据这个[0]数组初始化</li>
<li>并发度：Segment 数组大小即并发度，决定了同一时刻最多能有多少个线程并发访问。Segment 数组不能扩容，意味着并发度在 ConcurrentHashMap 创建时就固定了</li>
<li>索引计算<ul>
<li>假设大数组长度是 $2^m$，key 在大数组内的索引是 key 的二次 hash 值的高 m 位</li>
<li>假设小数组长度是 $2^n$，key 在小数组内的索引是 key 的二次 hash 值的低 n 位</li>
</ul>
</li>
<li>扩容：每个小数组的扩容相对独立，小数组在超过扩容因子时会触发扩容，每次扩容翻倍</li>
<li>Segment[0] 原型：首次创建其它小数组时，会以此原型为依据，数组长度，扩容因子都会以原型为准</li>
</ul>
<p><strong>ConcurrentHashMap 1.8</strong></p>
<p>capcity为要放的数组元素个数，不是数组的个数，因为16放不下16个（只能放下capcity*loadfactor个数,只有初始化时会看loadfactor的值，否则按0.75计算），所以初始会为2^5即32个元素</p>
<ul>
<li>数据结构：<code>Node 数组 + 链表或红黑树</code>，数组的每个头节点作为锁，如果多个线程访问的头节点不同，则不会冲突。首次生成头节点时如果发生竞争，利用 cas 而非 syncronized，进一步提升性能</li>
<li>并发度：Node 数组有多大，并发度就有多大，与 1.7 不同，Node 数组可以扩容</li>
<li>扩容条件<strong>：Node 数组满 3&#x2F;4 时就会扩容</strong></li>
<li>扩容单位：以链表为单位从后向前迁移链表，迁移完成的将旧数组头节点替换为 ForwardingNode，当旧数组所有值都为ForwardingNode就用新数组替换。</li>
<li>扩容时并发 get<ul>
<li>根据是否为 ForwardingNode 来决定是在新数组查找还是在旧数组查找，不会阻塞</li>
<li>如果链表长度超过 1，<strong>则需要对节点进行复制（创建新节点）</strong>，怕的是节点迁移后 next 指针改变。</li>
<li>如果链表最后几个元素扩容后索引不变，则节点无需复制，</li>
</ul>
</li>
<li>扩容时并发 put<ul>
<li>如果 put 的线程与扩容线程操作的链表是同一个，put 线程会阻塞</li>
<li>如果 put 的线程操作的链表还未迁移完成，即头节点不是 ForwardingNode，则可以并发执行</li>
<li>如果 put 的线程操作的链表已经迁移完成，即头结点是 ForwardingNode，则可以协助扩容</li>
</ul>
</li>
<li>与 1.7 相比是懒惰初始化</li>
<li>capacity 代表预估的元素个数，capacity &#x2F; factory 来计算出初始数组大小，需要贴近 $2^n$ </li>
<li>loadFactor 只在计算初始数组大小时首次被使用，之后扩容固定为 3&#x2F;4</li>
<li>超过树化阈值时的扩容问题，如果容量已经是 64，直接树化，否则在原来容量基础上做 3 轮扩容</li>
</ul>
<h2 id="8-ThreadLocal"><a href="#8-ThreadLocal" class="headerlink" title="8. ThreadLocal"></a>8. ThreadLocal</h2><p><strong>作用</strong></p>
<ul>
<li>ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免争用引发的线程安全问题</li>
<li>ThreadLocal 同时实现了线程内的资源共享</li>
</ul>
<p><strong>原理</strong></p>
<p>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p>
<ul>
<li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li>
<li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li>
<li>调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li>
</ul>
<p>ThreadLocalMap 的一些特点</p>
<ul>
<li>key 的 hash 值统一分配</li>
<li>初始容量 16，扩容因子 2&#x2F;3，扩容容量翻倍</li>
<li>key 索引冲突后用开放寻址法解决冲突</li>
</ul>
<p><strong>弱引用 key</strong></p>
<p>ThreadLocalMap 中的 key 被设计为弱引用，原因如下</p>
<ul>
<li>Thread 可能需要长时间运行（如线程池中的线程），如果 key 不再使用，需要在内存不足（GC）时释放其占用的内存，如果设置为强引用不能被垃圾回收掉</li>
</ul>
<p><strong>内存释放时机</strong></p>
<ul>
<li>被动 GC 释放 key<ul>
<li>仅是让 key 的内存释放，关联 value 的内存并不会释放</li>
</ul>
</li>
<li>懒惰被动释放 value<ul>
<li>get key 时，发现是 null key，则释放其 value 内存</li>
<li>set key 时，会使用启发式扫描，清除临近的 null key 的 value 内存，启发次数与元素个数，是否发现 null key 有关</li>
</ul>
</li>
<li>主动 remove 释放 key，value<ul>
<li>会同时释放 key，value 的内存，也会清除临近的 null key 的 value 内存</li>
<li>推荐使用它，因为一般使用 ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/01/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/01/JVM/" class="post-title-link" itemprop="url">JVM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-01 23:47:44" itemprop="dateCreated datePublished" datetime="2022-03-01T23:47:44+08:00">2022-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-10 22:40:26" itemprop="dateModified" datetime="2022-05-10T22:40:26+08:00">2022-05-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">Java知识</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220315164232268.png" alt="image-20220315164232268"></p>
<p><strong>虚拟机栈</strong>描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都 会同步创建一个栈帧[1]（Stack Frame）用于<strong>存储局部变量表、操作数栈、动态连接、方法出口</strong>等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、 float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始 地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress<br>类型（指向了一条字节码指令的地址）。</p>
<p>Java<strong>堆</strong>是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。</p>
<p><strong>方法区（Method Area）</strong>与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<p>类加载会在方法区内加载，虚拟机栈包含了局部变量表和对象引用类型(stu,args),本地方法栈包含一些本地方法，而Hotspot虚拟机将本地方法栈合并到虚拟机栈中，解释器将Java字节码转换成机器码，对同一行代码反复解释，对于频繁执行的代码（热点代码），即时编译器发现热点代码将热点代码缓存，下次调用便会从缓存中读取。</p>
<h3 id="哪些区域会产生内存溢出"><a href="#哪些区域会产生内存溢出" class="headerlink" title="哪些区域会产生内存溢出"></a>哪些区域会产生内存溢出</h3><h4 id="产生OutOfMemoryError的情况"><a href="#产生OutOfMemoryError的情况" class="headerlink" title="产生OutOfMemoryError的情况"></a>产生OutOfMemoryError的情况</h4><ol>
<li>堆内存耗尽会出现<strong>OutOfMemoryError</strong></li>
<li>方法区内存耗尽-加载的类越来越多，很多框架都会动态的产生类，此时会产生OutOfMemoryError</li>
<li>​    虚拟机栈累积，每个线程最多占用1M内存，<strong>线程个数</strong>越来越多而又长时间不销毁，(<strong>在创建线程申请内存时就无法获得足够内</strong>存)，则会产生OutOfMemoryError</li>
</ol>
<h4 id="产生StackOverFlowError的情况"><a href="#产生StackOverFlowError的情况" class="headerlink" title="产生StackOverFlowError的情况"></a>产生StackOverFlowError的情况</h4><ol>
<li>​    HotSpot虚拟机不支持动态扩展，所以当<strong>线程内部方法</strong>调用次数过多时，虚拟机栈只会产生<strong>StackOverFlowError</strong>，而不会产生OutOfMemoryError</li>
</ol>
<h3 id="方法区与永久代、元空间的关系"><a href="#方法区与永久代、元空间的关系" class="headerlink" title="方法区与永久代、元空间的关系"></a>方法区与永久代、元空间的关系</h3><ul>
<li><strong>方法区</strong>是 JVM 规范中定义的一块内存区域，用来存储类元数据、方法字节码、即时编译器需要的信息等</li>
<li><strong>永久代</strong>是 Hotspot 虚拟机对 JVM 规范的实现（1.8 之前）</li>
<li><strong>元空间</strong>是 Hotspot 虚拟机对 JVM 规范的另一种实现（1.8 以后），使用本地内存作为这些信息的存储空间</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831170457337.png" alt="image-20210831170457337"></p>
<p>从这张图学到三点</p>
<ul>
<li>当第一次用到某个类是，由类加载器将 class 文件的类元信息读入，并存储于元空间</li>
<li>X，Y 的类元信息是存储于元空间中，无法直接访问</li>
<li>可以用 X.class，Y.class 间接访问类元信息，它们俩属于 java 对象，我们的代码中可以使用</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831170512418.png" alt="image-20210831170512418"></p>
<p>从这张图可以学到</p>
<ul>
<li>堆内存中：当一个<strong>类加载器对象</strong>，这个类加载器对象加载的所有<strong>类对象</strong>，这些类对象对应的所有<strong>实例对象</strong>都没人引用时，GC 时就会对它们占用的对内存进行释放</li>
<li>元空间中：内存释放<strong>以类加载器为单位</strong>，当堆中类加载器内存释放时，对应的元空间中的类元信息也会释放</li>
</ul>
<h3 id="Java虚拟机参数"><a href="#Java虚拟机参数" class="headerlink" title="Java虚拟机参数"></a>Java虚拟机参数</h3><p>-Xss  控制每个虚拟机栈的内存，Linux默认为1m</p>
<p><strong>堆内存，按大小设置</strong></p>
<p>-Xmx Java虚拟机最大内存是多少</p>
<p>-Xms Java虚拟机最小内存数</p>
<p>-Xmn 虚拟机新生代的占的内存</p>
<p>-XX:SurvivorRatio 伊甸园区和from部分的占比</p>
<p>-XX:NewRatio 控制新生代的占比</p>
<p>新生代分为伊甸园区和from区和to 区，Survivor区是from和to占的大小</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220316081701537.png" alt="image-20220316081701537"></p>
<p><strong>元空间内存设置</strong></p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831173118634.png" alt="image-20210831173118634"></p>
<p>解释：</p>
<ul>
<li>class space 存储类的基本信息，最大值受 -XX:CompressedClassSpaceSize 控制</li>
<li>non-class space 存储除类的基本信息以外的其它信息（如方法字节码、注解等）</li>
<li>class space 和 non-class space 总大小受 -XX:MaxMetaspaceSize 控制</li>
</ul>
<p>注意：</p>
<ul>
<li>这里 -XX:CompressedClassSpaceSize 这段空间还与是否开启了指针压缩有关，这里暂不深入展开，可以简单认为指针压缩默认开启</li>
</ul>
<p><strong>代码缓存内存设置</strong></p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220316082300452.png" alt="image-20220316082300452"></p>
<p>解释：</p>
<ul>
<li>如果 -XX:ReservedCodeCacheSize &lt; 240m，所有优化机器代码不加区分存在一起</li>
<li>否则，分成三个区域（图中笔误 mthod 拼写错误，少一个 e）<ul>
<li>non-nmethods - JVM 自己用的代码</li>
<li>profiled nmethods - 部分优化的机器码</li>
<li>non-profiled nmethods - 完全优化的机器码</li>
</ul>
</li>
</ul>
<h1 id="Java垃圾回收器"><a href="#Java垃圾回收器" class="headerlink" title="Java垃圾回收器"></a>Java垃圾回收器</h1><h4 id="Java的四种引用"><a href="#Java的四种引用" class="headerlink" title="Java的四种引用"></a>Java的四种引用</h4><p>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为<strong>强引用（Strongly Re-ference）、软 引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）</strong>4种，这4种引用强 度依次逐渐减弱。</p>
<ul>
<li>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object  obj&#x3D;new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回 收掉被引用的对象。</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220317143558133.png" alt="image-20220317143558133"></p>
<ul>
<li><p>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，<strong>在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。</strong>在JDK 1.2版之后提供了SoftReference类来实现软引用。</p>
<p>SoftReference a&#x3D;new SoftReference(new A); 软引用自身内存不会释放，软引用需要配合引用队列来释放，典型例子是反射数据</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220317143547828.png" alt="image-20220317143547828"></p>
</li>
<li><p>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。<strong>当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</strong>在JDK 1.2版之后提供了WeakReference类来实现弱引用。</p>
</li>
</ul>
<p>​       WeakReference a&#x3D;new WeakReference(new A);弱引用自身需要配合队列来释放，典型例子是ThreadLocalMap中的Entry对象</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220317143612879.png" alt="image-20220317143612879"></p>
<ul>
<li><p>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。<strong>为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</strong>在JDK 1.2版之后提供<br>了PhantomReference类来实现虚引用。</p>
<p>PhantomReference a&#x3D;new PhantomReference(new A());必须配合引用队列一起使用，当虚引用的对象被回收时，会将虚引用对象入队，由Reference Handler线程释放其关联的外部资源，典型例子是Cleaner释放DirectByteBuffer占用的直接内存。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210901112157901.png" alt="image-20210901112157901"></p>
</li>
</ul>
<h4 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h4><p>任何一个对象finalize方法都只会被系统调用一次，如果对象面临下一次回收，它的finalize方法不会再次执行。建议使用trl-finally方式代替finalize()</p>
<ul>
<li>它是 Object 中的一个方法，如果子类重写它，垃圾回收时此方法会被调用，可以在其中进行资源释放和清理工作</li>
<li>将资源释放和清理放在 finalize 方法中非常不好，非常影响性能，严重时甚至会引起 OOM，从 Java9 开始就被标注为 @Deprecated，不建议被使用了</li>
</ul>
<p><strong>finalize 原理</strong></p>
<ol>
<li>对 finalize 方法进行处理的核心逻辑位于 java.lang.ref.Finalizer 类中，它包含了名为 unfinalized 的静态变量（双向链表结构），Finalizer 也可被视为另一种引用对象（地位与软、弱、虚相当，只是不对外，无法直接使用）</li>
<li>当重写了 finalize 方法的对象，在构造方法调用之时，JVM 都会将其包装成一个 Finalizer 对象，并加入 unfinalized 链表中</li>
</ol>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210901121032813.png" alt="image-20210901121032813"></p>
<ol start="3">
<li>Finalizer 类中还有另一个重要的静态变量，即 ReferenceQueue 引用队列，刚开始它是空的。当狗对象可以被当作垃圾回收时，就会把这些狗对象对应的 Finalizer 对象加入此引用队列</li>
<li>但此时 Dog 对象还没法被立刻回收，因为 unfinalized -&gt; Finalizer 这一引用链还在引用它嘛，为的是【先别着急回收啊，等我调完 finalize 方法，再回收】</li>
<li>FinalizerThread 线程会从 ReferenceQueue 中逐一取出每个 Finalizer 对象，把它们从链表断开并真正调用 finallize 方法</li>
</ol>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210901122228916.png" alt="image-20210901122228916"></p>
<ol start="6">
<li>由于整个 Finalizer 对象已经从 unfinalized 链表中断开，这样没谁能引用到它和狗对象，所以下次 gc 时就被回收了</li>
</ol>
<p><strong>finalize 缺点</strong></p>
<ul>
<li>无法保证资源释放：FinalizerThread 是守护线程，代码很有可能没来得及执行完，线程就结束了，造成资源没有正确释放。</li>
<li>无法判断是否发生错误：执行 finalize 方法时，会吞掉任意异常（Throwable）</li>
<li>内存释放不及时：重写了 finalize 方法的对象在第一次被 gc 时，并不能及时释放它占用的内存，因为要等着 FinalizerThread 调用完 finalize，把它从 unfinalized 队列移除后，第二次 gc 时才能真正释放内存</li>
<li>可以想象gc本就因为内存不足引起，finalize调用又很慢(两个队列的移除操作，都是串行执行的，用来释放连接类的资源也应该不快)，不能及时释放内存，对象释放不及时就会逐渐移入老年代，老年代垃圾积累过多容易引起full gc，full gc后释放速度如果仍然跟不上创建新对象的速度，就会OOM。</li>
<li>有的文章提到【Finalizer 线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的CPU时间较少，因此它永远也赶不上主线程的步伐】这个显然是错误的，FinalizerThread 的优先级较普通线程更高，原因应该是 finalize 串行执行慢等原因综合导致</li>
</ul>
<h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h4><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220316085947530.png" alt="image-20220316085947530"></p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220316090003045.png" alt="image-20220316090003045"></p>
<h4 id="JVM垃圾回收算法"><a href="#JVM垃圾回收算法" class="headerlink" title="JVM垃圾回收算法"></a>JVM垃圾回收算法</h4><p><strong>三种垃圾回收算法</strong></p>
<p>标记清除法</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831211008162.png" alt="image-20210831211008162"></p>
<p>解释：</p>
<ol>
<li>找到 GC Root 对象，即那些一定不会被回收的对象，如正执行方法内局部变量引用的对象、静态变量引用的对象</li>
<li>标记阶段：沿着 GC Root 对象的引用链找，直接或间接引用到的对象加上标记</li>
<li>清除阶段：释放未加标记的对象占用的内存</li>
</ol>
<p>要点：</p>
<ul>
<li>标记速度与存活对象线性关系</li>
<li>清除速度与内存大小线性关系</li>
<li>缺点是会产生内存碎片</li>
</ul>
<p>标记整理法</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831211641241.png" alt="image-20210831211641241"></p>
<p>解释：</p>
<ol>
<li>前面的标记阶段、清理阶段与标记清除法类似</li>
<li>多了一步整理的动作，将存活对象向一端移动，可以避免内存碎片产生</li>
</ol>
<p>特点：</p>
<ul>
<li><p>标记速度与存活对象线性关系</p>
</li>
<li><p>清除与整理速度与内存大小成线性关系</p>
</li>
<li><p>缺点是性能上较慢</p>
</li>
</ul>
<p>标记复制法</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831212125813.png" alt="image-20210831212125813"></p>
<p>解释：</p>
<ol>
<li>将整个内存分成两个大小相等的区域，from 和 to，其中 to 总是处于空闲，from 存储新创建的对象</li>
<li>标记阶段与前面的算法类似</li>
<li>在找出存活对象后，会将它们从 from 复制到 to 区域，复制的过程中自然完成了碎片整理</li>
<li>复制完成后，交换 from 和 to 的位置即可</li>
</ol>
<p>特点：</p>
<ul>
<li>标记与复制速度与存活对象成线性关系</li>
<li>缺点是会占用成倍的空间</li>
</ul>
<h4 id="GC-与分代回收算法"><a href="#GC-与分代回收算法" class="headerlink" title="GC 与分代回收算法"></a>GC 与分代回收算法</h4><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220508143437315.png" alt="image-20220508143437315"></p>
<p>GC 的目的在于实现无用对象内存自动释放，减少内存碎片、加快分配速度</p>
<p>GC 要点：</p>
<ul>
<li>回收区域是<strong>堆内存</strong>，不包括虚拟机栈</li>
<li>判断无用对象，使用<strong>可达性分析算法</strong>，<strong>三色标记法</strong>标记存活对象，回收未标记对象</li>
<li>GC 具体的实现称为<strong>垃圾回收器</strong></li>
<li>GC 大都采用了<strong>分代回收思想</strong><ul>
<li>理论依据是大部分对象朝生夕灭，用完立刻就可以回收，另有少部分对象会长时间存活，每次很难回收</li>
<li>根据这两类对象的特性将回收区域分为<strong>新生代</strong>和<strong>老年代</strong>，新生代采用标记复制法、老年代一般采用标记整理法</li>
</ul>
</li>
<li>根据 GC 的规模可以分成 <strong>Minor GC</strong>，<strong>Mixed GC</strong>，<strong>Full GC</strong><ul>
<li><p>Minor GC 发生在新生代的垃圾回收，暂停时间短</p>
</li>
<li><p>Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有</p>
</li>
<li><p>Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a><strong>分代回收</strong></h5><ol>
<li>伊甸园 eden，最初对象都分配到这里，与幸存区 survivor（分成 from 和 to）合称新生代，</li>
</ol>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831213622704.png" alt="image-20210831213622704"></p>
<ol start="2">
<li>当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象</li>
</ol>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831213640110.png" alt="image-20210831213640110"></p>
<ol start="3">
<li>将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放</li>
</ol>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831213657861.png" alt="image-20210831213657861"></p>
<ol start="4">
<li>将 from 和 to 交换位置</li>
</ol>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831213708776.png" alt="image-20210831213708776"></p>
<ol start="5">
<li>经过一段时间后伊甸园的内存又出现不足</li>
</ol>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831213724858.png" alt="image-20210831213724858"></p>
<ol start="6">
<li>标记伊甸园与 from（现阶段没有）的存活对象</li>
</ol>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831213737669.png" alt="image-20210831213737669"></p>
<ol start="7">
<li>将存活对象采用复制算法复制到 to 中</li>
</ol>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831213804315.png" alt="image-20210831213804315"></p>
<ol start="8">
<li>复制完毕后，伊甸园和 from 内存都得到释放</li>
</ol>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831213815371.png" alt="image-20210831213815371"></p>
<ol start="9">
<li>将 from 和 to 交换位置</li>
</ol>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831213826017.png" alt="image-20210831213826017"></p>
<ol start="10">
<li>老年代 old，当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）</li>
</ol>
<ul>
<li>对象首先分配在伊甸园区域 </li>
<li>新生代空间不足时，触发 minor gc，伊甸园和 from存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且交换 from to 的位置</li>
<li>minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行 </li>
<li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit），<strong>保存在对象头中</strong></li>
<li>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时 间更长</li>
<li><strong>大对象直接晋升到老年代</strong></li>
</ul>
<h5 id="相关VM参数"><a href="#相关VM参数" class="headerlink" title="相关VM参数"></a>相关VM参数</h5><table>
<thead>
<tr>
<th>含义</th>
<th>参数</th>
</tr>
</thead>
<tbody><tr>
<td>堆初始大小</td>
<td>-Xms</td>
</tr>
<tr>
<td>堆最大大小</td>
<td>-Xmx 或 -XX:MaxHeapSize&#x3D;size</td>
</tr>
<tr>
<td>新生代大小</td>
<td>-Xmn 或 (-XX:NewSize&#x3D;size + -XX:MaxNewSize&#x3D;size )</td>
</tr>
<tr>
<td>幸存区比例（动态）</td>
<td>-XX:InitialSurvivorRatio&#x3D;ratio 和 -XX:+UseAdaptiveSizePolicy</td>
</tr>
<tr>
<td>幸存区比例</td>
<td>-XX:SurvivorRatio&#x3D;ratio</td>
</tr>
<tr>
<td>晋升阈值</td>
<td>-XX:MaxTenuringThreshold&#x3D;threshold</td>
</tr>
<tr>
<td>晋升详情</td>
<td>XX:+PrintTenuringDistribution</td>
</tr>
<tr>
<td>GC详情</td>
<td>-XX:+PrintGCDetails -verbose:gc</td>
</tr>
<tr>
<td>FullGC 前 MinorGC</td>
<td>XX:+ScavengeBeforeFullGC</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>当一个线程抛出OOM异常后，它所占据的内存资源会被全部释放掉</p>
<h4 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h4><p>即用三种颜色记录对象的标记状态</p>
<ul>
<li>黑色 – 已标记</li>
<li>灰色 – 标记中</li>
<li>白色 – 还未标记</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220508160355202.png" alt="image-20220508160355202"></p>
<ol>
<li>起始的三个对象还未处理完成，用灰色表示</li>
</ol>
<img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831215016566.png" alt="image-20210831215016566" style="zoom:50%;" />

<ol start="2">
<li>该对象的引用已经处理完成，用黑色表示，黑色引用的对象变为灰色</li>
</ol>
<img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831215033510.png" alt="image-20210831215033510" style="zoom:50%;" />

<ol start="3">
<li>依次类推</li>
</ol>
<img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831215105280.png" alt="image-20210831215105280" style="zoom:50%;" />

<ol start="4">
<li>沿着引用链都标记了一遍</li>
</ol>
<img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831215146276.png" alt="image-20210831215146276" style="zoom:50%;" />

<ol start="5">
<li>最后为标记的白色对象，即为垃圾</li>
</ol>
<img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831215158311.png" alt="image-20210831215158311" style="zoom:50%;" />

<h4 id="并发漏标问题"><a href="#并发漏标问题" class="headerlink" title="并发漏标问题"></a>并发漏标问题</h4><p>比较先进的垃圾回收器都支持<strong>并发标记</strong>，即在标记过程中，用户线程仍然能工作。但这样带来一个新的问题，如果用户线程修改了对象引用，那么就存在漏标问题。例如：</p>
<p>1.黑色的多了一条引用而黑色不能使得连接的白色变为灰色状态</p>
<ol>
<li>如图所示标记工作尚未完成</li>
</ol>
<img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831215846876.png" alt="image-20210831215846876" style="zoom:50%;" />

<ol start="2">
<li>用户线程同时在工作，断开了第一层 3、4 两个对象之间的引用，这时对于正在处理 3 号对象的垃圾回收线程来讲，它会将 4 号对象当做是白色垃圾</li>
</ol>
<img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831215904073.png" alt="image-20210831215904073" style="zoom:50%;" />

<ol start="3">
<li>但如果其他用户线程又建立了 2、4 两个对象的引用，这时因为 2 号对象是黑色已处理对象了，因此垃圾回收线程不会察觉到这个引用关系的变化，从而产生了漏标</li>
</ol>
<img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831215919493.png" alt="image-20210831215919493" style="zoom:50%;" />

<ol start="4">
<li>如果用户线程让黑色对象引用了一个新增对象，一样会存在漏标问题</li>
</ol>
<img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831220004062.png" alt="image-20210831220004062" style="zoom:50%;" />

<p>并发漏标产生的条件</p>
<ul>
<li><p>赋值器插入了一条或多条从黑色对象到白色对象的新引用； </p>
</li>
<li><p>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</p>
</li>
</ul>
<p>因此对于<strong>并发标记</strong>而言，必须解决漏标问题，也就是要记录标记过程中的变化。有两种解决方法：</p>
<ol>
<li>Incremental Update 增量更新法，CMS 垃圾回收器采用<ul>
<li>思路是拦截每次赋值动作，只要赋值发生，被赋值的对象就会被记录下来，在重新标记阶段再确认一遍</li>
<li><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220508160831942.png" alt="image-20220508160831942"></li>
</ul>
</li>
<li>Snapshot At The Beginning，SATB 原始快照法，G1 垃圾回收器采用<ul>
<li>思路也是拦截每次赋值动作，不过记录的对象不同，也需要在重新标记阶段对这些对象二次处理</li>
<li>新加对象会被记录</li>
<li>被删除引用关系的对象也被记录</li>
<li><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220508160905287.png" alt="image-20220508160905287"></li>
</ul>
</li>
</ol>
<h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220508161301642.png" alt="image-20220508161301642"></p>
<h5 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h5><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220316113515282.png" alt="image-20220316113515282"></p>
<p>迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的默认新生 代收集器，有着优于其他收集器的地方，那就是简单而高效（与其他收集器的单线程相比），对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）[1]最小的</p>
<h5 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h5><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220316113853294.png" alt="image-20220316113853294"></p>
<p>ParNew合并入CMS，成为它专门处理新生代的组成部 分。ParNew可以说是HotSpot虚拟机中第一款退出历史舞台的垃圾收集器。</p>
<h5 id="垃圾回收器-Parallel-GC"><a href="#垃圾回收器-Parallel-GC" class="headerlink" title="垃圾回收器 - Parallel GC"></a><strong>垃圾回收器 - Parallel GC</strong></h5><ul>
<li><p>eden 内存不足发生 Minor GC，采用标记复制算法，需要暂停用户线程</p>
</li>
<li><p>old 内存不足发生 Full GC，采用标记整理算法，需要暂停用户线程</p>
</li>
<li><p><strong>注重吞吐量</strong></p>
</li>
</ul>
<p><strong>垃圾回收器 - ConcurrentMarkSweep GC ———CMS</strong></p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220508164834470.png" alt="image-20220508164834470"></p>
<ul>
<li>它是工作在 old 老年代，支持<strong>并发标记</strong>的一款回收器，采用<strong>并发清除</strong>算法<ul>
<li>并发标记时不需暂停用户线程</li>
<li>重新标记时仍需暂停用户线程</li>
</ul>
</li>
<li>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</li>
<li><strong>注重响应时间</strong></li>
</ul>
<p>缺点：</p>
<ul>
<li>CMS默认启动的回收线程数是（处理器核心数量 +3）&#x2F;4，但是当处理器核心数量不足四个时， CMS对用户程序的影响就可能变得很大。如果应用本来的处理器负载就很高，还要分出一半的运算能力去执行收集器线程，就<strong>可能导致用户程序的执行速度忽然大幅降低</strong>。</li>
<li>由于CMS收集器无法处理“浮动垃圾”（Floating Garbage），有可能出现“Con-current Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生</li>
<li>收集结束时会有大量空间碎片产生。空间 碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。</li>
</ul>
<p>运行流程</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>标记清除</li>
</ul>
<h5 id="垃圾回收器-G1-GC"><a href="#垃圾回收器-G1-GC" class="headerlink" title="垃圾回收器 - G1 GC"></a>垃圾回收器 - G1 GC</h5><ul>
<li><strong>响应时间与吞吐量兼顾</strong></li>
<li>划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备，G1只要认定大小超过了一个Region容量一半的对象即可判定为大对象。对于那些超过了整个Region容量的超级大对象， 将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待</li>
<li>分成三个阶段：新生代回收、并发标记、混合收集</li>
<li>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220509212409996.png" alt="image-20220509212409996"></p>
<p>-XX:G1HeapRegionSize 设定区域大小</p>
<h6 id="回收巨型对象"><a href="#回收巨型对象" class="headerlink" title="回收巨型对象"></a>回收巨型对象</h6><ul>
<li>一个对象大于 region 的一半时，称之为巨型对象 humongous</li>
<li>G1 不会对巨型对象进行拷贝 </li>
<li>回收时被优先考虑 </li>
<li>G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生 代垃圾回收时处理掉</li>
</ul>
<h3 id="面试题：项目什么情况下会内存溢出，怎么解决的"><a href="#面试题：项目什么情况下会内存溢出，怎么解决的" class="headerlink" title="面试题：项目什么情况下会内存溢出，怎么解决的"></a>面试题：项目什么情况下会内存溢出，怎么解决的</h3><p><strong>典型情况</strong></p>
<ul>
<li>误用线程池导致的内存溢出<ul>
<li>参考 day03.TestOomThreadPool</li>
</ul>
</li>
<li>查询数据量太大导致的内存溢出<ul>
<li>参考 day03.TestOomTooManyObject</li>
</ul>
</li>
<li>动态生成类导致的内存溢出<ul>
<li>参考 day03.TestOomTooManyClass</li>
</ul>
</li>
</ul>
<h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220316183823997.png" alt="image-20220316183823997"></p>
<h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><ol>
<li><p>加载</p>
<ol>
<li>将类的字节码载入方法区，并创建类.class 对象<img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220510164539739.png" alt="image-20220510164539739"></li>
<li>如果此类的父类没有加载，先加载父类</li>
<li>加载是懒惰执行，加载和链接可能是交替进行的</li>
<li><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220510164626537.png" alt="image-20220510164626537"></li>
</ol>
</li>
<li><p>链接</p>
<ul>
<li>验证 – 验证类是否符合 Class 规范，合法性、安全性检查</li>
<li>准备 – 为 static 变量分配空间，设置默认值<ul>
<li>static 变量在 JDK 7 之前存储于 instanceKlass 末尾，从 JDK 7 开始，存储于 _java_mirror 末尾 </li>
<li>static 变量分配空间和赋值是两个步骤，分配空间在<strong>准备阶段</strong>完成，赋值<strong>在初始化阶段</strong>完成 </li>
<li>如果 static 变量是 final 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成 </li>
<li>如果 static 变量是 final 的，但属于引用类型，那么赋值也会在初始化阶段完成</li>
<li>解析 – 将常量池的符号引用解析为直接引用，原来是只知道是个符号，解析后知道类D在内存中的实际地址</li>
</ul>
</li>
</ul>
</li>
<li><p>初始化</p>
<ol>
<li><p>静态代码块、static 修饰的变量赋值、static final 修饰的引用类型变量赋值，会被合并成一个 <code>&lt;cinit&gt;</code> 方法，在初始化时被调用</p>
</li>
<li><p>static final 修饰的基本类型变量赋值，在链接阶段就已完成</p>
</li>
<li><p>初始化是懒惰执行</p>
<ul>
<li><p>main 方法所在的类，总会被首先初始化 </p>
</li>
<li><p>首次访问这个类的静态变量或静态方法时 </p>
</li>
<li><p>子类初始化，如果父类还没初始化，会引发 </p>
</li>
<li><p>子类访问父类的静态变量，只会触发父类的初始化 </p>
</li>
<li><p>Class.forName </p>
</li>
<li><p>new 会导致初始化 </p>
<p>不会导致类初始化的情况</p>
</li>
<li><p>访问类的 static final 静态常量（基本类型和字符串）不会触发初始化 </p>
</li>
<li><p>类对象.class 不会触发初始化 </p>
</li>
<li><p>创建该类的数组不会触发初始化 </p>
</li>
<li><p>类加载器的 loadClass 方法 </p>
</li>
<li><p>Class.forName 的参数 2 为 false 时</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220317101838367.png" alt="image-20220317101838367"></p>
<p>启动类加载器，拓展类加载器，应用程序类加载器</p>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220317105643388.png" alt="image-20220317105643388"></p>
<p>所谓的双亲委派，就是指调用类加载器的 loadClass 方法时，查找类的规则</p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 首先，检查请求的类是否已经被加载过了 </span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name); </span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123; </span><br><span class="line">                <span class="comment">//如果有上级，委派上级loadClass</span></span><br><span class="line">                c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">             &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="comment">//没有上级了，委启动类加载器</span></span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">             &#125;        </span><br><span class="line">             &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; </span><br><span class="line">             <span class="comment">// 如果父类加载器抛出ClassNotFoundException </span></span><br><span class="line">             <span class="comment">// 说明父类加载器无法完成加载请求，不进行处理 </span></span><br><span class="line">             &#125; </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 在父类加载器无法加载时 </span></span><br><span class="line">            <span class="comment">// 再调用本身的findClass方法来进行类加载 </span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">             &#125;</span><br><span class="line">     &#125; </span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123; </span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所谓的双亲委派，就是指优先委派上级类加载器进行加载，如果上级类加载器</p>
<ul>
<li>能找到这个类，由上级加载，加载后该类也对下级加载器可见</li>
<li>找不到这个类，则下级类加载器才有资格执行加载</li>
</ul>
<p>双亲委派的目的有两点</p>
<ol>
<li>让上级类加载器中的类对下级共享（反之不行），即能让你的类能依赖到 jdk 提供的核心类</li>
<li>让类的加载有优先次序，保证核心类优先加载</li>
</ol>
<h4 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h4><p>打破双亲委派规则。 </p>
<h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><p>什么时候需要自定义类加载器？</p>
<ol>
<li>想加载非classpath随意路径中的类文件</li>
<li>都是通过接口来使用实现，希望解耦时，常用在框架设计。</li>
<li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于tomcat容器</li>
</ol>
<p> 步骤</p>
<ol>
<li>继承ClassLoader父类</li>
<li>要遵从双亲委派机制，重写findClass方法<ul>
<li>注意不是重写loadClass方法，否则不会走双亲委派机制</li>
</ul>
</li>
<li>读取类文件的字节码</li>
<li>调用父类的defineClass方法来加载类</li>
<li>使用者调用该类加载器的loadClass方法</li>
</ol>
<h3 id="跨代引用问题"><a href="#跨代引用问题" class="headerlink" title="跨代引用问题"></a>跨代引用问题</h3><p>使用卡表解决跨代引用问题</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220508155610898.png" alt="image-20220508155610898"></p>
<p>只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏（Dirty），没有则标识为0。在垃 圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/01/MQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/01/MQ/" class="post-title-link" itemprop="url">MQ</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-01 23:47:44" itemprop="dateCreated datePublished" datetime="2022-03-01T23:47:44+08:00">2022-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-21 13:55:06" itemprop="dateModified" datetime="2022-04-21T13:55:06+08:00">2022-04-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">Java知识</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="常见MQ比较"><a href="#常见MQ比较" class="headerlink" title="常见MQ比较"></a>常见MQ比较</h3><p>ActiveMQ,RabbitMQ吞吐量为万级，RocketMQ，Kafka吞吐量为十万级别，</p>
<p>RocketMQ topic可以达到几百，几千个级别吞吐量会有较小幅度的下降，Kafka  topic从几十个到几百个的时候，吞吐量会大幅度下降</p>
<p>ActiveMQ,，RocketMQ，Kafka时效性都为ms，而RabbitMQ时效性为微秒</p>
<p>ActiveMQ,RabbitMQ可用性高，基于主从架构实现高可用性，RocketMQ和Kafka可用性非常高，采用的都是分布式架构</p>
<p>消息可靠性，ActiveMQ有较低概率丢失数据，RocketMQ，Kafka经过参数优化匹配，消息可以做到0丢失。</p>
<h3 id="RabbitMQ高可用的实现"><a href="#RabbitMQ高可用的实现" class="headerlink" title="RabbitMQ高可用的实现"></a>RabbitMQ高可用的实现</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220325121554889.png" alt="image-20220325121554889"></p>
<p>这种模式，才是所谓的 rabbitmq 的高可用模式，跟普通集群模式不一样的是，你创建的queue，无论元数据还是 queue 里的消息都会存在于多个实例上，然后每次你写消息到 queue 的时候，都会自动把消息到多个实例的 queue 里进行消息同步。类似 Redis 的主从复制。</p>
<p>这样的话，好处在于，你任何一个机器宕机了，没事儿，别的机器都可以用。坏处在于，第一，这个性能开销也太大了吧，，消息同步所有机器，导致网络带宽压力和消耗很重！第二，这么玩儿，就没有扩展性可言了，如果某个 queue 负载很重，你加机器，新增的机器也包含个queue的所有数据，并没有办法线性扩展你的 queue。<br>那么怎么开启这个镜像集群模式呢？我这里简单说一下，避免面试人家问你你不知道，其实很简单rabbitmq 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候可以要求数据同步到所有节点的，也可以要求就同步到指定数量的节点，然后你再次创建queue的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p>
<h3 id="RabbitMQ如何保证消息不被重复消费"><a href="#RabbitMQ如何保证消息不被重复消费" class="headerlink" title="RabbitMQ如何保证消息不被重复消费"></a>RabbitMQ如何保证消息不被重复消费</h3><ol>
<li>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。</li>
<li>比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。</li>
<li>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</li>
<li>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据</li>
</ol>
<h3 id="如何保证消息的可靠性传输"><a href="#如何保证消息的可靠性传输" class="headerlink" title="如何保证消息的可靠性传输"></a>如何保证消息的可靠性传输</h3><h3 id="如何保证消息的消费顺序"><a href="#如何保证消息的消费顺序" class="headerlink" title="如何保证消息的消费顺序"></a>如何保证消息的消费顺序</h3><p>先看看顺序会错乱的俩场景 </p>
<p>（1）rabbitmq：一个 queue，多个 consumer，这不明显乱了，因为消费数据的顺序不同，有可能 2,3,1， 按正常来说应该 1,2,3 进行消费，如下图：</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220330114518890.png" alt="image-20220330114518890"></p>
<p>（1）如何保证消息的顺序性呢？<br>拆分多个queue，每个queue一个consumer，就是多一些queue而已，确实是麻烦点；或者就一个 queue但是对应一个consumer，然后这个consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。如下图所示：</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220330114300040.png" alt="image-20220330114300040"></p>
<h3 id="如何解决消息队列的延时以及过期失效的问题？"><a href="#如何解决消息队列的延时以及过期失效的问题？" class="headerlink" title="如何解决消息队列的延时以及过期失效的问题？"></a>如何解决消息队列的延时以及过期失效的问题？</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220330114732891.png" alt="image-20220330114732891"></p>
<p>（1）大量消息在 mq 里积压了几个小时了还没解决</p>
<p>几千万条数据在 MQ 里积压了七八个小时，从下午 4 点多，积压到了晚上很晚，10 点多，11 点多 </p>
<p>这个是我们真实遇到过的一个场景，确实是线上故障了，这个时候要不然就是修复 consumer 的问题， 让他恢复消费速度，然后傻傻的等待几个小时消费完毕。这个肯定不能在面试的时候说吧。 </p>
<p>一个消费者一秒是 1000 条，一秒 3 个消费者是 3000 条，一分钟是 18 万条，1000 多万条 所以如果你积压了几百万到上千万的数据，即使消费者恢复了，也需要大概 1 小时的时间才能恢复 过来 </p>
<p>一般这个时候，只能操作临时紧急扩容了，具体操作步骤和思路如下： </p>
<ol>
<li>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 cnosumer 都停掉 </li>
<li>新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍或者 20 倍的 queue 数量 </li>
<li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不 做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue </li>
<li>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据 </li>
<li>这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数 据 </li>
<li>等快速消费完积压数据之后，得恢复原先部署架构，重新用原先的 consumer 机器来消费消息</li>
</ol>
<p>上面的 topic，partition，queue 的关系弄不清楚，所以我总结如下：</p>
<p>修复原来生产者的问题，并停掉，然后新建一些生产者，快速消费消息，并不做耗时的处理，那么 这些消息如何快速消费呢？扩展集群，零时征用 10 倍的机器部署消费者，消费前边消费者转发过来 的消息，这样就很快消费掉队列里边堆积的消息了。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220330115507603.png" alt="image-20220330115507603"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/01/Java%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/01/Java%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Java基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-01 23:47:44" itemprop="dateCreated datePublished" datetime="2022-03-01T23:47:44+08:00">2022-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-21 14:10:41" itemprop="dateModified" datetime="2022-04-21T14:10:41+08:00">2022-04-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">Java知识</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Java-集合概览"><a href="#Java-集合概览" class="headerlink" title="Java 集合概览"></a>Java 集合概览</h3><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</p>
<p>Java 集合框架如下图所示：</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/java-collection-hierarchy.1727461b.png" alt="img"></p>
<p>注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了<code>AbstractList</code>, <code>NavigableSet</code>等抽象类以及其他的一些辅助类，如想深入了解，可自行查看源码。</p>
<h4 id="说说-list-set-queue-map-四者的区别说说-List-Set-Queue-Map-四者的区别？"><a href="#说说-list-set-queue-map-四者的区别说说-List-Set-Queue-Map-四者的区别？" class="headerlink" title="说说-list-set-queue-map-四者的区别说说 List, Set, Queue, Map 四者的区别？"></a>说说-list-set-queue-map-四者的区别说说 List, Set, Queue, Map 四者的区别？</h4><ul>
<li><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li>
<li><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li>
<li><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>
<li><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>
</ul>
<h4 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="#集合框架底层数据结构总结"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93">#</a>集合框架底层数据结构总结</h4><p>先来看一下 <code>Collection</code> 接口下面的集合。</p>
<h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><ul>
<li><code>Arraylist</code>： <code>Object[]</code> 数组</li>
<li><code>Vector</code>：<code>Object[]</code> 数组</li>
<li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>
</ul>
<h5 id="Set"><a href="#Set" class="headerlink" title="#Set"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#set">#</a>Set</h5><ul>
<li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li>
<li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li>
<li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li>
</ul>
<h5 id="Queue"><a href="#Queue" class="headerlink" title="#Queue"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#queue">#</a>Queue</h5><ul>
<li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li>
<li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li>
</ul>
<p>再来看看 <code>Map</code> 接口下面的集合。</p>
<h5 id="Map"><a href="#Map" class="headerlink" title="#Map"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#map">#</a>Map</h5><ul>
<li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a target="_blank" rel="noopener" href="https://www.imooc.com/article/22931">《LinkedHashMap 源码详细分析（JDK1.8）》open in new window</a></li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li>
</ul>
<h3 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="#如何选用集合?"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#%E5%A6%82%E4%BD%95%E9%80%89%E7%94%A8%E9%9B%86%E5%90%88">#</a>如何选用集合?</h3><h3 id="JDK1-8-之前"><a href="#JDK1-8-之前" class="headerlink" title="JDK1.8 之前"></a>JDK1.8 之前</h3><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。</p>
<p>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p>
<p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>
<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/jdk1.8%E4%B9%8B%E5%89%8D%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="jdk1.8之前的内部结构"></p>
<h3 id="JDK1-8-之后"><a href="#JDK1-8-之后" class="headerlink" title="JDK1.8 之后"></a>JDK1.8 之后</h3><p>相比于之前的版本，JDK1.8 以后在解决哈希冲突时有了较大的变化。</p>
<p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 <code>resize()</code> 方法对数组扩容。相关源码这里就不贴了，重点关注 <code>treeifyBin()</code>方法即可！</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/up-bba283228693dae74e78da1ef7a9a04c684.png" alt="img"></p>
<h3 id="HashMap底层原理"><a href="#HashMap底层原理" class="headerlink" title="HashMap底层原理"></a>HashMap底层原理</h3><ul>
<li><p><strong>loadFactor 加载因子</strong></p>
<p>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>
<p><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</p>
<p><strong>给定的默认容量为 16，负载因子为 0.75</strong>。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 &#x3D; 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>
</li>
<li><p><strong>threshold</strong></p>
<p><strong>threshold &#x3D; capacity * loadFactor</strong>，<strong>当 Size&gt;&#x3D;threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p>
</li>
</ul>
<p>红黑树的阈值是8，当链表大于等于8时链表变成了红黑树结构，大大减少了查找的时间。</p>
<p>当长度低于6时会由红黑树转成链表,TreeNodes占用空间是普通Nodes的两倍,所以只有当bin包含足够多的节点时才会转成TreeNodes,而是否足够多就是由TREEIFY_THRESHOLD的值决定的,当bin中节点数变少时，又会转成普通的bin,这样就解析了为什么不是一开始就将其转换为TreeNodes，而是需要一定节点数才转为TreeNodes，说白了就是trade-off，空间和时间的权衡。</p>
<h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><p>两者的主要区别在于解决问题的方式不同：</p>
<ul>
<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>
<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li>
</ul>
<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>
<h3 id="场景题给十亿个手机号进行去重"><a href="#场景题给十亿个手机号进行去重" class="headerlink" title="场景题给十亿个手机号进行去重"></a>场景题给十亿个手机号进行去重</h3><p>利用位图bitmap</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220326180402088.png" alt="image-20220326180402088"></p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220326180440696.png" alt="image-20220326180440696"></p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220326180648995.png" alt="image-20220326180648995"></p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="ArrayList扩容机制"><a href="#ArrayList扩容机制" class="headerlink" title="ArrayList扩容机制"></a>ArrayList扩容机制</h4><p>Java8以前无参构造时候创建容量为10的数组</p>
<p>调用无参的ArrayList初始容量为0，有参的数组以给的整数作为容量。如果给的是集合，根据集合大小创建初始容量。</p>
<p>add()方法<strong>当数组添加第一个元素时，就会发生第一次扩容，创建长度为10的数组，第二次扩容的时候为上次容量的1.5倍，扩容&gt;&gt;1右移1位加上原来的容量。</strong></p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220406174435331.png" alt="image-20220406174435331"></p>
<p>分析：当前ArrayList里面元素是十个，通过addAll添加下次扩容为15，当前元素个数为13，因此扩容为15</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">      list.add(i);</span><br><span class="line">&#125;</span><br><span class="line">list.addAll(List.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));</span><br></pre></td></tr></table></figure>

<p>分析：当前ArrayList里面元素是十个，通过addAll添加下次扩容为15，当前元素个数为16，因此扩容为16</p>
<p><strong>调用addAll方法的时候，规则有所不一样，发现原始容量不够时，会在扩容容量大小和当前元素个数较大值作为下次容量。</strong></p>
<h4 id="LinkedList和ArrayList"><a href="#LinkedList和ArrayList" class="headerlink" title="LinkedList和ArrayList"></a>LinkedList和ArrayList</h4><p><strong>LinkedList</strong></p>
<ol>
<li>基于双向链表，无需连续内存</li>
<li>随机访问慢（要沿着链表遍历）</li>
<li>头尾插入删除性能高</li>
<li>占用内存多</li>
</ol>
<p><strong>ArrayList</strong></p>
<ol>
<li>基于数组，需要连续内存</li>
<li>随机访问快（指根据下标访问）实现了RandomAccess</li>
<li>尾部插入、删除性能可以，其它部分插入、删除都会移动数据，因此性能会低</li>
<li>可以利用 cpu 缓存，局部性原理（把数据和相邻的数据读入）</li>
</ol>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="底层数据结构，1-7和1-8有何不同？"><a href="#底层数据结构，1-7和1-8有何不同？" class="headerlink" title="底层数据结构，1.7和1.8有何不同？"></a>底层数据结构，1.7和1.8有何不同？</h4><ul>
<li>1.7 数组 + 链表</li>
<li>1.8 数组 + （链表 | 红黑树）</li>
</ul>
<p>key值计算，首先经过两次哈希，最后用第二次哈希值对总容量进行取模运算。</p>
<p>扩容规则当超过容量乘以负载因子就会发生扩容，扩容为一倍</p>
<h4 id="树化与退化"><a href="#树化与退化" class="headerlink" title="树化与退化"></a>树化与退化</h4><p><strong>树化意义</strong></p>
<ul>
<li>红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况，是保底策略</li>
<li>hash 表的查找，更新的时间复杂度是 O(1)，而红黑树的查找，更新的时间复杂度是 O(log_2⁡n )，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表</li>
<li>hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小</li>
</ul>
<p><strong>树化规则</strong></p>
<ul>
<li>当链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 &gt;&#x3D;64，才会进行树化</li>
</ul>
<p><strong>退化规则</strong></p>
<ul>
<li>情况1：在扩容时如果拆分树时，树元素个数 &lt;&#x3D; 6 则会退化链表</li>
<li>情况2：remove 树节点时，若移除之前 <strong>root、root.left、root.right、root.left.left</strong> 有一个为 null ，也会退化为链表</li>
</ul>
<h4 id="索引计算"><a href="#索引计算" class="headerlink" title="索引计算"></a>索引计算</h4><p><strong>索引计算方法</strong></p>
<ul>
<li>首先，计算对象的 hashCode()</li>
<li>再进行调用 HashMap 的 hash() 方法进行二次哈希  (h &#x3D; key.hashCode) ^ (h &gt;&gt;&gt; 16) <ul>
<li>二次 hash() 是为了综合高位数据，让哈希分布更为均匀</li>
</ul>
</li>
<li>最后 &amp; (capacity – 1) 得到索引</li>
</ul>
<p><strong>数组容量为何是 2 的 n 次幂</strong></p>
<ol>
<li>计算索引时效率更高：<strong>如果是 2 的 n 次幂可以使用位与运算代替取模</strong></li>
<li><strong>扩容</strong>时重新计算索引效率更高： hash &amp; oldCap &#x3D;&#x3D; 0 的元素留在原来位置 ，否则新位置 &#x3D; 旧位置 + oldCap</li>
</ol>
<p><strong>注意</strong></p>
<ul>
<li>二次 hash 是为了配合 <strong>容量是 2 的 n 次幂</strong> 这一设计前提，如果 hash 表的容量不是 2 的 n 次幂，则不必二次 hash</li>
<li><strong>容量是 2 的 n 次幂</strong> 这一设计计算索引效率更好，但 hash 的分散性就不好，需要二次 hash 来作为补偿，没有采用这一设计的典型例子是 Hashtable</li>
</ul>
<h4 id="put-与扩容"><a href="#put-与扩容" class="headerlink" title="put 与扩容"></a>put 与扩容</h4><p><strong>put 流程</strong></p>
<ol>
<li>HashMap 是懒惰创建数组的，首次使用才创建数组</li>
<li>计算索引（桶下标）</li>
<li>如果桶下标还没人占用，创建 Node 占位返回</li>
<li>如果桶下标已经有人占用<ol>
<li>已经是 TreeNode 走红黑树的添加或更新逻辑</li>
<li>是普通 Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑</li>
</ol>
</li>
<li>返回前检查容量是否超过阈值，一旦超过进行扩容（先把节点放到旧数组后然后迁移元素）</li>
</ol>
<p><strong>1.7 与 1.8 的区别</strong></p>
<ol>
<li><p>链表插入节点时，1.7 是头插法，1.8 是尾插法</p>
</li>
<li><p><strong>1.7 是大于等于阈值且没有此时添加的索引位置没有空位时才扩容</strong>，例如索引值为10，此时上面没有元素，则不扩容，若有空位则扩容，而 1.8 是大于阈值就扩容</p>
</li>
<li><p>1.8 在扩容计算 Node 索引时，会优化</p>
</li>
</ol>
<p><strong>扩容（加载）因子为何默认是 0.75f</strong></p>
<ol>
<li>在空间占用与查询时间之间取得较好的权衡</li>
<li>大于这个值，空间节省了，但链表就会比较长影响性能</li>
<li>小于这个值，冲突减少了，但扩容就会更频繁，空间占用也更多</li>
</ol>
<h4 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h4><p><strong>扩容死链（1.7 会存在）</strong></p>
<p>1.7 源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>e 和 next 都是局部变量，用来指向当前节点和下一个节点</li>
<li>线程1（绿色）的临时变量 e 和 next 刚引用了这俩节点，还未来得及移动节点，发生了线程切换，由线程2（蓝色）完成扩容和迁移</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831084325075.png" alt="image-20210831084325075"></p>
<ul>
<li>线程2 扩容完成，由于头插法，链表顺序颠倒。但线程1 的临时变量 e 和 next 还引用了这俩节点，还要再来一遍迁移</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831084723383.png" alt="image-20210831084723383"></p>
<ul>
<li>第一次循环<ul>
<li>循环接着线程切换前运行，注意此时 e 指向的是节点 a，next 指向的是节点 b</li>
<li>e 头插 a 节点，注意图中画了两份 a 节点，但事实上只有一个（为了不让箭头特别乱画了两份）</li>
<li>当循环结束是 e 会指向 next 也就是 b 节点</li>
</ul>
</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831084855348.png" alt="image-20210831084855348"></p>
<ul>
<li>第二次循环<ul>
<li>next 指向了节点 a</li>
<li>e 头插节点 b</li>
<li>当循环结束时，e 指向 next 也就是节点 a</li>
</ul>
</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831085329449.png" alt="image-20210831085329449"></p>
<ul>
<li>第三次循环<ul>
<li>next 指向了 null</li>
<li>e 头插节点 a，<strong>a 的 next 指向了 b</strong>（之前 a.next 一直是 null），b 的 next 指向 a，死链已成</li>
<li>当循环结束时，e 指向 next 也就是 null，因此第四次循环时会正常退出</li>
</ul>
</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831085543224.png" alt="image-20210831085543224"></p>
<p><strong>数据错乱（1.7，1.8 都会存在）</strong></p>
<ul>
<li>代码参考 <code>day01.map.HashMapMissData</code>，具体调试步骤参考视频</li>
</ul>
<blockquote>
<p><em><strong>补充代码说明</strong></em></p>
<ul>
<li>day01.map.HashMapDistribution 演示 map 中链表长度符合泊松分布</li>
<li>day01.map.DistributionAffectedByCapacity 演示容量及 hashCode 取值对分布的影响<ul>
<li>day01.map.DistributionAffectedByCapacity#hashtableGrowRule 演示了 Hashtable 的扩容规律</li>
<li>day01.sort.Utils#randomArray 如果 hashCode 足够随机，容量是否是 2 的 n 次幂影响不大</li>
<li>day01.sort.Utils#lowSameArray 如果 hashCode 低位一样的多，容量是 2 的 n 次幂会导致分布不均匀</li>
<li>day01.sort.Utils#evenArray 如果 hashCode 偶数的多，容量是 2 的 n 次幂会导致分布不均匀</li>
<li>由此得出对于容量是 2 的 n 次幂的设计来讲，二次 hash 非常重要</li>
</ul>
</li>
<li>day01.map.HashMapVsHashtable 演示了对于同样数量的单词字符串放入 HashMap 和 Hashtable 分布上的区别</li>
</ul>
</blockquote>
<p><strong>同步与异步</strong></p>
<ul>
<li><strong>同步：</strong> 同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。</li>
<li><strong>异步：</strong> 异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。</li>
</ul>
<p>同步和异步的区别最大在于异步的话调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。</p>
<p><strong>阻塞和非阻塞</strong></p>
<ul>
<li><strong>阻塞：</strong> 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</li>
<li><strong>非阻塞：</strong> 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。</li>
</ul>
<h3 id="NIO-BIO-AIO"><a href="#NIO-BIO-AIO" class="headerlink" title="NIO,BIO,AIO"></a>NIO,BIO,AIO</h3><p>BIO 同步阻塞I&#x2F;O模式，数据的读取写入必须阻塞在一个线程内等待其完成。</p>
<p>NIO是一种同步非阻塞的I&#x2F;O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。</p>
<p>AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
<h3 id="NIO的特性-x2F-NIO与IO区别"><a href="#NIO的特性-x2F-NIO与IO区别" class="headerlink" title="NIO的特性&#x2F;NIO与IO区别"></a>NIO的特性&#x2F;NIO与IO区别</h3><p>如果是在面试中回答这个问题，我觉得首先肯定要从 NIO 流是非阻塞 IO 而 IO 流是阻塞 IO 说起。然后，可以从 NIO 的3个核心组件&#x2F;特性为 NIO 带来的一些改进来分析。如果，你把这些都回答上了我觉得你对于 NIO 就有了更为深入一点的认识，面试官问到你这个问题，你也能很轻松的回答上来了。</p>
<p>1)Non-blocking IO（非阻塞IO）</p>
<p><strong>IO流是阻塞的，NIO流是不阻塞的。</strong></p>
<p>Java NIO使我们可以进行非阻塞IO操作。比如说，单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。写数据也是一样的。另外，非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。</p>
<p>Java IO的各种流是阻塞的。这意味着，当一个线程调用 <code>read()</code> 或 <code>write()</code> 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了</p>
<p>2)Buffer(缓冲区)</p>
<p><strong>IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。</strong></p>
<p>Buffer是一个对象，它包含一些要写入或者要读出的数据。在NIO类库中加入Buffer对象，体现了新库与原I&#x2F;O的一个重要区别。在面向流的I&#x2F;O中·可以将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。</p>
<p>在NIO厍中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。</p>
<p>最常用的缓冲区是 ByteBuffer,一个 ByteBuffer 提供了一组功能用于操作 byte 数组。除了ByteBuffer,还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean类型）都对应有一种缓冲区。</p>
<p>3)Channel (通道)</p>
<p>NIO 通过Channel（通道） 进行读写。</p>
<p>通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。</p>
<p>4)Selectors(选择器)</p>
<p>NIO有选择器，而IO没有。</p>
<p><strong>选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道</strong>。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/20190422121139668.png" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/01/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/01/Spring/" class="post-title-link" itemprop="url">Spring</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-01 23:47:44" itemprop="dateCreated datePublished" datetime="2022-03-01T23:47:44+08:00">2022-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-21 14:04:24" itemprop="dateModified" datetime="2022-04-21T14:04:24+08:00">2022-04-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">Java知识</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="谈谈自己对于-Spring-IoC-的了解"><a href="#谈谈自己对于-Spring-IoC-的了解" class="headerlink" title="谈谈自己对于 Spring IoC 的了解"></a>谈谈自己对于 Spring IoC 的了解</h3><p><strong>IoC（Inverse of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p>
<p><strong>为什么叫控制反转？</strong></p>
<ul>
<li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li>
<li><strong>反转</strong> ：控制权交给外部环境（Spring 框架、IoC 容器）</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/frc-365faceb5697f04f31399937c059c162.png" alt="img"></p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何被创建出来的。</p>
<p>在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p>
<p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p>
<h3 id="谈谈自己对于-AOP-的了解"><a href="#谈谈自己对于-AOP-的了解" class="headerlink" title="谈谈自己对于 AOP 的了解"></a>谈谈自己对于 AOP 的了解</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p>AOP在不更改业务逻辑上进行功能增强，一般用于安全检查，日志操作，事务操作，比如说我要在一个功能上加入日志就可以，利用ioc，好处是不影响原有业务逻辑，并且可以复用，底层使用的是动态代理，如果对应的类实现了接口就使用JDK的动态代理，否则使用的就cglid代理。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220421140351287.png" alt="image-20220421140351287"></p>
<p>当然你也可以使用 <strong>AspectJ</strong> ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>我们可以把 <code>@SpringBootApplication</code>看作是 <code>**@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>** 注解的集合。</p>
<p>根据 SpringBoot 官网，这三个注解的作用分别是：</p>
<ul>
<li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制，是借助 @Import 的帮助，将所有符合自动配置条件的 bean 定义加载到 IoC 容器，仅此而已！</li>
<li><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描该类所在的包下所有的类。</li>
<li><code>@Configuration</code>：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类，@ComponentScan 的功能其实就是自动扫描并加载符合条件的组件或 bean 定义，最终将这些 bean 定义加载到容器中。加载 bean 定义到 Spring 的 IoC 容器，我们可以手工单个注册，不一定非要通过批量的自动扫描完成，</li>
</ul>
<h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><h3 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h3><p>　就Spring 声明式事务而言，无论其基于 <tx> 命名空间的实现还是基于 @Transactional 的实现，其本质都是 Spring AOP 机制的应用：即通过以@Transactional的方式或者XML配置文件的方式向业务组件中的目标业务方法插入事务增强处理并生成相应的代理对象供应用程序(客户端)使用从而达到无污染地添加事务的目的。如下图所示：</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
