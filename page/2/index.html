<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="akurisu">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="akurisu">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>akurisu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">akurisu</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/06/JUC%E7%9F%A5%E8%AF%86%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/JUC%E7%9F%A5%E8%AF%86%E7%82%B9/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-06 15:16:01" itemprop="dateCreated datePublished" datetime="2022-04-06T15:16:01+08:00">2022-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-22 09:06:35" itemprop="dateModified" datetime="2022-03-22T09:06:35+08:00">2022-03-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><p><img src="/JUC%E7%9F%A5%E8%AF%86%E7%82%B9.assets/image-20220322090438844.png" alt="image-20220322090438844"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/06/JUC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/JUC/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-06 15:16:01 / 修改时间：15:18:34" itemprop="dateCreated datePublished" datetime="2022-04-06T15:16:01+08:00">2022-04-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="线程有哪几种状态"><a href="#线程有哪几种状态" class="headerlink" title="线程有哪几种状态"></a>线程有哪几种状态</h2><p><strong>六种状态及转换</strong></p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JUC.assets/image-20210831090722658.png" alt="image-20210831090722658"></p>
<p>分别是</p>
<ul>
<li>新建<ul>
<li>当一个线程对象被创建，但还未调用 start 方法时处于<strong>新建</strong>状态</li>
<li>此时未与操作系统底层线程关联</li>
</ul>
</li>
<li>可运行<ul>
<li>调用了 start 方法，就会由<strong>新建</strong>进入<strong>可运行</strong></li>
<li>此时与底层线程关联，由操作系统调度执行</li>
</ul>
</li>
<li>终结<ul>
<li>线程内代码已经执行完毕，由<strong>可运行</strong>进入<strong>终结</strong></li>
<li>此时会取消与底层线程关联</li>
</ul>
</li>
<li>阻塞<ul>
<li>当获取锁失败后，由<strong>可运行</strong>进入 Monitor 的阻塞队列<strong>阻塞</strong>，此时不占用 cpu 时间</li>
<li>当持锁线程释放锁时，会按照一定规则唤醒阻塞队列中的<strong>阻塞</strong>线程，唤醒后的线程进入<strong>可运行</strong>状态</li>
</ul>
</li>
<li>等待<ul>
<li>当获取锁成功后，但由于条件不满足，调用了 wait() 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合<strong>等待</strong>，同样不占用 cpu 时间</li>
<li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>等待</strong>线程，恢复为<strong>可运行</strong>状态</li>
</ul>
</li>
<li>有时限等待<ul>
<li>当获取锁成功后，但由于条件不满足，调用了 wait(long) 方法，此时从<strong>可运行</strong>状态释放锁进入 Monitor 等待集合进行<strong>有时限等待</strong>，同样不占用 cpu 时间</li>
<li>当其它持锁线程调用 notify() 或 notifyAll() 方法，会按照一定规则唤醒等待集合中的<strong>有时限等待</strong>线程，恢复为<strong>可运行</strong>状态，并重新去竞争锁</li>
<li>如果等待超时，也会从<strong>有时限等待</strong>状态恢复为<strong>可运行</strong>状态，并重新去竞争锁</li>
<li>还有一种情况是调用 sleep(long) 方法也会从<strong>可运行</strong>状态进入<strong>有时限等待</strong>状态，但与 Monitor 无关，不需要主动唤醒，超时时间到自然恢复为<strong>可运行</strong>状态</li>
</ul>
</li>
</ul>
<blockquote>
<p><em><strong>其它情况（只需了解）</strong></em></p>
<ul>
<li>可以用 interrupt() 方法打断<strong>等待</strong>、<strong>有时限等待</strong>的线程，让它们恢复为<strong>可运行</strong>状态</li>
<li>park，unpark 等方法也可以让线程等待和唤醒</li>
</ul>
</blockquote>
<h2 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h2><p>七大参数</p>
<ol>
<li>corePoolSize 核心线程数目 - 池中会保留的最多线程数</li>
<li>maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目</li>
<li>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</li>
<li>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</li>
<li>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</li>
<li>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li>
<li>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略<ol>
<li>抛异常 java.util.concurrent.ThreadPoolExecutor.AbortPolicy</li>
<li>由调用者执行任务 java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy</li>
<li>丢弃任务 java.util.concurrent.ThreadPoolExecutor.DiscardPolicy</li>
<li>丢弃最早排队任务并执行当前任务 java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy</li>
</ol>
</li>
</ol>
<h2 id="wait-vs-sleep"><a href="#wait-vs-sleep" class="headerlink" title="wait vs sleep"></a>wait vs sleep</h2><p><strong>一个共同点，三个不同点</strong></p>
<p>共同点</p>
<ul>
<li>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</li>
</ul>
<p>不同点</p>
<ul>
<li><p>方法归属不同</p>
<ul>
<li>sleep(long) 是 Thread 的静态方法</li>
<li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</li>
</ul>
</li>
<li><p>醒来时机不同</p>
<ul>
<li>执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li>
<li>wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</li>
<li>它们都可以被打断唤醒</li>
</ul>
</li>
<li><p>锁特性不同（重点）</p>
<ul>
<li>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</li>
<li>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</li>
<li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</li>
</ul>
</li>
</ul>
<h2 id="lock-vs-synchronized"><a href="#lock-vs-synchronized" class="headerlink" title="lock vs synchronized"></a>lock vs synchronized</h2><p><strong>要求</strong></p>
<ul>
<li>掌握 lock 与 synchronized 的区别</li>
<li>理解 ReentrantLock 的公平、非公平锁</li>
<li>理解 ReentrantLock 中的条件变量</li>
</ul>
<p>synchronized</p>
<ul>
<li>对于普通同步方法，锁是当前实例对象</li>
<li>对于静态同步方法，锁是当前类的Class对象</li>
<li>对于同步代码块，锁是Synchronized括号里配置的对象</li>
</ul>
<p><strong>三个层面</strong></p>
<p>不同点</p>
<ul>
<li>语法层面<ul>
<li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现</li>
<li>Lock 是接口，源码由 jdk 提供，用 java 语言实现</li>
<li>使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁</li>
</ul>
</li>
<li>功能层面<ul>
<li>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</li>
<li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量</li>
<li>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock</li>
</ul>
</li>
<li>性能层面<ul>
<li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li>
<li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li>
</ul>
</li>
</ul>
<p><strong>公平锁</strong></p>
<ul>
<li>公平锁的公平体现<ul>
<li><strong>已经处在阻塞队列</strong>中的线程（不考虑超时）始终都是公平的，先进先出</li>
<li>公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，如果队列不为空，则老实到队尾等待</li>
<li>非公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，与队列头唤醒的线程去竞争，谁抢到算谁的</li>
</ul>
</li>
<li>公平锁会降低吞吐量，一般不用</li>
</ul>
<p><strong>条件变量</strong></p>
<ul>
<li>ReentrantLock 中的条件变量功能类似于普通 synchronized 的 wait，notify，用在当线程获得锁后，发现条件不满足时，临时等待的链表结构</li>
<li>与 synchronized 的等待集合不同之处在于，ReentrantLock 中的条件变量可以有多个，可以实现更精细的等待、唤醒控制</li>
</ul>
<blockquote>
<p><em><strong>代码说明</strong></em></p>
<ul>
<li>day02.TestReentrantLock 用较为形象的方式演示 ReentrantLock 的内部结构</li>
</ul>
</blockquote>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>线程安全要考虑三个方面</p>
<ol>
<li>可见性：一个线程对共享变量修改，另一个线程能看到最新的结果</li>
<li>有序性：一个线程内代码按编写顺序执行</li>
<li>原子性：一个线程内多行代码以一个整体运行，期间不能有其他的代码插队</li>
</ol>
<p>volatile只能保证共享变量的可见性和有序性，但并不能保证原子性</p>
<p><strong>原子性</strong></p>
<ul>
<li>起因：多线程下，不同线程的<strong>指令发生了交错</strong>导致的共享变量的读写混乱</li>
<li>解决：用悲观锁或乐观锁解决，volatile 并不能解决原子性</li>
</ul>
<p><strong>可见性</strong></p>
<p>JIT把多次运行的代码替换掉，使得每次读取的都为false</p>
<ul>
<li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致的对共享变量所做的修改另外的线程看不到</li>
<li>解决：用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</li>
</ul>
<p><strong>有序性</strong></p>
<ul>
<li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致指令的实际执行顺序与编写顺序不一致</li>
<li>解决：用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</li>
<li>注意：<ul>
<li><strong>volatile 变量写</strong>加的屏障是阻止上方其它写操作越过屏障排到 <strong>volatile 变量写</strong>之下</li>
<li><strong>volatile 变量读</strong>加的屏障是阻止下方其它读操作越过屏障排到 <strong>volatile 变量读</strong>之上</li>
<li>volatile 读写加入的屏障只能防止同一线程内的指令重排</li>
</ul>
</li>
</ul>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JUC.assets/image-20220322100227889.png" alt="image-20220322100227889"></p>
<h2 id="6-悲观锁-vs-乐观锁"><a href="#6-悲观锁-vs-乐观锁" class="headerlink" title="6. 悲观锁 vs 乐观锁"></a>6. 悲观锁 vs 乐观锁</h2><p><strong>对比悲观锁与乐观锁</strong></p>
<ul>
<li><p>悲观锁的代表是 synchronized 和 Lock 锁</p>
<ul>
<li>其核心思想是【线程只有占有了锁，才能去操作共享变量，每次只有一个线程占锁成功，获取锁失败的线程，都得停下来等待】</li>
<li>线程从运行到阻塞、再从阻塞到唤醒，涉及线程上下文切换，如果频繁发生，影响性能</li>
<li>实际上，线程在获取 synchronized 和 Lock 锁时，如果锁已被占用，都会做几次重试操作，减少阻塞的机会</li>
</ul>
</li>
<li><p>乐观锁的代表是 AtomicInteger，使用 cas 来保证原子性</p>
<ul>
<li>其核心思想是【无需加锁，每次只有一个线程能成功修改共享变量，其它失败的线程不需要停止，不断重试直至成功】</li>
<li>由于线程一直运行，不需要阻塞，因此不涉及线程上下文切换</li>
<li>它需要多核 cpu 支持，且线程数不应超过 cpu 核数</li>
</ul>
</li>
</ul>
<blockquote>
<p><em><strong>代码说明</strong></em></p>
<ul>
<li>day02.SyncVsCas 演示了分别使用乐观锁和悲观锁解决原子赋值</li>
<li>请同时参考视频讲解</li>
</ul>
</blockquote>
<h2 id="7-Hashtable-vs-ConcurrentHashMap"><a href="#7-Hashtable-vs-ConcurrentHashMap" class="headerlink" title="7. Hashtable vs ConcurrentHashMap"></a>7. Hashtable vs ConcurrentHashMap</h2><p><strong>要求</strong></p>
<ul>
<li>掌握 Hashtable 与 ConcurrentHashMap 的区别</li>
<li>掌握 ConcurrentHashMap 在不同版本的实现区别</li>
</ul>
<blockquote>
<p>更形象的演示，见资料中的 hash-demo.jar，运行需要 jdk14 以上环境，进入 jar 包目录，执行下面命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar --add-exports java.base/jdk.internal.misc=ALL-UNNAMED hash-demo.jar</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>Hashtable 对比 ConcurrentHashMap</strong></p>
<ul>
<li>Hashtable 与 ConcurrentHashMap 都是线程安全的 Map 集合</li>
<li>Hashtable 并发度低，整个 Hashtable 对应一把锁，同一时刻，只能有一个线程操作它</li>
<li>ConcurrentHashMap 并发度高，整个 ConcurrentHashMap 对应多把锁，只要线程访问的是不同锁，那么不会冲突</li>
</ul>
<p>HashTable每次扩容2*n+1</p>
<p><strong>ConcurrentHashMap 1.7</strong></p>
<ul>
<li>数据结构：<code>Segment(大数组容量clevel并发度不能扩容) + HashEntry(小数组) + 链表</code>，每个 Segment 对应一把锁，如果多个线程访问不同的 Segment，则不会冲突</li>
<li>*<em>capacity</em>loadfactor 为小数组的扩容值，一旦大于就扩容，各自小数组分别扩容，小数组等价于原来的HashMap的数组，<img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JUC.assets/image-20220322111243513.png" alt="image-20220322111243513">，初始segmment[0]小数组的容量为capacity&#x2F;clevel（最小值为2)**，其他小数组初始化根据这个[0]数组初始化</li>
<li>并发度：Segment 数组大小即并发度，决定了同一时刻最多能有多少个线程并发访问。Segment 数组不能扩容，意味着并发度在 ConcurrentHashMap 创建时就固定了</li>
<li>索引计算<ul>
<li>假设大数组长度是 $2^m$，key 在大数组内的索引是 key 的二次 hash 值的高 m 位</li>
<li>假设小数组长度是 $2^n$，key 在小数组内的索引是 key 的二次 hash 值的低 n 位</li>
</ul>
</li>
<li>扩容：每个小数组的扩容相对独立，小数组在超过扩容因子时会触发扩容，每次扩容翻倍</li>
<li>Segment[0] 原型：首次创建其它小数组时，会以此原型为依据，数组长度，扩容因子都会以原型为准</li>
</ul>
<p><strong>ConcurrentHashMap 1.8</strong></p>
<p>capcity为要放的数组元素个数，不是数组的个数，因为16放不下16个（只能放下capcity*loadfactor个数,只有初始化时会看loadfactor的值，否则按0.75计算），所以初始会为2^5即32个元素</p>
<ul>
<li>数据结构：<code>Node 数组 + 链表或红黑树</code>，数组的每个头节点作为锁，如果多个线程访问的头节点不同，则不会冲突。首次生成头节点时如果发生竞争，利用 cas 而非 syncronized，进一步提升性能</li>
<li>并发度：Node 数组有多大，并发度就有多大，与 1.7 不同，Node 数组可以扩容</li>
<li>扩容条件<strong>：Node 数组满 3&#x2F;4 时就会扩容</strong></li>
<li>扩容单位：以链表为单位从后向前迁移链表，迁移完成的将旧数组头节点替换为 ForwardingNode，当旧数组所有值都为ForwardingNode就用新数组替换。</li>
<li>扩容时并发 get<ul>
<li>根据是否为 ForwardingNode 来决定是在新数组查找还是在旧数组查找，不会阻塞</li>
<li>如果链表长度超过 1，<strong>则需要对节点进行复制（创建新节点）</strong>，怕的是节点迁移后 next 指针改变。</li>
<li>如果链表最后几个元素扩容后索引不变，则节点无需复制，</li>
</ul>
</li>
<li>扩容时并发 put<ul>
<li>如果 put 的线程与扩容线程操作的链表是同一个，put 线程会阻塞</li>
<li>如果 put 的线程操作的链表还未迁移完成，即头节点不是 ForwardingNode，则可以并发执行</li>
<li>如果 put 的线程操作的链表已经迁移完成，即头结点是 ForwardingNode，则可以协助扩容</li>
</ul>
</li>
<li>与 1.7 相比是懒惰初始化</li>
<li>capacity 代表预估的元素个数，capacity &#x2F; factory 来计算出初始数组大小，需要贴近 $2^n$ </li>
<li>loadFactor 只在计算初始数组大小时首次被使用，之后扩容固定为 3&#x2F;4</li>
<li>超过树化阈值时的扩容问题，如果容量已经是 64，直接树化，否则在原来容量基础上做 3 轮扩容</li>
</ul>
<h2 id="8-ThreadLocal"><a href="#8-ThreadLocal" class="headerlink" title="8. ThreadLocal"></a>8. ThreadLocal</h2><p><strong>作用</strong></p>
<ul>
<li>ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免争用引发的线程安全问题</li>
<li>ThreadLocal 同时实现了线程内的资源共享</li>
</ul>
<p><strong>原理</strong></p>
<p>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p>
<ul>
<li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li>
<li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li>
<li>调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li>
</ul>
<p>ThreadLocalMap 的一些特点</p>
<ul>
<li>key 的 hash 值统一分配</li>
<li>初始容量 16，扩容因子 2&#x2F;3，扩容容量翻倍</li>
<li>key 索引冲突后用开放寻址法解决冲突</li>
</ul>
<p><strong>弱引用 key</strong></p>
<p>ThreadLocalMap 中的 key 被设计为弱引用，原因如下</p>
<ul>
<li>Thread 可能需要长时间运行（如线程池中的线程），如果 key 不再使用，需要在内存不足（GC）时释放其占用的内存，如果设置为强引用不能被垃圾回收掉</li>
</ul>
<p><strong>内存释放时机</strong></p>
<ul>
<li>被动 GC 释放 key<ul>
<li>仅是让 key 的内存释放，关联 value 的内存并不会释放</li>
</ul>
</li>
<li>懒惰被动释放 value<ul>
<li>get key 时，发现是 null key，则释放其 value 内存</li>
<li>set key 时，会使用启发式扫描，清除临近的 null key 的 value 内存，启发次数与元素个数，是否发现 null key 有关</li>
</ul>
</li>
<li>主动 remove 释放 key，value<ul>
<li>会同时释放 key，value 的内存，也会清除临近的 null key 的 value 内存</li>
<li>推荐使用它，因为一般使用 ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/06/Java%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/Java%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-06 15:16:01" itemprop="dateCreated datePublished" datetime="2022-04-06T15:16:01+08:00">2022-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-26 23:00:36" itemprop="dateModified" datetime="2022-03-26T23:00:36+08:00">2022-03-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Java-集合概览"><a href="#Java-集合概览" class="headerlink" title="Java 集合概览"></a>Java 集合概览</h3><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</p>
<p>Java 集合框架如下图所示：</p>
<p><img src="/Java%E5%9F%BA%E7%A1%80.assets%5Cjava-collection-hierarchy.1727461b.png" alt="img"></p>
<p>注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了<code>AbstractList</code>, <code>NavigableSet</code>等抽象类以及其他的一些辅助类，如想深入了解，可自行查看源码。</p>
<h3 id="说说-List-Set-Queue-Map-四者的区别？"><a href="#说说-List-Set-Queue-Map-四者的区别？" class="headerlink" title="#说说 List, Set, Queue, Map 四者的区别？"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#%E8%AF%B4%E8%AF%B4-list-set-queue-map-%E5%9B%9B%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB">#</a>说说 List, Set, Queue, Map 四者的区别？</h3><ul>
<li><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li>
<li><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li>
<li><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li>
<li><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>
</ul>
<h3 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="#集合框架底层数据结构总结"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93">#</a>集合框架底层数据结构总结</h3><p>先来看一下 <code>Collection</code> 接口下面的集合。</p>
<h4 id="List"><a href="#List" class="headerlink" title="#List"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#list">#</a>List</h4><ul>
<li><code>Arraylist</code>： <code>Object[]</code> 数组</li>
<li><code>Vector</code>：<code>Object[]</code> 数组</li>
<li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>
</ul>
<h4 id="Set"><a href="#Set" class="headerlink" title="#Set"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#set">#</a>Set</h4><ul>
<li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li>
<li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li>
<li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li>
</ul>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="#Queue"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#queue">#</a>Queue</h4><ul>
<li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li>
<li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li>
</ul>
<p>再来看看 <code>Map</code> 接口下面的集合。</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="#Map"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#map">#</a>Map</h4><ul>
<li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a target="_blank" rel="noopener" href="https://www.imooc.com/article/22931">《LinkedHashMap 源码详细分析（JDK1.8）》open in new window</a></li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li>
</ul>
<h3 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="#如何选用集合?"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#%E5%A6%82%E4%BD%95%E9%80%89%E7%94%A8%E9%9B%86%E5%90%88">#</a>如何选用集合?</h3><h3 id="JDK1-8-之前"><a href="#JDK1-8-之前" class="headerlink" title="JDK1.8 之前"></a>JDK1.8 之前</h3><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。</p>
<p>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p>
<p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p>
<p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^ ：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>
<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/jdk1.8%E4%B9%8B%E5%89%8D%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="jdk1.8之前的内部结构"></p>
<h3 id="JDK1-8-之后"><a href="#JDK1-8-之后" class="headerlink" title="JDK1.8 之后"></a>JDK1.8 之后</h3><p>相比于之前的版本，JDK1.8 以后在解决哈希冲突时有了较大的变化。</p>
<p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 <code>resize()</code> 方法对数组扩容。相关源码这里就不贴了，重点关注 <code>treeifyBin()</code>方法即可！</p>
<p><img src="/Java%E5%9F%BA%E7%A1%80.assets%5Cup-bba283228693dae74e78da1ef7a9a04c684.png" alt="img"></p>
<h3 id="HashMap底层原理"><a href="#HashMap底层原理" class="headerlink" title="HashMap底层原理"></a>HashMap底层原理</h3><ul>
<li><p><strong>loadFactor 加载因子</strong></p>
<p>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>
<p><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</p>
<p><strong>给定的默认容量为 16，负载因子为 0.75</strong>。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 &#x3D; 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>
</li>
<li><p><strong>threshold</strong></p>
<p><strong>threshold &#x3D; capacity * loadFactor</strong>，<strong>当 Size&gt;&#x3D;threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p>
</li>
</ul>
<p>红黑树的阈值是8，当链表大于等于8时链表变成了红黑树结构，大大减少了查找的时间。</p>
<p>当长度低于6时会由红黑树转成链表,TreeNodes占用空间是普通Nodes的两倍,所以只有当bin包含足够多的节点时才会转成TreeNodes,而是否足够多就是由TREEIFY_THRESHOLD的值决定的,当bin中节点数变少时，又会转成普通的bin,这样就解析了为什么不是一开始就将其转换为TreeNodes，而是需要一定节点数才转为TreeNodes，说白了就是trade-off，空间和时间的权衡。</p>
<h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><p>两者的主要区别在于解决问题的方式不同：</p>
<ul>
<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>
<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li>
</ul>
<p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p>
<h3 id="场景题给十亿个手机号进行去重"><a href="#场景题给十亿个手机号进行去重" class="headerlink" title="场景题给十亿个手机号进行去重"></a>场景题给十亿个手机号进行去重</h3><p>利用位图bitmap</p>
<p><img src="/Java%E5%9F%BA%E7%A1%80.assets/image-20220326180402088.png" alt="image-20220326180402088"></p>
<p><img src="/Java%E5%9F%BA%E7%A1%80.assets/image-20220326180440696.png" alt="image-20220326180440696"></p>
<p><img src="/Java%E5%9F%BA%E7%A1%80.assets/image-20220326180648995.png" alt="image-20220326180648995"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/06/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-06 08:58:35" itemprop="dateCreated datePublished" datetime="2022-04-06T08:58:35+08:00">2022-04-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
