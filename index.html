<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="akurisu">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="akurisu">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>akurisu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">akurisu</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-06 15:16:01 / 修改时间：15:27:11" itemprop="dateCreated datePublished" datetime="2022-04-06T15:16:01+08:00">2022-04-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p> R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的<strong>二叉查找树</strong>。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p>
<p><strong>红黑树的特性</strong>:</p>
<ol>
<li><strong>每个节点或者是黑色，或者是红色。</strong></li>
<li><strong>根节点是黑色。</strong></li>
<li><strong>每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</strong></li>
<li><strong>如果一个节点是红色的，则它的子节点必须是黑色的。</strong></li>
<li><strong>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点</strong></li>
<li><strong>对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点</strong></li>
</ol>
<p>(01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。</p>
<p>(02) 特性(5)，<strong>确保没有一条路径会比其他路径长出俩倍</strong>。因而，红黑树是相对是接近平衡的二叉树。</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20220405160645933.png" alt="image-20220405160645933"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-06 15:16:01" itemprop="dateCreated datePublished" datetime="2022-04-06T15:16:01+08:00">2022-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-21 12:25:47" itemprop="dateModified" datetime="2022-03-21T12:25:47+08:00">2022-03-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/06/%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-06 15:16:01" itemprop="dateCreated datePublished" datetime="2022-04-06T15:16:01+08:00">2022-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-27 18:36:38" itemprop="dateModified" datetime="2022-03-27T18:36:38+08:00">2022-03-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="SpringBoot的执行流程"><a href="#SpringBoot的执行流程" class="headerlink" title="SpringBoot的执行流程"></a>SpringBoot的执行流程</h2><p>（1）创建 Spring Application 实例，调用 run 方法，同时将启动入口类作 为参数传递进去，由此开始了 Spring Boot 内部相关核心组件以及配置的 启动和加载；</p>
<p>（2）通过 Spring Factories Loader 加载 META-INF&#x2F;spring.factories 文 件，获取并创建 SpringApplicationRunListener 对象；</p>
<p>（3）然后由 SpringApplicationRunListener 来发出 starting 消息；</p>
<p>（4）创建参数，并配置当前 SpringBoot 应用需要使用的 Environment 实 例；</p>
<p>（5）完成之后，依然由 SpringApplicationRunListener 来发出 environmentPrepared 消息；</p>
<p>（6）创建 Spring 的应用上下文实例：ApplicationContext，初始化该实例 并设置应用环境配置实例：Environment，同时加载相关的配置项；</p>
<p>（7）由 SpringApplicationRunListener 发出 contextPrepared 消息，告 知 SpringBoot 应用当前使用的 ApplicationContext 已准备完毕；</p>
<p>（8）将各种 Bean 组件装载入 Spring 的 IO 容器&#x2F;应用上下文： ApplicationContext 中，继续由 SpringApplicationRunListener 来发出 contextLoaded 消息，告知 SpringBoot 应用当前使用的 ApplicationContext 已准备完毕；</p>
<p>（9）重新刷新 Refresh Spring 的应用上下文实例：ApplicationContext， 完成 IOC 容器可用的最后一步；</p>
<p>（10）由 SpringApplicationRunListener 发出 started 消息，完成最终的 程序的启动；</p>
<p>（11）由 SpringApplicationRunListener 发出 running 消息，告知程序已 成功运行起来了。</p>
<p>Spring Boot在启动的时候就是从类路径下的META-INF&#x2F;spring.factories中获取需要自动装配的类 （一些配置组件），找到这些类（XXXAutoConfiguration），通过SpringFactoriesLoader机制创建对应的bean，注入到容器中，完成了自动注入spring容器，本来需要在spring的xml配置文件中去配置bean的操作就免去了 ，也就是springboot完成了自动装配。</p>
<h2 id="SpringBoot自动装配的原理"><a href="#SpringBoot自动装配的原理" class="headerlink" title="SpringBoot自动装配的原理"></a>SpringBoot自动装配的原理</h2><p>Spring Boot在启动的时候就是从类路径下的META-INF&#x2F;spring.factories中获取需要自动装配的类 （一些配置组件），找到这些类（XXXAutoConfiguration），通过SpringFactoriesLoader机制创建对应的bean，注入到容器中，完成了自动注入spring容器，本来需要在spring的xml配置文件中去配置bean的操作就免去了 ，也就是springboot完成了自动装配。</p>
<h2 id="SpringBootConfiguration注解"><a href="#SpringBootConfiguration注解" class="headerlink" title="SpringBootConfiguration注解"></a>SpringBootConfiguration注解</h2><p>@SpringBootConfiguration这个注解 这个其实就是上面介绍过的@Configuration的注解 用于定义bean的，springboot的启动类其实也就是作为spring的一个bean注入到spring容器中。</p>
<p>@ComponentScan 是spring中的注解 主要就是定义扫描的路径从中找出标识了需要装配的类自动装配到spring的bean容器中</p>
<p>@EnableAutoConfiguration这个注解 这个是开启自动装配的核心注解，他的作用就是获取配置类 扫描并注入IOC容器中进行管理，他也是组合注解 我们点进去看又能看到</p>
<p>另外两个:<br>@AutoConfigurationPackage 添加该注解的类所在的package 作为 自动配置package 进行管理，个人的理解吧 我觉得这个注解的含义就是扫描springboot所在包 将其配置类交给IOC管理。</p>
<p>@Import({AutoConfigurationImportSelector.class}) 这个导入AutoConfigurationImportSelector.class这个类，将其注入spring容器<br>而这个导入的类的作用可以帮助将所有符合条件的@Configuration配置交给spring的IOC容器进行注入。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-06 15:16:01 / 修改时间：15:23:28" itemprop="dateCreated datePublished" datetime="2022-04-06T15:16:01+08:00">2022-04-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="OSI七层网络体系"><a href="#OSI七层网络体系" class="headerlink" title="OSI七层网络体系"></a>OSI七层网络体系</h3><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220313185712942.png" alt="image-20220313185712942"></p>
<h3 id="TCP-x2F-IP网络体系"><a href="#TCP-x2F-IP网络体系" class="headerlink" title="TCP&#x2F;IP网络体系"></a>TCP&#x2F;IP网络体系</h3><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220313185422470.png" alt="image-20220313185422470"></p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层</li>
</ol>
<h1 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP报文头"><a href="#HTTP报文头" class="headerlink" title="HTTP报文头"></a>HTTP报文头</h3><p>下面提供了一个典型的HTTP请求报文: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /somedir/page・html HTTP/1.1 </span><br><span class="line">Host: www・someschool•edu </span><br><span class="line">Connection: close </span><br><span class="line">User-agent: Mozilla/5•0</span><br><span class="line">Accept-language: fr</span><br></pre></td></tr></table></figure>

<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220329122500251.png" alt="image-20220329122500251"></p>
<p>http 报文头分为两种，一种是请求报文头和响应报文头 包含一下几个部分：<strong>请求行，首部行和实体体</strong>。其中请求行包含了这个请求的方法：有 GET、  POST、PUT、HEAD、DELETE。还包含了 URL 字段和 HTTP 的版本。实体体中，<strong>如果使用的是 get 方法，那么实体体就为空，如果使用的是 post 方法，那么响应的文本内容就会放在实体体中。</strong>HEAD 方法类似于 GET 方法，但是发送一个 HEAD 请求是不会返回请求的对象的。一般用于调试。PUT 方法时允许用户上传对象到指定的 web 服务器上的指定路径。DELETE 就是删除 web 服务器上的对象。首部行里面的信息。</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220329125857983.png" alt="image-20220329125857983"></p>
<p>我们仔细看一下这个响应报文。它有三个部分：一个初始状态行（status line） , 6个 首部行（headerline）,然后是实体体（entity body）o。</p>
<h3 id="Http常见响应码"><a href="#Http常见响应码" class="headerlink" title="Http常见响应码"></a>Http常见响应码</h3><h4 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h4><ul>
<li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li>
</ul>
<h4 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="#2XX 成功"></a><a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html#_2xx-%E6%88%90%E5%8A%9F">#</a>2XX 成功</h4><ul>
<li><strong>200 OK</strong>   请求成功，信息在返回的响应报文中。</li>
<li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>
<li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li>
</ul>
<h4 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="#3XX 重定向"></a><a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html#_3xx-%E9%87%8D%E5%AE%9A%E5%90%91">#</a>3XX 重定向</h4><ul>
<li><strong>301 Moved Permanently</strong> ：永久性重定向</li>
<li><strong>302 Found</strong> ：临时性重定向</li>
<li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li>
<li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li>
<li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>
<li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>
</ul>
<h4 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="#4XX 客户端错误"></a><a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html#_4xx-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF">#</a>4XX 客户端错误</h4><ul>
<li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li>
<li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>
<li><strong>403 Forbidden</strong> ：请求被拒绝。</li>
<li><strong>404 Not Found</strong>：被请求的文档不在服务器上</li>
</ul>
<h4 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="#5XX 服务器错误"></a><a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html#_5xx-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF">#</a>5XX 服务器错误</h4><ul>
<li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li>
<li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</li>
<li><strong>505 HTTP Version Not Supported</strong>：服务器不支持请求报文使用的HTTP协议版本。</li>
</ul>
<h3 id="HTTP-x2F-1-0vsHTTP-x2F-1-1vsHTTP-x2F-2-0"><a href="#HTTP-x2F-1-0vsHTTP-x2F-1-1vsHTTP-x2F-2-0" class="headerlink" title="HTTP&#x2F;1.0vsHTTP&#x2F;1.1vsHTTP&#x2F;2.0"></a>HTTP&#x2F;1.0vsHTTP&#x2F;1.1vsHTTP&#x2F;2.0</h3><h4 id="HTTP-x2F-1-0"><a href="#HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h4><p>HTTP&#x2F;1.0中浏览器与服务器只保持短暂的连接，连接无法复用。也就是说每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p>
<p>我们知道TCP连接的建立需要三次握手，是很耗费时间的一个过程。所以，HTTP&#x2F;1.0版本的性能比较差。</p>
<blockquote>
<p>HTTP1.0 其实也可以强制开启长链接，例如接受<code>Connection: keep-alive</code> 这个字段，但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p>
</blockquote>
<h4 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h4><p>为了解决HTTP&#x2F;1.0存在的缺陷，HTTP&#x2F;1.1于1999年诞生。相比较于HTTP&#x2F;1.0来说，最主要的改进就是引入了持久连接。所谓的持久连接即<strong>TCP连接默认不关闭，可以被多个请求复用</strong>。</p>
<p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。或者客户端在最后一个请求时，主动告诉服务端要关闭连接。H<strong>TTP&#x2F;1.1版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</strong></p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220329131132781.png" alt="image-20220329131132781"></p>
<h4 id="HTTP-x2F-2-0"><a href="#HTTP-x2F-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h4><p>  HTTP&#x2F;2.0主要基于 SPDY 协议。HTTP&#x2F;2 为了解决HTTP&#x2F;1.1中仍然存在的效率问题，HTTP&#x2F;2 采用了<strong>多路复用</strong>。即在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。能这样做有一个前提，就是HTTP&#x2F;2进行了<strong>二进制分帧</strong>，即 HTTP&#x2F;2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码。</p>
<p>  除此之外，还有一些其他的优化，比如<strong>做Header压缩、服务端推送</strong>等。</p>
<p>  <strong>Header压缩</strong>就是压缩老板和员工之间的对话。</p>
<p>  <strong>服务端推送</strong>就是员工事先把一些老板可能询问的事情提现发送到老板的手机（缓存）上。这样老板想要知道的时候就可以直接读取短信（缓存）了。</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>  HTTPS 是在 HTTP 的基础上增加了 <strong>SSL 或 TLS 安全协议</strong>（TLS 不支持数字证书），让 HTTP 先 和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行 通信。</p>
<p>   SSL 和 TLS 这两个协议可以加密处理数据（采用混合加密技术）防止数据被监听、验证通信方身份 （通过数字证书认证通信方是自己的服务器）以及数据完整性保护（防止传输的内容被中间人冒充 或者篡改），也就是说 HTTPS 使用了隧道进行通信。隧道：使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。 </p>
<p>  通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p>
<h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220330093509369.png" alt="image-20220330093509369"></p>
<p>1、 客户端发送自己支持的加密规则给服务器，代表告诉服务器要进行连接了；</p>
<p>2、 服务器从中选出一套加密算法和 hash 算法以及自己的身份信息（地址等）以证书的形式发送给浏览器，证书中包含<strong>服务器信息，加密公钥，证书的办法机构；</strong></p>
<p>3、客户端收到网站的证书之后要做下面的事情：</p>
<ul>
<li>验证证书的合法性；</li>
<li>如果验证通过证书，浏览器会生成一串随机数<strong>密钥</strong>，并用证书中的公钥进行加密；</li>
<li>用约定好的 hash 算法计算握手消息，然后用生成的密钥进行加密，然后一起发送给服务器。</li>
</ul>
<p>4、服务器接收到客户端传送来的信息，要做下面的事情：</p>
<ul>
<li>4.1 用私钥解析出密钥，用密钥解析握手消息，验证 hash 值是否和浏览器发来的一致；</li>
<li>4.2 使用密钥加密消息；</li>
</ul>
<p>5、如果计算法 hash 值一致，握手成功。</p>
<h4 id="对称式加密"><a href="#对称式加密" class="headerlink" title="对称式加密"></a>对称式加密</h4><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p>
<ul>
<li>优点：运算速度快； </li>
<li>缺点：无法安全地将密钥传输给通信方。</li>
</ul>
<h4 id="非对称式加密"><a href="#非对称式加密" class="headerlink" title="非对称式加密"></a>非对称式加密</h4><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p>
<p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。 </p>
<p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此<strong>通信发送方使用其私有密钥进行签名</strong>，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p>
<ul>
<li>优点：可以更安全地将公开密钥传输给通信发送方； </li>
<li>缺点：运算速度慢</li>
</ul>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="DNS-的查询过程"><a href="#DNS-的查询过程" class="headerlink" title="DNS 的查询过程"></a>DNS 的查询过程</h3><p>首先通过 URL 找到主机名。比如 <a target="_blank" rel="noopener" href="http://www.baidu.com,**根据这个去浏览器缓存里面找,如果没有就去本机的/">www.baidu.com，**根据这个去浏览器缓存里面找，如果没有就去本机的</a> host 的文件找，在没有就去访问本地域名服务器<strong>，询问能不能找到这个主机 IP 地址的缓存。 再没有就通过迭代的方法，找</strong>根域名服务器，顶级、权威，最后返回一个 ip 地址给 DNS 应用**。 当发送一个 DNS 请求的时候，如果本地域名服务器中没有的话，本地域名服务器就会代理的作用将请求转发到 DNS 服务器层次结构中。</p>
<h3 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h3><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220330100416720.png" alt="image-20220330100416720"></p>
<p>至此我们的讨论一直忽略了 DNS系统 的一个非常重要特色：DNS缓存(DNS caching) o实际上，为了改善时延性能并减 少在因特网上到处传输的DNS报文数量， DNS广泛使用了缓存技术。DNS缓存的原 理非常简单。在一个请求链中，当某DNS 服务器接收一个DNS回答(例如，包含某 主机名到IP地址的映射)时，它能将映射 缓存在本地存储器中。例如，在图2・18 中，每当本地DNS服务器dns. nyu. edu从 某个DNS服务器接收到一个回答，它能够 缓存包含在该回答中的任何信息。如果在 DNS服务器中缓存了一台主机名&#x2F;IP地址 对，另一个对相同主机名的查询到达该 DNS服务器时，该DNS服务器就能够提供 所要求的IP地址，即使它不是该主机名的权威服务器。由于主机和主机名与IP地址间的映射并不是永久的，DNS服务器在一段时间后(通常设置为两天)将丢弃缓存的信息。</p>
<p>举一个例子，假定主机apricot, nyu. edu向dns. nyu. edu查询主机名cnn. com的IP地址。 此后，假定过了几个小时，纽约大学的另外一台主机如kiwi. nyu. edu也向dns. nyu. edu查询 相同的主机名。因为有了缓存，该本地DNS服务器可以立即返回cnn. com的IP地址，而不 必查询任何其他DNS服务器。本地DNS服务器也能够缓存TLD服务器的IP地址，因而允 许本地DNS绕过查询链中的根DNS服务器。事实上，因为缓存，除了少数DNS查询以外，根服务器被绕过了。</p>
<p>http 请求都有哪些？</p>
<ul>
<li>GET 获取资源，服务端返回报文实体主体部分。  </li>
<li>HEAD 与 GET 类似，但是服务端不返回报文实体主体部分。 </li>
<li>POST 传输实体主体 </li>
<li>PUT 上传文件，存在安全性问题，一般不建议使用 </li>
<li>PATCH 对资源进行部分修改 </li>
<li>DELETE 删除文件，与 PUT 功能相反，并且同样不带验证机制 </li>
<li>OPTIONS 查询指定的 URL 能够支持的方法，会返回 Allow：GET，POST，HEAD 这样的内容。 </li>
<li>CONNECT 要求在与代理服务器通信时建立隧道 </li>
<li>TRACE 追踪路径，服务器会将通信路径返回给客户端，通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）</li>
</ul>
<h1 id="运输层协议"><a href="#运输层协议" class="headerlink" title="运输层协议"></a>运输层协议</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><h4 id="三次握手的概念"><a href="#三次握手的概念" class="headerlink" title="三次握手的概念"></a>三次握手的概念</h4><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220329083907417.png" alt="image-20220329083907417"></p>
<p> 刚开始客户端处于 closed 的状态，服务端处于 listen 状态。然后<br>   1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN（c）。此时客户端处于 SYN_Send 状态。</p>
<p>   2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</p>
<p>   3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。</p>
<p>   4、服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。</p>
<h4 id="三次握手作用"><a href="#三次握手作用" class="headerlink" title="三次握手作用"></a>三次握手作用</h4><p> 1、确认双方的接受能力、发送能力是否正常。<br> 2、指定自己的初始化序列号，为后面的可靠传送做准备。<br> 3、如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。</p>
<h4 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h4><ul>
<li>当进行第一次握手，网络不好可能会堵塞，所以连接的请求并没有到达服务器端；</li>
<li>但是tcp连接有超时重传的机制，所以再一次发送请求，这时候服务器端接收到了你的请求，他也会返回一个请求给你，这是第二次握手；</li>
<li>但是这时候网络环境突然又好了起来，那个堵塞的请求到达了服务器端，服务器端又给你回了一个请求，但是你又不想给服务器发送请求，这时候服务器的资源会进行占用等待你的请求，为了不使服务器的资源继续占用，你又必须发送一个请求给服务器；所以要进行3次握手</li>
</ul>
<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220329085636059.png" alt="image-20220329085636059"></p>
<p>1、第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。</p>
<p>2、第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。</p>
<p>3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</p>
<p>4、第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</p>
<p>5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p>
<h4 id="为什么最后还要等待TIME-WAIT"><a href="#为什么最后还要等待TIME-WAIT" class="headerlink" title="为什么最后还要等待TIME_WAIT"></a>为什么最后还要等待TIME_WAIT</h4><p>  这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。<br>  至于 TIME_WAIT 持续的时间至少是一个报文的来回时间，即2MSL(Maximum Segment  Lifetime)。MSL 指一个片段在网络中最大的存活时间，一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>  窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP  确认报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗 口大小，从而控制发送速率。</p>
<p>   发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且 已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。 </p>
<p>  接收方只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节序号为 {31,   34, 35}，其中 {31}按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个 字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220329093110364.png" alt="image-20220329093110364"></p>
<p>  TCP 链接的每一侧主机都为该 TCP 链接设置了接收缓存。当 TCP 链接收到正确、按续的字节后，它就将数据放入接收缓存。相关联的应用进程就会从该缓存中读取数据，不是数据一道道就立 马读取数据。当发送送方发的太快了，太多了，很容易使接收方缓存溢出。这个时候就需要流量控制来解决。他是一个速度匹配的服务。</p>
<p>  TCP通过让发送方维护一个称为接收窗口(receive window)的变量来提供流量控制，接收窗口用于给发送方一个指示一一该接收方还有多少可用的缓存空间。因为 TCP是全双工通信，在连接两端的发送方都各自维护一个接收窗口。主机B通过把当前的rwnd值放入它发给主机A的报文段接收窗口字段中，通知主机A它在该连接的缓存中还有多少可用空间。当主机B的接收窗口为0时，主机A继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认。最终缓存将开始清空，并且确认报文里将包含一个非0的rwnd 值。</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>  TCP 主要通过四个算法来进行拥塞控制：<strong>慢开始、拥塞避免、快重传、快恢复。</strong> 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞 窗口只是一状态变量，实际决定发送方能发送多少数据的是发送方窗口</p>
<p>为了便于讨论，做如下假设： </p>
<ul>
<li>接收方有足够大的接收缓存，因此不会发生流量控制； </li>
<li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li>
</ul>
<p>​    <img src="http://r9wfwrw6c.hb-bkt.clouddn.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220329094335339.png" alt="image-20220329094335339"></p>
<h4 id="慢开始与拥塞避免"><a href="#慢开始与拥塞避免" class="headerlink" title="慢开始与拥塞避免"></a>慢开始与拥塞避免</h4><p>  发送的最初执行慢开始，令 cwnd &#x3D; 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … </p>
<p>  注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的 速度增长速度过快，网络拥塞的可能性也就更高。<strong>设置一个慢开始门限 ssthresh，当 cwnd &gt;&#x3D; ssthresh  时，进入拥塞避免，每个轮次只将 cwnd 加 1。</strong></p>
<p>  如果出现了超时（即发送方没有接收到接收方传过来的确认报文），则令 <strong>ssthresh &#x3D; cwnd &#x2F; 2</strong>，然后 重新执行慢开始。 </p>
<p>  注意：拥塞避免并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增 长，使网络比较不容易出现拥塞。</p>
<h4 id="快重传与快恢复"><a href="#快重传与快恢复" class="headerlink" title="快重传与快恢复"></a>快重传与快恢复</h4><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220329100939294.png" alt="image-20220329100939294"></p>
<p>  所谓快重传，就是使发送方尽早知道发生了个别报文段丢失，尽快重传，而不是等待重传计时器超 时再重传。</p>
<p>   在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认（所以才会有了下边连续 3 次重复确认 M2）。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确 认。 </p>
<p>  在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 <strong>cwnd &#x3D;ssthresh &#x3D; cwnd  &#x2F; 2</strong> ，注意到此时直接进入拥塞避免。 </p>
<p>  <strong>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1， 而快恢复 cwnd 设定为 ssthresh。</strong></p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220329101247891.png" alt="image-20220329101247891"></p>
<h3 id="TCP报文头格式"><a href="#TCP报文头格式" class="headerlink" title="TCP报文头格式"></a>TCP报文头格式</h3><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220329115402388.png" alt="image-20220329115402388"></p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220314105352113.png" alt="image-20220314105352113"></p>
<p><strong>序号</strong>：TCP 的序号是数据流中的字节数，不是分组的序号。表示该报文段数据字段首字节的序号。</p>
<p> <strong>确认号</strong>：TCP 使用累积确认，确认号是第一个未收到的字节序号，表示希望接收到的下一个字节。</p>
<p> <strong>首部长度</strong>：通常选项字段为空，所以一般 TCP 首部的长度是 <strong>20</strong> <strong>字节</strong>。</p>
<p> <strong>选项字段</strong>(可选与变长的)：用于发送方与接收方协商 MSS(最大报文段长)，或在高速网络环境下用作窗口</p>
<p>调节因子。</p>
<p> <strong>标志字段</strong></p>
<p> <strong>ACK</strong>：指示确认字段中的值是有效的</p>
<p> <strong>RST,SYN,FIN</strong>：连接建立与拆除</p>
<p> <strong>PSH</strong>：指示接收方应立即将数据交给上层</p>
<p> <strong>URG</strong>：报文段中存在着(被发送方的上层实体置位)“紧急”的数据</p>
<p> <strong>接收窗口</strong>：用于流量控制（表示接收方还有多少可用的缓存空间）。</p>
<p> TCP RFC 并没有规定失序到达的分组应该如何处理，而是交给程序员。可以选择丢弃或保留。如果发生超时，TCP <strong>只重传第一个已发送而未确认的分组</strong>，超时时间间隔会设置为原来的</p>
<h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220329120555130.png" alt="image-20220329120555130"></p>
<p>  UDP 在传送数据之前不需要先建立连接（无连接），远地主机在收到 UDP 报文后，不需要给出任 何确认。一般用于即时通信，因为偶尔丢失包也没有影响，比如： QQ 语音、 QQ 视频 、直播等 等。</p>
<p>  TCP 不提供广播或多播服务。</p>
<p>  TCP 要提供可靠的，面向连接的运输服务（TCP 的面向连接体现在 TCP 在传递数据之前，会有三 次握手来建立连接，在数据传完后，会断开连接用来节约系统资源，可靠性体现在数据传递时，有 JIANG J Q: 699046690 报文确认、滑动窗口、超时重传、拥塞控制机制），这一系列操作增加了许多开销。这不仅使 TCP 首部增大很多，还要占用许多处理机资源。TCP 一般用于需要可靠传输的场景，比如：文件传输、 发送邮件、远程登录（包括了文件传输）等场景。</p>
<p> 总的来说： </p>
<ol>
<li>TCP 面向连接，UDP 无连接。 </li>
<li>TCP 可靠传输，UDP 不可靠传输。 </li>
<li>TCP 传输慢，UDP 传输快。 </li>
<li>TCP 所需资源多（比如：超时重传功能需要先缓存已发送的数据），UDP 所需资源少。 </li>
<li>TCP 首部字节多（因为有 ACK，SYN，FIN 等字段以及滑动窗口等），UPD 首部字节少。</li>
</ol>
<h3 id="TCP粘包和拆包"><a href="#TCP粘包和拆包" class="headerlink" title="TCP粘包和拆包"></a>TCP粘包和拆包</h3><p>由于TCP传输协议面向流的，<strong>没有消息保护边界</strong>。一方发送的多个报文可能会被合并成一个大的报文进行传输，这就是粘包；也可能发送的一个报文，可能会被拆分成多个小报文，这就是拆包。</p>
<p>发生TCP粘包、拆包主要是以下原因：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）应用程序写入数据大于套接字缓冲区大小，会发生拆包；</span><br><span class="line">（2）应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发送粘包；</span><br><span class="line">（3）进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度——TCP header长度&gt;MSS  的时候会发生拆包；</span><br><span class="line">（4）接收方法不及时读取套接字缓冲区数据，这将发生粘包。</span><br></pre></td></tr></table></figure>

<p> <strong>UDP会不会产生粘包问题呢？</strong></p>
<p> TCP为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的（保护消息边界：指传输协议把数据当做一条独立的消息在网上传输，接收端一次只能接受一条独立的消息）。UDP则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。</p>
<p> 举个例子：有三个数据包，大小分别为2k、4k、6k，如果采用UDP发送的话，不管接受方的接收缓存有多大，我们必须要进行至少三次以上的发送才能把数据包发送完，但是使用TCP协议发送的话，我们只需要接受方的接收缓存有12k的大小，就可以一次把这3个数据包全部发送完毕。</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220324202652206.png" alt="image-20220324202652206"></p>
<h3 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h3><ol>
<li><p>应用数据被分割成 TCP 认为最适合发送的数据块。</p>
</li>
<li><p>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</p>
</li>
<li><p><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p>
</li>
<li><p>TCP 的接收端会丢弃重复的数据。</p>
</li>
<li><p><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</p>
<p>在连接双方都维护一个接收窗口，主机B为该连接分配了一个接收缓存，用RcvBuffer表示大小，rwnd&#x3D;RcvBuffer-LastByteRcvd+LastbyteRead</p>
<p>，主机B把当前rwnd放到发给主机A的报文段接收窗口中，通知主机A该连接缓存还有多少空间，将未确认的数量控制在rwnd以内就可以保证主机A不会使主机B的接收缓存溢出。</p>
</li>
<li><p><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<ul>
<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li>
<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送放的 cwnd 加 1.</li>
<li><strong>快重传与快恢复：</strong> 在 TCP&#x2F;IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>
</ul>
</li>
<li><p><strong>ARQ 协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p>
</li>
<li><p><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段</p>
</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="TCP和UDP有如下区别："><a href="#TCP和UDP有如下区别：" class="headerlink" title="TCP和UDP有如下区别："></a>TCP和UDP有如下区别：</h3><ol>
<li>连接：TCP面向连接的传输层协议，即传输数据之前必须先建立好连接；UDP无连接。</li>
<li>服务对象：TCP点对点的两点间服务，即一条TCP连接只能有两个端点；UDP支持一对一，一对多，多对一，多对多的交互通信。</li>
<li>可靠性：TCP可靠交付：无差错，不丢失，不重复，按序到达；UDP尽最大努力交付，不保证可靠交付。</li>
<li>拥塞控制&#x2F;流量控制：有拥塞控制和流量控制保证数据传输的安全性；UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。</li>
<li>报文长度：TCP动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的；UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。</li>
<li>首部开销：TCP首部开销大，首部20个字节；UDP首部开销小，8字节（源端口，目的端口，数据长度，校验和）。</li>
<li>适用场景（由特性决定）：数据完整性需让位于通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。</li>
</ol>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/tcp-vs-udp.jpg" alt="TCP、UDP协议的区别"></p>
<h3 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议"></a>ARQ 协议</h3><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p>
<h4 id="停止等待-ARQ-协议"><a href="#停止等待-ARQ-协议" class="headerlink" title="#停止等待 ARQ 协议"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/other-network-questions.html#%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85-arq-%E5%8D%8F%E8%AE%AE">#</a>停止等待 ARQ 协议</h4><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。</p>
<p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h3 id="IPv4数据报格式"><a href="#IPv4数据报格式" class="headerlink" title="IPv4数据报格式"></a>IPv4数据报格式</h3><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220313162307775.png" alt="image-20220313162307775"></p>
<ul>
<li>4比特版本号</li>
<li>4比特首部长度</li>
<li>8比特服务类型</li>
<li>16比特数据报长度</li>
<li>16比特标识、4比特标志、12比特片偏移</li>
<li>8比特寿命</li>
<li>8比特协议</li>
<li>16比特首部检验和</li>
<li>32比特源和32比特目的IP地址</li>
<li>选项</li>
<li>数据（有效载荷）</li>
</ul>
<h3 id="IPv4数据报分片-标识、标志、偏移量"><a href="#IPv4数据报分片-标识、标志、偏移量" class="headerlink" title="IPv4数据报分片(标识、标志、偏移量)"></a>IPv4数据报分片(标识、标志、偏移量)</h3><p>发送主机在为数据报设置源和目标地址的同时贴上标识号，发送主机通常将它发送的每个数据报的标识号加1，当分片时，片具有初始数据报的源地址、目的地址和标识号。</p>
<p>最后一个分片标志比特被设为了0，其他片标志比特被设为1,使用偏移字段指定该片在数据报的哪个位置。</p>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="打开一个网页，整个过程会使用哪些协议（过程有-6-个）"><a href="#打开一个网页，整个过程会使用哪些协议（过程有-6-个）" class="headerlink" title="打开一个网页，整个过程会使用哪些协议（过程有 6 个）"></a>打开一个网页，整个过程会使用哪些协议（过程有 6 个）</h2><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20220330100701382.png" alt="image-20220330100701382"></p>
<p>总体来说分为以下几个过程: </p>
<ol>
<li>DNS 解析 </li>
<li>TCP 连接 </li>
<li>SSL 握手 </li>
<li>发送 HTTP 请求 </li>
<li>服务器处理请求并返回 HTTP 报文 </li>
<li>浏览器解析渲染页面 </li>
<li>连接结束</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-06 15:16:01 / 修改时间：15:21:55" itemprop="dateCreated datePublished" datetime="2022-04-06T15:16:01+08:00">2022-04-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-1-什么是操作系统？"><a href="#1-1-什么是操作系统？" class="headerlink" title="1.1 什么是操作系统？"></a>1.1 什么是操作系统？</h3><p>👨‍💻<strong>面试官</strong> ： 先来个简单问题吧！<strong>什么是操作系统？</strong></p>
<p>🙋 <strong>我</strong> ：我通过以下四点向您介绍一下什么是操作系统吧！</p>
<ol>
<li><strong>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</strong></li>
<li><strong>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</strong> 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</li>
<li><strong>操作系统存在屏蔽了硬件层的复杂性。</strong> 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li>
<li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li>
</ol>
<h3 id="1-2-系统调用"><a href="#1-2-系统调用" class="headerlink" title="1.2 系统调用"></a>1.2 系统调用</h3><p>👨‍💻<strong>面试官</strong> ：<strong>什么是系统调用呢？</strong> 能不能详细介绍一下。</p>
<p>🙋 <strong>我</strong> ：介绍系统调用之前，我们先来了解一下用户态和系统态。</p>
<p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>
<ol>
<li>用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据，在用户态下运行的代码会受到限制。</li>
<li>系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>
</ol>
<p>说了用户态和系统态之后，那么什么是系统调用呢？</p>
<p>我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！要执行系统调用，程序必须执行特殊的陷阱（trap）指令，该指令同时跳入内核并将特权级别提升到内核模式。</p>
<p>也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>
<p>这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
<h2 id="二-进程和线程"><a href="#二-进程和线程" class="headerlink" title="#二 进程和线程"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E4%BA%8C-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B">#</a>二 进程和线程</h2><h3 id="2-1-进程和线程的区别"><a href="#2-1-进程和线程的区别" class="headerlink" title="#2.1 进程和线程的区别"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_2-1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB">#</a>2.1 进程和线程的区别</h3><p>👨‍💻<strong>面试官</strong>: 好的！我明白了！那你再说一下： <strong>进程和线程的区别</strong>。</p>
<p>🙋 <strong>我：</strong> 好的！ 下图是 Java 内存区域，我们从 JVM 的角度来说一下线程和进程之间的关系吧！</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-cd8ac705f6f004c01e0a1312f1599430ba5.png" alt="img"></p>
<p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)**资源，但是每个线程有自己的**程序计数器**、</strong>虚拟机栈** 和 <strong>本地方法栈</strong>。</p>
<p><strong>总结：</strong> 线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。进程：系统进行资源调度和分配的基本单位，进程间独享内存，一个系统至少一个进程；线程。cpu进行资源调度和分配的基本单位，线程间共享进程的内存，一个进程至少一个线程，线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>
<h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p>是一种<strong>用户态的轻量级线程</strong>、协程的调度完全由用户控制。协程拥有自己的寄存器上下文和 栈。协程调度切换时，将寄存器上下文和栈栈保存到其他地方，在切换回来的时候，回复先前保存 的寄存器上下文和栈，没有内核切换开销所以非常快。</p>
<h3 id="2-2-进程有哪几种状态"><a href="#2-2-进程有哪几种状态" class="headerlink" title="#2.2 进程有哪几种状态?"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_2-2-%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81">#</a>2.2 进程有哪几种状态?</h3><p>👨‍💻<strong>面试官</strong> ： 那你再说说<strong>进程有哪几种状态?</strong></p>
<p>🙋 <strong>我</strong> ：我们一般把进程大致分为 5 种状态，这一点和<a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/JavaConcurrencyBasicsCommonInterviewQuestionsSummary.md#6-%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81">线程open in new window</a>很像！</p>
<ul>
<li><strong>创建状态(new)</strong> ：进程正在被创建，尚未到就绪状态。</li>
<li><strong>就绪状态(ready)</strong> ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。</li>
<li><strong>运行状态(running)</strong> ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</li>
<li><strong>阻塞状态(waiting)</strong> ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li>
<li><strong>结束状态(terminated)</strong> ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li>
</ul>
<blockquote>
<p>订正：下图中 running 状态被 interrupt 向 ready 状态转换的箭头方向反了。</p>
</blockquote>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/d38202593012b457debbcd74994c6292.png" alt="process-state"></p>
<h3 id="2-3-进程间的通信方式"><a href="#2-3-进程间的通信方式" class="headerlink" title="#2.3 进程间的通信方式"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_2-3-%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">#</a>2.3 进程间的通信方式</h3><p>👨‍💻<strong>面试官</strong> ：<strong>进程间的通信常见的的有哪几种方式呢?</strong></p>
<p>🙋 <strong>我</strong> ：大概有 7 种常见的进程间的通信方式。</p>
<blockquote>
<p>下面这部分总结参考了:<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c1015f5ffa74">《进程间通信 IPC (InterProcess Communication)》open in new window</a> 这篇文章，推荐阅读，总结的非常不错。</p>
</blockquote>
<ol>
<li><strong>管道&#x2F;匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。                                                                                                                  管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。 当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</li>
<li><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li>
<li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li>
<li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。</strong></li>
<li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li>
<li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li>
<li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP&#x2F;IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li>
</ol>
<h3 id="2-4-线程间的同步的方式"><a href="#2-4-线程间的同步的方式" class="headerlink" title="#2.4 线程间的同步的方式"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_2-4-%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F">#</a>2.4 线程间的同步的方式</h3><p>👨‍💻<strong>面试官</strong> ：<strong>那线程间的同步的方式有哪些呢?</strong></p>
<p>🙋 <strong>我</strong> ：线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：</p>
<ol>
<li>**互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li>
<li><strong>信号量(Semphares)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li>
<li><strong>事件(Event)</strong> :Wait&#x2F;Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>
</ol>
<h3 id="2-5-进程的调度算法"><a href="#2-5-进程的调度算法" class="headerlink" title="#2.5 进程的调度算法"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_2-5-%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">#</a>2.5 进程的调度算法</h3><p>👨‍💻<strong>面试官</strong> ：<strong>你知道操作系统中进程的调度算法有哪些吗?</strong></p>
<p>🙋 <strong>我</strong> ：嗯嗯！这个我们大学的时候学过，是一个很重要的知识点！</p>
<p>为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率，计算机科学家已经定义了一些算法，它们是：</p>
<ul>
<li><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>
<li><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。属于最高优先级类的进程运行一个时间片，属于次高优先级类的进程运行两个时间片，再次一级运行四个时间片，以此类推，多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li>
<li><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
</ul>
<h3 id="2-6-什么是死锁"><a href="#2-6-什么是死锁" class="headerlink" title="#2.6 什么是死锁"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_2-6-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81">#</a>2.6 什么是死锁</h3><p>👨‍💻<strong>面试官</strong> ：<strong>你知道什么是死锁吗?</strong></p>
<p>🙋 <strong>我</strong> ：多个进程可以竞争有限数量的资源。当一个进程申请资源时，如果这时没有可用资源，那么这个进程进入等待状态。有时，如果所申请的资源被其他等待进程占有，那么该等待进程有可能再也无法改变状态。这种情况称为 <strong>死锁</strong>。</p>
<h3 id="2-7-死锁的四个条件"><a href="#2-7-死锁的四个条件" class="headerlink" title="#2.7 死锁的四个条件"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_2-7-%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%9D%A1%E4%BB%B6">#</a>2.7 死锁的四个条件</h3><p>👨‍💻<strong>面试官</strong> ：<strong>产生死锁的四个必要条件是什么?</strong></p>
<p>🙋 <strong>我</strong> ：如果系统中以下四个条件同时成立，那么就能引起死锁：</p>
<ul>
<li><strong>互斥</strong>：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</li>
<li><strong>占有并等待</strong>：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</li>
<li><strong>非抢占</strong>：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li>
<li><strong>循环等待</strong>：有一组等待进程 <code>&#123;P0, P1,..., Pn&#125;</code>， <code>P0</code> 等待的资源被 <code>P1</code> 占有，<code>P1</code> 等待的资源被 <code>P2</code> 占有，……，<code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有，<code>Pn</code> 等待的资源被 <code>P0</code> 占有。</li>
</ul>
<p>注意，只有四个条件同时成立时，死锁才会出现。</p>
<h3 id="2-8-解决死锁的方法"><a href="#2-8-解决死锁的方法" class="headerlink" title="#2.8 解决死锁的方法"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_2-8-%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95">#</a>2.8 解决死锁的方法</h3><p>解决死锁的方法可以从多个角度去分析，一般的情况下，有<strong>预防，避免，检测和解除四种</strong>。</p>
<ul>
<li><strong>预防</strong> 是采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间上都不满足。</li>
<li><strong>避免</strong>则是系统在分配资源时，根据资源的使用情况<strong>提前做出预测</strong>，从而<strong>避免死锁的发生</strong></li>
<li><strong>检测</strong>是指系统设有<strong>专门的机构</strong>，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</li>
<li><strong>解除</strong> 是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong>。</li>
</ul>
<h4 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="#死锁的预防"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2">#</a>死锁的预防</h4><p>死锁四大必要条件上面都已经列出来了，很显然，只要破坏四个必要条件中的任何一个就能够预防死锁的发生。</p>
<p>破坏第一个条件 <strong>互斥条件</strong>：使得资源是可以同时访问的，这是种简单的方法，磁盘就可以用这种方法管理，但是我们要知道，有很多资源 <strong>往往是不能同时访问的</strong> ，所以这种做法在大多数的场合是行不通的。</p>
<p>破坏第三个条件 <strong>非抢占</strong> ：也就是说可以采用 <strong>剥夺式调度算法</strong>，但剥夺式调度方法目前一般仅适用于 <strong>主存资源</strong> 和 <strong>处理器资源</strong> 的分配，并不适用于所以的资源，会导致 <strong>资源利用率下降</strong>。</p>
<p>所以一般比较实用的 <strong>预防死锁的方法</strong>，是通过考虑破坏第二个条件和第四个条件。</p>
<p><strong>1、静态分配策略</strong></p>
<p>静态分配策略可以破坏死锁产生的第二个条件（占有并等待）。所谓静态分配策略，就是指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。进程要么占有所有的资源然后开始执行，要么不占有资源，不会出现占有一些资源等待一些资源的情况。</p>
<p>静态分配策略逻辑简单，实现也很容易，但这种策略 <strong>严重地降低了资源利用率</strong>，因为在每个进程所占有的资源中，有些资源是在比较靠后的执行时间里采用的，甚至有些资源是在额外的情况下才是用的，这样就可能造成了一个进程占有了一些 <strong>几乎不用的资源而使其他需要该资源的进程产生等待</strong> 的情况。</p>
<p><strong>2、层次分配策略</strong></p>
<p>层次分配策略破坏了产生死锁的第四个条件(循环等待)。在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略，证明略。</p>
<h4 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="#死锁的避免"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E6%AD%BB%E9%94%81%E7%9A%84%E9%81%BF%E5%85%8D">#</a>死锁的避免</h4><p>上面提到的 <strong>破坏</strong> 死锁产生的四个必要条件之一就可以成功 <strong>预防系统发生死锁</strong> ，但是会导致 <strong>低效的进程运行</strong> 和 <strong>资源使用率</strong> 。而死锁的避免相反，它的角度是允许系统中<strong>同时存在四个必要条件</strong> ，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出 <strong>明智和合理的选择</strong> ，仍然可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。</p>
<p>我们将系统的状态分为 <strong>安全状态</strong> 和 <strong>不安全状态</strong> ，每当在未申请者分配资源前先测试系统状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。</p>
<blockquote>
<p>如果操作系统能够保证所有的进程在有限的时间内得到需要的全部资源，则称系统处于安全状态，否则说系统是不安全的。很显然，系统处于安全状态则不会发生死锁，系统若处于不安全状态则可能发生死锁。</p>
</blockquote>
<p>那么如何保证系统保持在安全状态呢？通过算法，其中最具有代表性的 <strong>避免死锁算法</strong> 就是 Dijkstra 的银行家算法，银行家算法用一句话表达就是：当一个进程申请使用资源的时候，<strong>银行家算法</strong> 通过先 <strong>试探</strong> 分配给该进程资源，然后通过 <strong>安全性算法</strong> 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 <strong>真的分配资源给该进程</strong>。</p>
<p>银行家算法详情可见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33414271/article/details/80245715">《一句话+一张图说清楚——银行家算法》open in new window</a> 。</p>
<p>操作系统教程树中讲述的银行家算法也比较清晰，可以一看.</p>
<p>死锁的避免(银行家算法)改善解决了 <strong>资源使用率低的问题</strong> ，但是它要不断地检测每个进程对各类资源的占用和申请情况，以及做 <strong>安全性检查</strong> ，需要花费较多的时间。</p>
<h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="#死锁的检测"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B">#</a>死锁的检测</h4><p>对资源的分配加以限制可以 <strong>预防和避免</strong> 死锁的发生，但是都不利于各进程对系统资源的<strong>充分共享</strong>。解决死锁问题的另一条途径是 <strong>死锁检测和解除</strong> (这里突然联想到了乐观锁和悲观锁，感觉死锁的检测和解除就像是 <strong>乐观锁</strong> ，分配资源时不去提前管会不会发生死锁了，等到真的死锁出现了再来解决嘛，而 <strong>死锁的预防和避免</strong> 更像是悲观锁，总是觉得死锁会出现，所以在分配资源的时候就很谨慎)。</p>
<p>这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 <strong>定时地运行一个 “死锁检测”</strong> 的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。</p>
<h5 id="进程-资源分配图"><a href="#进程-资源分配图" class="headerlink" title="#进程-资源分配图"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E8%BF%9B%E7%A8%8B-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE">#</a>进程-资源分配图</h5><p>操作系统中的每一刻时刻的<strong>系统状态</strong>都可以用<strong>进程-资源分配图</strong>来表示，进程-资源分配图是描述进程和资源申请及分配关系的一种有向图，可用于<strong>检测系统是否处于死锁状态</strong>。</p>
<p>用一个方框表示每一个资源类，方框中的黑点表示该资源类中的各个资源，每个键进程用一个圆圈表示，用 <strong>有向边</strong> 来表示<strong>进程申请资源和资源被分配的情况</strong>。</p>
<p>图中 2-21 是<strong>进程-资源分配图</strong>的一个例子，其中共有三个资源类，每个进程的资源占有和申请情况已清楚地表示在图中。在这个例子中，由于存在 <strong>占有和等待资源的环路</strong> ，导致一组进程永远处于等待资源的状态，发生了 <strong>死锁</strong>。</p>
<p><img src="https://javaguide.cn/assets/%E8%BF%9B%E7%A8%8B-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.31e353df.jpg" alt="进程-资源分配图"></p>
<p>进程-资源分配图中存在环路并不一定是发生了死锁。因为循环等待资源仅仅是死锁发生的必要条件，而不是充分条件。图 2-22 便是一个有环路而无死锁的例子。虽然进程 P1 和进程 P3 分别占用了一个资源 R1 和一个资源 R2，并且因为等待另一个资源 R2 和另一个资源 R1 形成了环路，但进程 P2 和进程 P4 分别占有了一个资源 R1 和一个资源 R2，它们申请的资源得到了满足，在有限的时间里会归还资源，于是进程 P1 或 P3 都能获得另一个所需的资源，环路自动解除，系统也就不存在死锁状态了。</p>
<h5 id="死锁检测步骤"><a href="#死锁检测步骤" class="headerlink" title="#死锁检测步骤"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B%E6%AD%A5%E9%AA%A4">#</a>死锁检测步骤</h5><p>知道了死锁检测的原理，我们可以利用下列步骤编写一个 <strong>死锁检测</strong> 程序，检测系统是否产生了死锁。</p>
<ol>
<li>如果进程-资源分配图中无环路，则此时系统没有发生死锁</li>
<li>如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁。</li>
<li>如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁。如果能在进程-资源分配图中找出一个 <strong>既不阻塞又非独立的进程</strong> ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 <strong>消除所有的边</strong> ，则不会发生死锁，否则会发生死锁。(消除边的过程类似于 <strong>拓扑排序</strong>)</li>
</ol>
<h4 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="#死锁的解除"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E9%99%A4">#</a>死锁的解除</h4><p>当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁状态中恢复过来，常用的解除死锁的方法有以下四种：</p>
<ol>
<li><strong>立即结束所有进程的执行，重新启动操作系统</strong> ：这种方法简单，但以前所在的工作全部作废，损失很大。</li>
<li><strong>撤销涉及死锁的所有进程，解除死锁后继续运行</strong> ：这种方法能彻底打破<strong>死锁的循环等待</strong>条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。</li>
<li><strong>逐个撤销涉及死锁的进程，回收其资源直至死锁解除。</strong></li>
<li><strong>抢占资源</strong> ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。</li>
</ol>
<h3 id="2-9协程"><a href="#2-9协程" class="headerlink" title="2.9协程"></a>2.9协程</h3><p><strong>协程，英文Coroutines，是一种比线程更加轻量级的存在。</strong>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8D%8F%E7%A8%8B&spm=1001.2101.3001.7020">协程</a>。</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/6765e36cc4604fba897976638af03524.jpeg" alt="img"></p>
<p>最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。</p>
<p>这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>
<h2 id="三-操作系统内存管理基础"><a href="#三-操作系统内存管理基础" class="headerlink" title="#三 操作系统内存管理基础"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E4%B8%89-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80">#</a>三 操作系统内存管理基础</h2><h3 id="3-1-内存管理介绍"><a href="#3-1-内存管理介绍" class="headerlink" title="#3.1 内存管理介绍"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_3-1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BB%8B%E7%BB%8D">#</a>3.1 内存管理介绍</h3><p>👨‍💻 <strong>面试官</strong>: <strong>操作系统的内存管理主要是做什么？</strong></p>
<p>🙋 <strong>我：</strong> 操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。</p>
<h3 id="3-2-常见的几种内存管理机制"><a href="#3-2-常见的几种内存管理机制" class="headerlink" title="#3.2 常见的几种内存管理机制"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_3-2-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6">#</a>3.2 常见的几种内存管理机制</h3><p>👨‍💻 <strong>面试官</strong>: <strong>操作系统的内存管理机制了解吗？内存管理有哪几种方式?</strong></p>
<p>🙋 <strong>我：</strong> 这个在学习操作系统的时候有了解过。</p>
<p>简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 <strong>块式管理</strong> 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如<strong>页式管理</strong> 和 <strong>段式管理</strong>。</p>
<ol>
<li><strong>块式管理</strong> ： 远古时代的计算机操作系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</li>
<li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</li>
<li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</li>
</ol>
<p>简单来说：页是物理单位，段是逻辑单位。分页可以有效提高内存利用率，分段可以更好满足用户需求。</p>
<p>👨‍💻<strong>面试官</strong> ： 回答的还不错！不过漏掉了一个很重要的 <strong>段页式管理机制</strong> 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部的都是离散的。</p>
<p>🙋 <strong>我</strong> ：谢谢面试官！刚刚把这个给忘记了～</p>
<h3 id="3-3-快表和多级页表"><a href="#3-3-快表和多级页表" class="headerlink" title="#3.3 快表和多级页表"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_3-3-%E5%BF%AB%E8%A1%A8%E5%92%8C%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8">#</a>3.3 快表和多级页表</h3><p>👨‍💻<strong>面试官</strong> ： 页表管理机制中有两个很重要的概念：快表和多级页表，这两个东西分别解决了页表管理中很重要的两个问题。你给我简单介绍一下吧！</p>
<p>🙋 <strong>我</strong> ：在分页内存管理中，很重要的两点是：</p>
<ol>
<li>虚拟地址到物理地址的转换要快。</li>
<li>解决虚拟地址空间大，页表也会很大的问题。</li>
</ol>
<h4 id="快表"><a href="#快表" class="headerlink" title="#快表"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E5%BF%AB%E8%A1%A8">#</a>快表</h4><p>为了解决虚拟地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>快表</strong> 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容（虚拟页号，页面的修改位，修改位，保护位，页框号）。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p>
<p>使用快表之后的地址转换流程是这样的：</p>
<ol>
<li>根据虚拟地址中的页号查快表；</li>
<li>如果该页在快表中，直接从快表中读取相应的物理地址；</li>
<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li>
<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li>
</ol>
<p>看完了之后你会发现快表和我们平时经常在我们开发的系统使用的缓存（比如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。</p>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="#多级页表"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8">#</a>多级页表</h4><p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景，具体可以查看下面这篇文章</p>
<ul>
<li>多级页表如何节约内存：<a target="_blank" rel="noopener" href="https://www.polarxiong.com/archives/%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%A6%82%E4%BD%95%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98.html">https://www.polarxiong.com/archives/多级页表如何节约内存.htmlopen in new window</a></li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="#总结"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E6%80%BB%E7%BB%93">#</a>总结</h4><p>为了提高内存的空间性能，提出了多级页表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表（即 TLB）的概念。 不论是快表还是多级页表实际上都利用到了<strong>程序的局部性原理</strong>，局部性原理在后面的虚拟内存这部分会介绍到。</p>
<h3 id="3-4-分页机制和分段机制的共同点和区别"><a href="#3-4-分页机制和分段机制的共同点和区别" class="headerlink" title="#3.4 分页机制和分段机制的共同点和区别"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_3-4-%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E5%92%8C%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB">#</a>3.4 分页机制和分段机制的共同点和区别</h3><p>👨‍💻<strong>面试官</strong> ： <strong>分页机制和分段机制有哪些共同点和区别呢？</strong></p>
<p>🙋 <strong>我</strong> ：</p>
<ol>
<li><p>共同点</p>
<p>：</p>
<ul>
<li>分页机制和分段机制都是为了提高内存利用率，减少内存碎片。</li>
<li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li>
</ul>
</li>
<li><p>区别</p>
<p>：</p>
<ul>
<li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li>
<li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li>
</ul>
</li>
</ol>
<h3 id="3-5-逻辑-虚拟-地址和物理地址"><a href="#3-5-逻辑-虚拟-地址和物理地址" class="headerlink" title="#3.5 逻辑(虚拟)地址和物理地址"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_3-5-%E9%80%BB%E8%BE%91-%E8%99%9A%E6%8B%9F-%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80">#</a>3.5 逻辑(虚拟)地址和物理地址</h3><p>👨‍💻<strong>面试官</strong> ：你刚刚还提到了<strong>逻辑地址和物理地址</strong>这两个概念，我不太清楚，你能为我解释一下不？</p>
<p>🙋 <strong>我：</strong> em…好的嘛！我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。</p>
<h3 id="3-6-CPU-寻址了解吗-为什么需要虚拟地址空间"><a href="#3-6-CPU-寻址了解吗-为什么需要虚拟地址空间" class="headerlink" title="#3.6 CPU 寻址了解吗?为什么需要虚拟地址空间?"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_3-6-cpu-%E5%AF%BB%E5%9D%80%E4%BA%86%E8%A7%A3%E5%90%97-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4">#</a>3.6 CPU 寻址了解吗?为什么需要虚拟地址空间?</h3><p>👨‍💻<strong>面试官</strong> ：<strong>CPU 寻址了解吗?为什么需要虚拟地址空间?</strong></p>
<p>🙋 <strong>我</strong> ：这部分我真不清楚！</p>
<p>于是面试完之后我默默去查阅了相关文档！留下了没有技术的泪水。。。</p>
<blockquote>
<p>这部分内容参考了 Microsoft 官网的介绍，地址：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/virtual-address-spaces?redirectedfrom=MSDN">https://docs.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/virtual-address-spaces?redirectedfrom=MSDNopen in new window</a></p>
</blockquote>
<p>现代处理器使用的是一种称为 <strong>虚拟寻址(Virtual Addressing)</strong> 的寻址方式。<strong>使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。</strong> 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 <strong>内存管理单元（Memory Management Unit, MMU）</strong> 的硬件。如下图所示：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/2b27dac8cc647f8aac989da2d1166db2.png" alt="MMU_principle_updated"></p>
<p><strong>为什么要有虚拟地址空间呢？</strong></p>
<p>先从没有虚拟地址空间的时候说起吧！没有虚拟地址空间的时候，<strong>程序都是直接访问和操作的都是物理内存</strong> 。但是这样有什么问题呢？</p>
<ol>
<li>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。</li>
<li>想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。</li>
</ol>
<p><strong>总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。</strong></p>
<p>通过虚拟地址访问内存有以下优势：</p>
<ul>
<li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。</li>
<li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</li>
<li>不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li>
</ul>
<h2 id="四-虚拟内存"><a href="#四-虚拟内存" class="headerlink" title="#四 虚拟内存"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E5%9B%9B-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">#</a>四 虚拟内存</h2><h3 id="4-1-什么是虚拟内存-Virtual-Memory"><a href="#4-1-什么是虚拟内存-Virtual-Memory" class="headerlink" title="#4.1 什么是虚拟内存(Virtual Memory)?"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_4-1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98-virtual-memory">#</a>4.1 什么是虚拟内存(Virtual Memory)?</h3><p>👨‍💻<strong>面试官</strong> ：再问你一个常识性的问题！<strong>什么是虚拟内存(Virtual Memory)?</strong></p>
<p>🙋 <strong>我</strong> ：这个在我们平时使用电脑特别是 Windows 系统的时候太常见了。很多时候我们使用点开了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。<strong>为什么可以这样呢？</strong> 正是因为 <strong>虚拟内存</strong> 的存在，通过 <strong>虚拟内存</strong> 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，<strong>虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）</strong>。这样会更加有效地管理内存并减少出错。</p>
<p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。<strong>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间</strong>，并且 <strong>把内存扩展到硬盘空间</strong>。推荐阅读：<a target="_blank" rel="noopener" href="https://juejin.im/post/59f8691b51882534af254317">《虚拟内存的那点事儿》open in new window</a></p>
<p>维基百科中有几句话是这样介绍虚拟内存的。</p>
<blockquote>
<p><strong>虚拟内存</strong> 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。From:<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">https://zh.wikipedia.org/wiki/虚拟内存open in new window</a></p>
</blockquote>
<h3 id="4-2-局部性原理"><a href="#4-2-局部性原理" class="headerlink" title="#4.2 局部性原理"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_4-2-%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86">#</a>4.2 局部性原理</h3><p>👨‍💻<strong>面试官</strong> ：要想更好地理解虚拟内存技术，必须要知道计算机中著名的<strong>局部性原理</strong>。另外，局部性原理既适用于程序结构，也适用于数据结构，是非常重要的一个概念。</p>
<p>🙋 <strong>我</strong> ：局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。</p>
<blockquote>
<p>以下内容摘自《计算机操作系统教程》 第 4 章存储器管理。</p>
</blockquote>
<p>早在 1968 年的时候，就有人指出我们的程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。</p>
<p>局部性原理表现在以下两个方面：</p>
<ol>
<li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li>
<li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>
</ol>
<p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p>
<h3 id="4-3-虚拟存储器"><a href="#4-3-虚拟存储器" class="headerlink" title="#4.3 虚拟存储器"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_4-3-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8">#</a>4.3 虚拟存储器</h3><blockquote>
<p><strong>勘误：虚拟存储器又叫做虚拟内存，都是 Virtual Memory 的翻译，属于同一个概念。</strong></p>
</blockquote>
<p>👨‍💻<strong>面试官</strong> ：都说了虚拟内存了。你再讲讲<strong>虚拟存储器</strong>把！</p>
<p>🙋 <strong>我</strong> ：</p>
<blockquote>
<p>这部分内容来自：<a target="_blank" rel="noopener" href="https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/13.html">王道考研操作系统知识点整理open in new window</a>。</p>
</blockquote>
<p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大的多的存储器——<strong>虚拟存储器</strong>。</p>
<p>实际上，我觉得虚拟内存同样是一种时间换空间的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。不得不感叹，程序世界几乎不是时间换空间就是空间换时间。</p>
<h3 id="4-4-虚拟内存的技术实现"><a href="#4-4-虚拟内存的技术实现" class="headerlink" title="#4.4 虚拟内存的技术实现"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_4-4-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0">#</a>4.4 虚拟内存的技术实现</h3><p>👨‍💻<strong>面试官</strong> ：<strong>虚拟内存技术的实现呢？</strong></p>
<p>🙋 <strong>我</strong> ：<strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</strong> 虚拟内存的实现有以下三种方式：</p>
<ol>
<li><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li>
<li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li>
<li><strong>请求段页式存储管理</strong></li>
</ol>
<p><strong>这里多说一下？很多人容易搞混请求分页与分页存储管理，两者有何不同呢？</strong></p>
<p>请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。</p>
<p>它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。</p>
<p>不管是上面那种实现方式，我们一般都需要：</p>
<ol>
<li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li>
<li><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</li>
<li><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换。</li>
</ol>
<h3 id="4-5-页面置换算法"><a href="#4-5-页面置换算法" class="headerlink" title="#4.5 页面置换算法"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#_4-5-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95">#</a>4.5 页面置换算法</h3><p>👨‍💻<strong>面试官</strong> ：虚拟内存管理很重要的一个概念就是页面置换算法。那你说一下 <strong>页面置换算法的作用?常见的页面置换算法有哪些?</strong></p>
<p>🙋 <strong>我</strong> ：</p>
<blockquote>
<p>这个题目经常作为笔试题出现，网上已经给出了很不错的回答，我这里只是总结整理了一下。</p>
</blockquote>
<p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。</p>
<blockquote>
<p><strong>缺页中断</strong> 就是要访问的<strong>页</strong>不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p>
</blockquote>
<p>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。</p>
<p>相同例子：服务器可以把经常访问的一些Web页面存在存储器的高速缓存中。</p>
<ul>
<li><p><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</p>
</li>
<li><p><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</p>
</li>
<li><p><strong>LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。数据结构双重链表加哈希表。</p>
</li>
<li><p><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法选择在之前时期使用最少的页面作为淘汰页</p>
</li>
<li><p>第二次机会算法FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：<br>当页面被访问 (读或写) 时设置该页面的 R 位为 1。当内存不足，需要页面替换的时候，检查链表中最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p>
</li>
</ul>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20220325110754388.png" alt="image-20220325110754388"></p>
<ul>
<li>第二次机会算需要在链表中移动页面，降低了效率。时钟算法使用和日使用一个指针指向最老的页面。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/06/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/Spring/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-06 15:16:01" itemprop="dateCreated datePublished" datetime="2022-04-06T15:16:01+08:00">2022-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-21 15:42:33" itemprop="dateModified" datetime="2022-03-21T15:42:33+08:00">2022-03-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="谈谈自己对于-Spring-IoC-的了解"><a href="#谈谈自己对于-Spring-IoC-的了解" class="headerlink" title="谈谈自己对于 Spring IoC 的了解"></a>谈谈自己对于 Spring IoC 的了解</h3><p><strong>IoC（Inverse of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p>
<p><strong>为什么叫控制反转？</strong></p>
<ul>
<li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li>
<li><strong>反转</strong> ：控制权交给外部环境（Spring 框架、IoC 容器）</li>
</ul>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/frc-365faceb5697f04f31399937c059c162.png" alt="img"></p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何被创建出来的。</p>
<p>在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p>
<p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p>
<h3 id="谈谈自己对于-AOP-的了解"><a href="#谈谈自己对于-AOP-的了解" class="headerlink" title="谈谈自己对于 AOP 的了解"></a>谈谈自己对于 AOP 的了解</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/926dfc549b06d280a37397f9fd49bf9d.jpg" alt="SpringAOPProcess"></p>
<p>当然你也可以使用 <strong>AspectJ</strong> ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/06/mysql%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/mysql%E9%9D%A2%E8%AF%95/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-06 15:16:01 / 修改时间：15:29:31" itemprop="dateCreated datePublished" datetime="2022-04-06T15:16:01+08:00">2022-04-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="MySQL的逻辑架构图"><a href="#MySQL的逻辑架构图" class="headerlink" title="MySQL的逻辑架构图"></a>MySQL的逻辑架构图</h3><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220312085136410.png" alt="image-20220312085136410"></p>
<p>Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p>查询缓存   可以通过query_cache_type进行开关0是关闭，1是开启，2是按需获取</p>
<p>分析器  词法分析分析是否是关键字，语法分析分析语法写的是否正确，分析器分析表是否存在列是否存在</p>
<p>优化器  决定SQL怎么执行是最好的</p>
<p>执行器 操作对应的引擎，返回结果</p>
<p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220403094200555.png" alt="image-20220403094200555"></p>
<h3 id="MyISAM-和-InnoDB-的区别"><a href="#MyISAM-和-InnoDB-的区别" class="headerlink" title="MyISAM 和 InnoDB 的区别"></a>MyISAM 和 InnoDB 的区别</h3><p><strong>1.是否支持行级锁</strong></p>
<p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p>
<p>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！</p>
<p><strong>行锁就是针对数据表中行记录的锁</strong>，<strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p>
<p><strong>2.是否支持事务</strong></p>
<p>MyISAM 不提供事务支持。</p>
<p>InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。</p>
<p>提到<strong>事务</strong>，你肯定会想到 <strong>ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）</strong></p>
<p><strong>多条事务执行执行时可能出现的情况</strong></p>
<p>脏读:读到其他事务未提交的数据； </p>
<p><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 也修改 A&#x3D;A-1，最终结果 A&#x3D;19，事务 1 的修改被丢失。</p>
<p>不可重复读：前后读取的记录内容不一致； </p>
<p>幻读：前后读取的记录数量不一致。</p>
<p><strong>SQL 标准的事务隔离级别包括：</strong></p>
<p>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</p>
<p>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</p>
<p>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</p>
<p>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p>
<p><strong>你可能会问那什么时候需要“可重复读”的场景呢？</strong></p>
<p>假设你在管理一个个人银行账户表。一个表存了账户余额，一个表存了账单明细。到了月底你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。</p>
<p>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。和jvm的锁有关联</p>
<p>MVCC:每条记录在更新的时候都会同时记录一条回滚操作。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）,是事务隔离级别的实现。</p>
<p><strong>3.是否支持外键</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>🌈 拓展一下：</p>
<p>一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</p>
<p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p>
<h4 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a><strong>redolog</strong></h4><p><strong>其实就是 MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging，</strong>它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本，具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p>
<p>与此类似，InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p>
<p><img src="C:\Users\86187\AppData\Roaming\Typora\typora-user-images\image-20220312083324081.png" alt="image-20220312083324081"></p>
<p>write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p>
<p><strong>write pos 和 checkpoint</strong> 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。</p>
<p><strong>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。</strong></p>
<p>要理解 crash-safe 这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。</p>
<h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a><strong>binlog</strong></h4><p>Server 层也有自己的日志，称为 binlog（归档日志）</p>
<p>这两种日志有以下三点不同。</p>
<ol>
<li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li>
<li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；</li>
<li>binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ol>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>🌈 拓展一下：</p>
<ul>
<li>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</li>
<li>MySQL InnoDB 引擎通过 <strong>锁机制</strong>、<strong>MVCC</strong> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code></strong> ）。</li>
<li>保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。</li>
</ul>
<h4 id="MySQL刷盘机制"><a href="#MySQL刷盘机制" class="headerlink" title="MySQL刷盘机制"></a>MySQL刷盘机制</h4><p>其中，有四种情况会触发脏页的刷盘： </p>
<ol>
<li><p>redo log 可写空间满了。</p>
</li>
<li><p>内存满了，需要淘汰的数据页恰好是脏页。</p>
</li>
<li><p>系统不繁忙的时候。</p>
</li>
<li><p>关 闭数据库的时候。</p>
<p> 其中，第三种情况不会为系统带来过多影响的，第四中情况下不会在乎为系统带来的影响。所以我 们只需要关注第一和第二种情况： 对于第二种情况，由于 mysql 的更新需要先写日志，所以当日志满了的情况下，所有的更新都会停 止，一直到刷完盘日志腾出了空间为止； </p>
<p>而对于第一种情况，当查询的数据在内存中的数据页没有的时候，就需要淘汰旧页释放内存以读入 新页，所以当一次查询导致需要淘汰的脏页过多的时候，就需要先等待较长的刷盘时间，然后才能 获取响应。 </p>
<p>为了避免上述两种情况，必须要控制脏页在内存中的比例。</p>
</li>
</ol>
<p><strong>5.是否支持 MVCC</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。</p>
<p>MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提供性能。</p>
<h3 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h3><p>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。innodb_lock_wait_timeout 的默认值是 50s，而且不能设置值太小误伤其他线程，所以一般不用这个策略。</p>
<p>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。</p>
<p>所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且 innodb_deadlock_detect 的默认值本身就是 on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。</p>
<p>假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。</p>
<p>一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉，另一个思路是控制并发度</p>
<p>你可以考虑通过将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的 1&#x2F;10，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。</p>
<h3 id="为什么表的数据删除一半，表文件大小不变"><a href="#为什么表的数据删除一半，表文件大小不变" class="headerlink" title="为什么表的数据删除一半，表文件大小不变"></a>为什么表的数据删除一半，表文件大小不变</h3><p>你现在知道了，delete 命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也就是说，通过 delete 命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是“空洞”。</p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h4><p>提到事务，你肯定会想到 ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）</p>
<h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><ul>
<li><strong>读未提交</strong>是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li><strong>读提交</strong>是指，一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li><strong>可重复读</strong>是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li><strong>串行化</strong>，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ul>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220403142212814.png" alt="image-20220403142212814"></p>
<ul>
<li>脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</li>
<li>不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</li>
<li>幻读:事务A 按照一定条件进行数据读取， 期间事务B 插入了相同搜索条件的新数据，事务A再次按照原先条件进行读取时，发现了事务B新插入的数据 称为幻读</li>
</ul>
<h3 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h3><h4 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h4><p>MVCC(Multiversion Concurrency Control)),多版本并发控制。顾名思义，MVcc是通过数据行的多个版本管理来实现数据库的并发控制。这项技术使得在InnoDB的事务隔离级别下执行一致性读操作有了保证。换言之，<strong>就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值</strong>，这样在做查询的时候就不用等待另一个事务释放锁。</p>
<h4 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h4><p>所谓的MVCC,就是生成一个ReadView,通过ReadView找到符合条件的记录版本（历史版本由undo日志构建)。查询语句只能读到在生成ReadView,之前己提交事务所做的更改，在生成ReadView之前未提交的事务或者之后才开启的事务所做的更改是看不到的。而写操作肯定针对的是最新版本的记录，读记录的历史版本和改动记录的最新版本本身并不冲突，也就是采用MVCC时，读-写操作并不冲突。</p>
<h4 id="再谈隔离级别"><a href="#再谈隔离级别" class="headerlink" title="再谈隔离级别"></a>再谈隔离级别</h4><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220404161412581.png" alt="image-20220404161412581"></p>
<p>​                                                                                                          SQL标准下的隔离级别</p>
<p>SQL标准下的隔离级别，在MySQL下是不一样的，MySQL默认的隔离级别<strong>可重复读</strong>不仅解决了脏读、不可重复读，<strong>也解决了幻读</strong>，主要原因是因为使用了MVCC，在MVCC相当于使用了快照。</p>
<p>MCC可以不采用锁机制，而是通过乐观锁的方式来解决不可重复读和幻读问题！它可以在大多数情况下替代行级锁，降低系统的开销。</p>
<h4 id="隐藏字段、Undo-Log版本链"><a href="#隐藏字段、Undo-Log版本链" class="headerlink" title="隐藏字段、Undo Log版本链"></a>隐藏字段、Undo Log版本链</h4><p>回顾一下undo Log的版本链，对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。</p>
<ul>
<li>trx_id：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务1d赋值给trx_1d隐藏列。</li>
<li>roll_pointer:每次对某条聚簇索引记录进行改动时，都会把I旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。指向上一个版本快照。</li>
</ul>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220404165512887.png" alt="image-20220404165512887"></p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220404213200554.png" alt="image-20220404213200554"></p>
<h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h4><h5 id="什么是ReadView"><a href="#什么是ReadView" class="headerlink" title="什么是ReadView"></a>什么是ReadView</h5><p>在MVCC机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在Undo Log里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢？这时就需要用到ReadView了，它帮我们解决了行的可见性问题。<br>ReadView就是事务A在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前<strong>活跃事务</strong>的ID(“活跃”指的就是，启动了但还没提交)</p>
<h5 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h5><p>使用READ UNCOMMITTED隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。<br>使用SERIALIZABLE隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。<br>使用READ COMMITTED和REPEATABLE READ隔离级别的事务，都必须保证读到<strong>已经提交了的</strong>事务修改过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。<br>这个ReadView中主要包含4个比较重要的内容，分别如下：</p>
<p>1.creator_trx_id&#96;,创建这个Read View的事务ID。</p>
<blockquote>
<p>说明：只有在对表中的记录做改动时（执行NSERT、DELETE、UPDATE这些语句时）才会为事务分配事<br>务d,否则在一个只读事务中的事务d值都默认为0。</p>
</blockquote>
<p>2.trx_ids,表示在生成ReadView时当前系统中<strong>活跃的</strong>(没有提交的)读写事务的事务id列表。<br>3.up_limit_id,活跃的事务中最小的事务ID。<br>4.low_limit_id,<strong>表示生成ReadView时系统中应该分配给下一个事务的id值</strong>。low_limit_id是系统最大的事务id值，这里要注意是系统中的事务id,需要区别于正在活跃的事务ID。   max（活跃，提交）</p>
<blockquote>
<p>注意：low_limit_.id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1,2,3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，trX_ids就包括1和2，up_limit_.id的值就是1，low_limit_id的值就是4。</p>
</blockquote>
<p>举例</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220404164609021.png" alt="image-20220404164609021"></p>
<h5 id="ReadView的规则"><a href="#ReadView的规则" class="headerlink" title="ReadView的规则"></a>ReadView的规则</h5><p>有了这个ReadView,这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。</p>
<ul>
<li><p>如果被访问版本的trx_id,属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</p>
</li>
<li><p>如果被访问版本的trx_id属性值小于ReadView中的up_limit_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</p>
</li>
<li><p>如果被访问版本的trx_id属性值大于或等于ReadView中的Iow_limit_id值，表明生成该版本的事务在当前事务生成ReadView,后才开启，所以该版本不可以被当前事务访问。</p>
</li>
<li><p>如果被访问版本的trx_id,属性值在ReadView的up_limit_id和low_limit_id之间，那就需要判断一下trx_id属性值是不是在trx_ids列表中。</p>
<p>  如果在，说明创建ReadViewl时生成该版本的事务还是活跃的，该版本不可以被访问。<br>  如果不在，说明创建ReadViewl时生成该版本的事务已经被提交，该版本可以被访问。</p>
</li>
</ul>
<h4 id="MVCC整体操作流程"><a href="#MVCC整体操作流程" class="headerlink" title="MVCC整体操作流程"></a>MVCC整体操作流程</h4><p>了解了这些概念之后，我们来看下当查询一条记录的时候，系统如何通过MVCC找到它：</p>
<ol>
<li>首先获取事务自己的版本号，也就是事务ID</li>
<li>获取ReadView:</li>
<li>查询得到的数据，然后与ReadView中的事务版本号进行比较：</li>
<li>如果不符合ReadView规则，就需要从Undo Log中获取历史快照；</li>
<li>最后返回符合规则的数据。</li>
</ol>
<p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p>
<blockquote>
<p>InnoDB中，MVCC是通过Undo Log+Read View进行数据读取，Undo Log保存了历史快照，而Read View规则帮我们判断当前版本的数据是否可见。</p>
</blockquote>
<p>读已提交个隔离级别，一个事务每一次SELECT查询都会重新获取一次Read View</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220404165731384.png" alt="image-20220404165731384"></p>
<p>当隔离级别为可重复读的时候，就避免了不可重复读，这是因为一个事务只在第一次SELECT的时候会获取一次Read View,而后面所有的SELECT都会复用这个Read View,如下表所示：</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220404165831731.png" alt="image-20220404165831731"></p>
<h4 id="MVCC在可重复读情况下解决幻读"><a href="#MVCC在可重复读情况下解决幻读" class="headerlink" title="MVCC在可重复读情况下解决幻读"></a>MVCC在可重复读情况下解决幻读</h4><p>每次查询可以看到的ReadView都是一个ReadView，所以连续两次读不会结果不同。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这里介绍了MVCC在READ COMMITTD、REPEATABLE READ这两种隔离级别的事务在执行快照读操作时访问记录的版本链的过程。这样使不同事务的读-写、写-读操作并发执行，从而提升系统性能。<br>核心点在于ReadView的原理，READ COMMITTD、REPEATABLE READ这两个隔离级别的一个很大不同就是生成ReadView的时机不同：</p>
<ul>
<li>READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView。</li>
<li>REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView,之后的查询操作都重复使用这个ReadView就好了。</li>
</ul>
<blockquote>
<p>说明：我们之前说执行DELETE语句或者更新主键的JPDATE语句并不会立即把对应的记录完全从页面中删除而是执行一个所谓的delete marki操作，相当于只是对记录打上了一个删除标志位，这主要就是为MVcc服务的。</p>
</blockquote>
<p>通过MVCC我们可以解决：</p>
<ol>
<li>读写之间阻塞的问题。通过MVCC可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。</li>
<li>降低了死锁的概率。这是因为MCC采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。</li>
<li>解决快照读的问题。当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。</li>
</ol>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h3 id="索引的几类型"><a href="#索引的几类型" class="headerlink" title="索引的几类型"></a>索引的几类型</h3><ol>
<li>普通索引</li>
<li>唯一索引</li>
<li>主键索引</li>
<li>组合索引</li>
<li>全文索引</li>
</ol>
<h4 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h4><p>这里我先给你介绍三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。</p>
<p>所以，哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎，有序数组索引只适用于静态存储引擎，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。</p>
<h4 id="B树（B-树-平衡多路查找树）"><a href="#B树（B-树-平衡多路查找树）" class="headerlink" title="B树（B-树    平衡多路查找树）"></a>B树（B-树    平衡多路查找树）</h4><p>（1）树种的每个节点最多拥有m个子节点且m&gt;&#x3D;2,空树除外（注：m阶代表一个树节点最多有多少个查找路径，m阶&#x3D;m路,当m&#x3D;2则是2叉树,m&#x3D;3则是3叉）；</p>
<p>（2）除根节点外每个节点的关键字数量大于等于ceil(m&#x2F;2)-1个小于等于m-1个，非根节点关键字数必须&gt;&#x3D;2;（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2)</p>
<p>（3）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子</p>
<p>（4）如果一个非叶节点有N个子节点，则该节点的关键字数等于N-1;</p>
<p>（5）所有节点关键字是按递增次序排列，并遵循左小右大原则；</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220403144605645.png" alt="image-20220403144605645"></p>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p>B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定；我们先看看两者的区别</p>
<p>（1）B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，这样使得B+树每个节点所能保存的关键字大大增加；</p>
<p>（2）B+树叶子节点保存了父节点的所有关键字和关键字记录的指针，每个叶子节点的关键字从小到大链接；</p>
<p>（3）B+树的根节点关键字数量和其子节点个数相等;</p>
<p>（4）B+的非叶子节点只进行数据索引，不会存实际的关键字记录的指针，所有数据地址必须要到叶子节点才能获取到，所以每次数据查询的次数都一样；</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220403145208350.png" alt="image-20220403145208350"></p>
<p>特点：在B树的基础上每个节点存储的关键字数更多，树的层级更少所以查询数据更快，所有指关键字指针都存在叶子节点，所以每次查找的次数都相同所以查询速度更稳定;</p>
<h4 id="InnoDB索引模型"><a href="#InnoDB索引模型" class="headerlink" title="InnoDB索引模型"></a>InnoDB索引模型</h4><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。</p>
<p>每一个索引在 InnoDB 里面对应一棵 B+ 树。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> T(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key, </span><br><span class="line">k <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>, </span><br><span class="line">name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">index (k))engine<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure>

<h4 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h4><p>基于主键索引和普通索引的查询有什么区别？</p>
<ul>
<li><p>如果语句是 select * from T where ID&#x3D;500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；</p>
</li>
<li><p>如果语句是 select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为<strong>回表</strong>。</p>
<p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p>
</li>
</ul>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果一个索引包含了满足查询语句中字段与条件的数据就叫做覆盖索引。</p>
<p>(k)</p>
<p>如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p>
<p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p>
<h4 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h4><p>顾名思义：最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。例如：b &#x3D; 2 如果建立(a,b)顺序的索引，是匹配不到(a,b)索引的；但是如果查询条件是a &#x3D; 1 and b &#x3D; 2或者a&#x3D;1(又或者是b &#x3D; 2 and b &#x3D; 1)就可以，因为优化器会自动调整a,b的顺序。再比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，因为c字段是一个范围查询，它之后的字段会停止匹配</p>
<p>最左匹配原则都是针对联合索引来说的，所以我们有必要了解一下联合索引的原理。了解了联合索引，那么为什么会有最左匹配原则这种说法也就理解了。</p>
<p>我们都知道索引的底层是一颗B+树，那么联合索引当然还是一颗B+树，只不过联合索引的健值数量不是一个，而是多个。构建一颗B+树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建B+树。<br>例子：假如创建一个（a,b)的联合索引，那么它的索引树是这样的</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220403163830215.png" alt="image-20220403163830215"></p>
<p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。所以b &#x3D; 2这种查询条件没有办法利用索引，因为联合索引首先是按a排序的，b是无序的。</p>
<h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><p>如有索引 (a,b,c,d)，查询条件 a&#x3D;1 and b&#x3D;2 and c&gt;3 and d&#x3D;4，则会在每个节点依次命中 a、b、c，无 法命中 d。(c 已经是范围查询了，d 肯定是排不了序了)</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220404125622828.png" alt="image-20220404125622828"></p>
<h5 id="范围查询右边失效的情况"><a href="#范围查询右边失效的情况" class="headerlink" title="范围查询右边失效的情况"></a>范围查询右边失效的情况</h5><p>举例</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220404130115771.png" alt="image-20220404130115771"></p>
<p>分析如下：<br>首先字段在B+树上是有序的，所以可以用二分查找法定位到1，然后将所有大于1的数据取出来，a可以用到索引。<br>b有序的前提是a是确定的值，那么现在a的值是取大于1的，可能有10个大于1的a,也可能有一百个a。<br>大于1的那部分的B+树里，b字段是无序的（开局一张图），所以b不能在无序的B+树里用二分查找来查询，b用不到索引。</p>
<h5 id="模糊查询索引失效问题"><a href="#模糊查询索引失效问题" class="headerlink" title="模糊查询索引失效问题"></a>模糊查询索引失效问题</h5><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220404130348676.png" alt="image-20220404130348676"></p>
<p>我们先来了解一下%的用途</p>
<ul>
<li>%放在右边，代表查询以”a”开头的数据，如：abc</li>
<li>两个%%，代表查询数据中包含”a”的数据，如：cab、cba、abc</li>
<li>%放在左边，代表查询以”a”为结尾的数据，如cba</li>
</ul>
<p>为什么%放在右边有时候能用到索引</p>
<ul>
<li>%放右边叫做：前缀</li>
<li>%%叫做：中缀</li>
<li>%放在左边叫做：后缀</li>
</ul>
<p>字符串的存放本身就是满足最左匹配原则的，按照第一个字符排序如果第一个字母相同就按照第二 字母排序。如果%放右边，B+树的索引顺序是按照首字母大小进行排序的，所以首字母明确了，就可以在 B+树上有序查找。 其他情况都无法确定首字母所以无法按照顺序查找，只能走全表。效率很低下。</p>
<h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tuser <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> ismale<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。</p>
<p>而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<p>图 4 跟图 3 的区别是，InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次。</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220403164923369.png" alt="image-20220403164923369"></p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220403164930546.png" alt="image-20220403164930546"></p>
<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>前缀索引也叫局部索引，比如给身份证的前 10 位添加索引，类似这种给某列部分信息添加索 引的方式叫做前缀索引。前缀索引能有效减小索引文件的大小，让每个索引页可以保存更多的索引 值，从而提高了索引查询的速度。但前缀索引也有它的缺点，不能在 order by 或者 group by 中触 发前缀索引，也不能把它们用于覆盖索引。目的就是为了降低重复的索引提高每个节点存放索引的 数量。减少 IO 次数提高查询速度。</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="共享锁（S-Lock-读锁）和排他锁（X-Lcok-写锁）"><a href="#共享锁（S-Lock-读锁）和排他锁（X-Lcok-写锁）" class="headerlink" title="共享锁（S Lock 读锁）和排他锁（X Lcok 写锁）"></a>共享锁（S Lock 读锁）和排他锁（X Lcok 写锁）</h4><ul>
<li>读锁 ：也称为 共享锁 、英文用 S 表示。针对同一份数据，多个事务的读操作可以同时进行而不会 互相影响，相互不阻塞的。</li>
<li>写锁 ：也称为 排他锁 、英文用 X 表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样 就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。</li>
</ul>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220403180158929.png" alt="image-20220403180158929"></p>
<p>默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的 获取锁请求，然后再给读锁队列中等候的获取锁请求</p>
<p>可以设置改变读锁和写锁的优先级</p>
<ul>
<li>通过指定启动参数 low-priority-updates，使 MyISAM 引擎默认给予读请求以优先的权利。 </li>
<li>通过执行命令 SET LOW_PRIORITY_UPDATES&#x3D;1，使该连接发出的更新请求优先级降低。 </li>
<li>通过指定 INSERT、UPDATE、DELETE 语句的 LOW_PRIORITY 属性，降低该语句的优先级。 </li>
<li>给系统参数 max_write_lock_count 设置一个合适的值，当一个表的读锁达到这个值后，MySQL 就暂时将写请求的优先级降低，给读进程一定获得锁的机会。</li>
</ul>
<h4 id="表级锁、页级锁、行锁"><a href="#表级锁、页级锁、行锁" class="headerlink" title="表级锁、页级锁、行锁"></a>表级锁、页级锁、行锁</h4><h5 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h5><h6 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h6><p>当产生行级别的锁时候，会产生对应的表级别意向锁(IX,IS)，防止检索锁的速度慢，因为要查到对应的行是很麻烦的。</p>
<p>读取也可以使用排他锁</p>
<p>意向共享锁</p>
<ul>
<li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先 取得该表的 IS 锁。 </li>
<li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先 取得该表的 IX 锁。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> 事务要获取某些行的 S 锁，必须先获得表的 <span class="keyword">IS</span> 锁。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure>

<p>意向排他锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>在5.7及之前版本，select … for update,如果获取不到锁，会一直等待，直到innodb_lock_wait_timeout超时</p>
<ul>
<li>InnoDB 支持 多粒度锁 ，特定场景下，行级锁可以与表级锁共存。 </li>
<li>意向锁之间互不排斥，但除了 IS 与 S 兼容外， 意向锁会与 共享锁 &#x2F; 排他锁 互斥 。 </li>
<li>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。 </li>
<li>意向锁在保证并发性的前提下，实现了 行锁和表锁共存 且 满足事务隔离性 的要求。</li>
</ul>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220403202731069.png" alt="image-20220403202731069"></p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220403202737106.png" alt="image-20220403202737106"></p>
<h6 id="自增锁-AUTO-INC锁"><a href="#自增锁-AUTO-INC锁" class="headerlink" title="自增锁(AUTO-INC锁)"></a>自增锁(AUTO-INC锁)</h6><h6 id="元数据锁（MDL锁）"><a href="#元数据锁（MDL锁）" class="headerlink" title="元数据锁（MDL锁）"></a>元数据锁（MDL锁）</h6><p>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL 的作用是，保证读写的正确性。比 如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更 ，增加了一 列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。 </p>
<p><strong>因此，当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写 锁。</strong></p>
<p>读锁之间不互斥，因此你可以有多个线程同时对-张表增删改查。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性，解决了DML和DDL操作之间的一致性问题。不需要显式使用，在访问一个表的时候会被自动加上。</p>
<p><strong>会采用公平队列，如果先用MDL读锁，然后再用MDL写锁阻塞，之后再采用MDL读锁就会继续排队</strong></p>
<h5 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h5><p>行锁(Row Lock)也称为记录锁，顾名思义，就是锁住某一行（某条记录row)。需要的注意的是，MySQL服器层并没有实现行锁机制，<strong>行级锁只在存储引擎层实现。</strong><br><strong>优点</strong>：锁定粒度小，发生锁冲突概率低，可以实现的并发度高。<br><strong>缺点：</strong>对于锁的开销比较大，加锁会比较慢，容易出现死锁情况。</p>
<h6 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a>InnoDB行锁实现方式</h6><ul>
<li>InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后 者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：<strong>只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</strong> </li>
<li>不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。 </li>
<li>只有执行计划真正使用了索引，才能使用行锁：即便在条件中使用了索引字段，但是否使用 索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，<strong>如果 MySQL 认为全表 扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁， 而不是行锁。</strong>因此，<strong>在分析锁冲突时，别忘了检查 SQL 的执行计划</strong>（可以通过 explain 检查 SQL  的 执 行 计 划 ） ， 以确认是否真正使用了索引 。 </li>
<li>由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然多个 session 是访问不同行的记录，<strong>但是如果是使用相同的索引键，是会出现锁冲突的（后使用这些索引的 session 需要等待先使用索引的 session 释放锁后，才能获取锁）</strong>。应用设计的时候要注意这一点。</li>
</ul>
<h6 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h6><p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为：LOCK_REC_NOT_GAP。比如我们把id值为8的那条记录加一个记录锁的示意图如图所示。仅仅是锁住了i值为8的记录，对周围的数据没有影响。</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220403210259912.png" alt="image-20220403210259912"></p>
<p>记录锁是有S锁和X锁之分的，称之为S型记录锁和型记录锁。</p>
<ul>
<li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的$型记录锁，但不可以继续获取X型记录锁，</li>
<li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li>
</ul>
<h6 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h6><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220403210956771.png" alt="image-20220403210956771"></p>
<p>图中id值为8的记录加了gap锁，间隙锁可以是4567，<strong>意味着不允许别的事务在id值为8的记录前边的间隙插入新记录，其实就是id列的值(3,8)这个区间的新记录是不允许立即插入的。</strong>比如，有另外一个事务再想插入一条d值为4的新记录，它定位到该条新记录的下一条记录的id值为8，而这条记录上又有一个gp锁，所以就会阻塞插入操作，直到拥有这个gap锁的事务提交了之后，id列的值在区间(3,8)中的新记录才可以被插入。<br>gap锁的提出仅仅是为了防止插入幻影记录而提出的。<strong>虽然有共享gap锁和独占gap锁这样的说法，但是它们起到的作用是相同的。</strong>而且如果对一条记录加了gap锁（不论是共享gap锁还是独占gap锁），并不会限制其他事务对这条记录加记录锁或者继续加gap锁。</p>
<p>最后一位为20，之后加了一个25的间隙锁，则大于20的都不能插入。</p>
<p>可能会出现死锁问题。</p>
<h6 id="临键锁（Next-Keys-Locks）"><a href="#临键锁（Next-Keys-Locks）" class="headerlink" title="临键锁（Next-Keys Locks）"></a>临键锁（Next-Keys Locks）</h6><p>有时候我们<strong>既想锁住某条记录</strong>，又想&#96;<strong>阻止</strong>其他事务在该记录前边的<strong>间隙插入新记录</strong>，所以InnoDB就提出了一种称之为Next-Key Locks的锁，官方的类型名称为：LOCK_ORDINARY,我们也可以简称为next-key锁。NextKey Locks是在存储擎innodb、事务级别在<strong>可重复读</strong>的情况下使用的数据库锁，innodb默认的锁就是Next-Keylocks。比如，我们把id值为8的那条记录加一个next-key锁的示意图如下：</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220403212708066.png" alt="image-20220403212708066"></p>
<p>next-key锁的本质就是一个记录锁和一个gap锁的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">8</span> <span class="keyword">and</span> id <span class="operator">&gt;</span> <span class="number">3</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<h6 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h6><h5 id="页锁"><a href="#页锁" class="headerlink" title="页锁"></a>页锁</h5><p>页锁就是在页的粒度上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。<em><strong>页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。</strong></em><br>每个层级的锁数量是有限制的，因为锁会占用内存空间，锁空间的大小是有限的。当某个层级的锁数量超过了这个层级的阈值时，就会进行锁升级。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。</p>
<h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><h5 id="悲观锁（Pessimistic-Locking）"><a href="#悲观锁（Pessimistic-Locking）" class="headerlink" title="悲观锁（Pessimistic Locking）"></a>悲观锁（Pessimistic Locking）</h5><p>悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。<br>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程)。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p>
<p>悲观锁不适用的场景较多，它存在一些不足，因为悲观锁大多数情况下依靠数据库的锁机制来实现，以保证程序的并发访问性，同时这样对数据库性能开销影响也很大，特别是长事务而言，这样的开销往往无法承受，这时就需要乐观锁。</p>
<h5 id="乐观锁（optimistic-locking）"><a href="#乐观锁（optimistic-locking）" class="headerlink" title="乐观锁（optimistic locking）"></a>乐观锁（optimistic locking）</h5><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是<em>不采用数据库自身的锁机制，而是通过程序来实现</em>。在程序上，我们可以采用版本号机制或者CS机制实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量。在Java中java.utl.concurrent.atomic包下的原子变量类就是使用了乐观锁的一种实现方式：CAS实现的。</p>
<h6 id="1-乐观锁的版本号机制"><a href="#1-乐观锁的版本号机制" class="headerlink" title="1.乐观锁的版本号机制"></a>1.乐观锁的版本号机制</h6><p>在表中设计一个版本字段version,第一次读的时候，会获取version字段的取值。然后对数据进行更新或删除操作时，会执行UPDATE…SET version&#x3D;version+1 WHERE version&#x3D;version。此时如果已经有事务对这条数据进行了更改，修改就不会成功。<br>这种方式类似我们熟悉的SVN、CVS版本管理系统，当我们修改了代码进行提交时，首先会检查当前版本号与服务器上的版本号是否一致，如果一致就可以直接提交，如果不一致就需要更新服务器上的最新代码，然后再进行提交。</p>
<h5 id="两种所适用情况"><a href="#两种所适用情况" class="headerlink" title="两种所适用情况"></a>两种所适用情况</h5><p>从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景：</p>
<ol>
<li>乐观锁适合读操作多的场景，相对来说写的操比较少。它的优点在于程序实现，不存在死锁问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</li>
<li>悲观锁适合写操作多的场景，因为写的操作具有排它性。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止读-写和写-写的冲突。<br>我们把乐观锁和悲观锁总结如下图所示。</li>
</ol>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220404101909756.png" alt="image-20220404101909756"></p>
<h3 id="显示锁和隐式锁"><a href="#显示锁和隐式锁" class="headerlink" title="显示锁和隐式锁"></a>显示锁和隐式锁</h3><h4 id="隐式锁"><a href="#隐式锁" class="headerlink" title="隐式锁"></a>隐式锁</h4><h4 id="显示锁"><a href="#显示锁" class="headerlink" title="显示锁"></a>显示锁</h4><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220404103917912.png" alt="image-20220404103917912"></p>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>全局锁就是对整个数据库实例加锁。<strong>当你需要让整个库处于只读状态的时候</strong>，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用场景是：做全库逻辑备份。<br>全局锁的命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flush tables <span class="keyword">with</span> read lock</span><br></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="产生死锁的必要条件"><a href="#产生死锁的必要条件" class="headerlink" title="产生死锁的必要条件"></a>产生死锁的必要条件</h4><ol>
<li>两个或者两个以上事务</li>
<li>每个事务都已经持有锁并且申请新的锁</li>
<li>锁资源同时只能被同一个事务持有或者不兼容</li>
<li>事务之间因为持有锁和申请锁导致彼此循环等待</li>
</ol>
<h4 id="如何处理死锁"><a href="#如何处理死锁" class="headerlink" title="如何处理死锁"></a>如何处理死锁</h4><p>方式1：等待，直到超时(innodb_lock_wait_timeout&#x3D;50s)。<br>即当两个事务互相等待时，当一个事务等待时间超过设置的阈值时，就将其回滚，另外事务继续进行。这种方法简单有效，在innodb中，参数<strong>innodb_lock_wait_timeout</strong>用来设置超时时间。<br>缺点：对于在线服务来说，这个等待时间往往是无法接受的。<br>那将此值修改短一些，比如1s,0.1s是否合适？不合适，容易误伤到普通的锁等待。</p>
<p>方式2：使用死锁检测进行死锁处理<br>方式1检测死锁太过被动，innodb还提供了wait-for graph算法来主动进行死锁检测，每当加锁请求无法立即<br>满足需要并进入等待时，wait-for graph.算法都会被触发。<br>这是一种较为主动的死锁检测机制，要求数据库保存锁的信息链表和事务等待链表两部分信息。</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220404105055504.png" alt="image-20220404105055504"></p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220404105104463.png" alt="image-20220404105104463"></p>
<p>一旦检测到回路、有死锁，这时候InnoDB存储引擎会选择回滚undo量最小的事务，让其他事务继续执行(innodb._dead1ock_detect&#x3D;on表示开启这个逻辑)。<br>缺点：每个新的被阻塞的线程，都要判断是不是由于自己的加入导致了死锁，这个操作时间复杂度是0(n)。如果100个并发线程同时更新同一行，意味着要检测100*100&#x3D;1万次，1万个线程就会有1千万次检测：</p>
<p>如何解决？</p>
<ul>
<li>方式1：关闭死锁检测，但意味着可能会出现大量的超时，会导致业务有损。</li>
<li>方式2：控制并发访问的数量。比如在中间件中实现对于相同行的更新，在进入引擎之前排队，这样在IoDB内部就不会有大量的死锁检测工作。<br>进一步的思路：<br>可以考虑通过将一行改成逻辑上的多行来减少锁冲突。比如，连锁超市账户总额的记录，可以考虑放到多条记录上。账户总额等于这多个记录的值的总和。</li>
</ul>
<h4 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h4><ul>
<li>合理设计索引，使业务SQL尽可能通过索引定位更少的行，减少锁竞争。</li>
<li>调整业务逻辑SQL执行顺序，避免update&#x2F;delete长时间持有锁的SQL在事务前面。</li>
<li>避免大事务，尽量将大事务拆成多个小事来处理，小事务缩短锁定资源的时间，发生锁冲突的几率也更小。</li>
<li>在并发比较高的系统中，不要显式加锁，特别是是在事务里显式加锁。如select..for update语句，如果是在事务里运行了start transaction或设置了autocommit等于0，那么就会锁定所查找到的记录。</li>
<li>降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC,可以避免掉很多因为gap锁造成的死锁。</li>
</ul>
<h3 id="锁的内存结构"><a href="#锁的内存结构" class="headerlink" title="锁的内存结构"></a>锁的内存结构</h3><p>理论上创建多个锁结构没问题，但是如果一个事务要获取10000条记录的锁，生成10000个锁结构也太崩溃了！所以决定在对不同记录加锁时，如果符合下边这些条件的记录会放到一个锁结构中。</p>
<ul>
<li>在同一个事务中进行加锁操作</li>
<li>被加锁的记录在同一个页面中</li>
<li>加锁的类型是一样的</li>
<li>等待状态是一样的</li>
</ul>
<p>InnoDB存储引擎锁结构如下</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220404110010359.png" alt="image-20220404110010359"></p>
<h3 id="锁监控"><a href="#锁监控" class="headerlink" title="锁监控"></a>锁监控</h3><p>关于MySQL锁的监控，我们一般可以通过检查InnoDB._row_Iock等状态变量来分析系统上的行锁的争夺情况 </p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/mysql%E9%9D%A2%E8%AF%95.assets/image-20220404110733333.png" alt="image-20220404110733333"></p>
<p>各个状态量的说明</p>
<ul>
<li>Innodb_row_lock_current_waits:当前正在等待锁定的数量：</li>
<li>Innodb_row_lock_time：从系统启动到现在锁定总时间长度；（等待总时长）</li>
<li>Innodb_row_lock_time-avg:每次等待所花平均时间；（等待平均时长）</li>
<li>Innodb_row_lock_time._max:从系统启动到现在等待最常的一次所花的时间：</li>
<li>Innodb_row_lock_waits：系统启动后到现在总共等待的次数；（等待总次数）</li>
</ul>
<h4 id="其他监控方法"><a href="#其他监控方法" class="headerlink" title="其他监控方法"></a>其他监控方法</h4><p>MySQL把事务和锁的信息记录在了information_schema库中，涉及到的三张表分别是INNODB_TRX、INNODB_LOCKS和INNODB_LOCK_WAITS。<br>MySQL5.7及之前，可以通过information_schema.INNODB_LOCKS查看事务的锁情况，但只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。<br>MySQL8.0删除了information,<em>schema.INNODB_LOCKS,添加了performance_schema.data_locks,可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，performance</em>.schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁。<br>同时，information._schema.INNODB_LOCK_WAITS也被performance_schema.data_lock_waits所代替。</p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h4 id="char和varchar的区别"><a href="#char和varchar的区别" class="headerlink" title="char和varchar的区别"></a>char和varchar的区别</h4><p><strong>char 是一种固定长度的类型，varchar 则是一种可变长度的类型</strong>，它们的区别是：<strong>char(M) 类型的数据列里，每个值都占用 M 个字节，如果某个长度小于 M，MySQL 就会在它的右边用空格字符补足．</strong>（在检索操作中那些填补出来的空格字符将被去掉）在 <strong>varchar(M)类型</strong>的 数据列里，<strong>每个值只占用刚好够用的字节再加上一个用来记录其长度的字节（即总长度为 L+1字节）</strong>,char插入时可省略尾部空格，varchar插入时不会省略尾部空格，查找时省略。</p>
<p>char 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p>
<p>在 MySQL 中用来判断是否需要进行对据列类型转换的规则（但是类型转换可能会走不 了索引。） </p>
<ol>
<li>在一个数据表里，如果每一个数据列的长度都是固定的，那么每一个数据行的长度也 将是固定的． </li>
<li>只要数据表里有一个数据列的长度的可变的，那么各数据行的长度都是可变的． </li>
<li>如果某个数据表里的数据行的长度是可变的，那么，为了节约存储空间，MySQL 会 把这个数据表里的固定长度类型的数据列转换为相应的可变长度类型．例外：长度小于 4 个 字符的 char 数据列不会被转换 varchar 类型</li>
</ol>
<h4 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h4><p>从数据结构角度上说</p>
<ol>
<li>树索引</li>
<li>Hash索引</li>
</ol>
<p>从物理存储角度说</p>
<ol>
<li>聚簇索引（叶子结点存储的是对应的数据）</li>
<li>非聚簇索引（叶子结点存储的仍是索引，主键）</li>
</ol>
<p>聚簇索引<strong>默认是主键</strong>，如果表中没有定义主键，InnoDB 会选择一个<strong>唯一的非空索引</strong>代替。如果没有这样的索引，InnoDB 会<strong>隐式定义一个主键</strong>来作为聚簇索引。<strong>InnoDB 只聚集在同一个页面中的记录。包含相邻健值的页面可能相距甚远。</strong></p>
<p>从逻辑上说</p>
<ol>
<li>普通索引</li>
<li>唯一索引</li>
<li>主键索引</li>
<li>联合索引</li>
<li>全文索引</li>
</ol>
<h4 id="查询索引有没有被使用的方法"><a href="#查询索引有没有被使用的方法" class="headerlink" title="查询索引有没有被使用的方法"></a>查询索引有没有被使用的方法</h4><p>使用 Explain 命令来查看语句的执行计划，MySQL 在执行某个语句之前，会将该语句过一遍查询优化器，之后会拿到对语句的分析，也就是执行计划，其中包含了许多信息。可以通过其中和索引有关的信息来分析是否命中了索引，例如：possilbe_key、key、key_len 等字段，分别说明了此语句可能会使用的索引、实际使用的索引以及使用的索引长度。</p>
<h4 id="InnoDB-和-MyISAM-的比较？"><a href="#InnoDB-和-MyISAM-的比较？" class="headerlink" title="InnoDB 和 MyISAM 的比较？"></a>InnoDB 和 MyISAM 的比较？</h4><ol>
<li>事务：MyISAM不支持事务，InnoDB支持事务；</li>
<li>全文索引：MyISAM 支持全文索引，InnoDB 5.6 之前不支持全文索引；</li>
<li>关于 count(<em>)：MyISAM会直接存储总行数，InnoDB 则不会，需要按行扫描。意思就是对于 select count(</em>) from table; 如果数据量大，MyISAM 会瞬间返回，而 InnoDB 则会一行行扫描；</li>
<li>外键：MyISAM 不支持外键，InnoDB 支持外键；</li>
<li>锁：MyISAM 只支持表锁，InnoDB 可以支持行锁。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/06/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-06 15:16:01" itemprop="dateCreated datePublished" datetime="2022-04-06T15:16:01+08:00">2022-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-03 08:23:47" itemprop="dateModified" datetime="2022-04-03T08:23:47+08:00">2022-04-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  CONCAT (NAME,<span class="string">&#x27;(&#x27;</span>,email,<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span> student </span><br><span class="line"><span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;马_&#x27;</span></span><br></pre></td></tr></table></figure>

<p>councat用于拼接</p>
<p><img src="/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.assets/image-20220403082147856.png" alt="image-20220403082147856"></p>
<p>as可以用来起别名</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  CONCAT (NAME,<span class="string">&#x27;(&#x27;</span>,email,<span class="string">&#x27;)&#x27;</span>) <span class="keyword">AS</span> bieming</span><br><span class="line"><span class="keyword">FROM</span> student </span><br><span class="line"><span class="keyword">WHERE</span> NAME <span class="keyword">LIKE</span> <span class="string">&#x27;马_&#x27;</span></span><br></pre></td></tr></table></figure>



<p><img src="/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.assets/image-20220403082334767.png" alt="image-20220403082334767"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/06/MQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/MQ/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-06 15:16:01 / 修改时间：15:24:10" itemprop="dateCreated datePublished" datetime="2022-04-06T15:16:01+08:00">2022-04-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p> 为什么要使用消息队列？</p>
<h3 id="常见MQ比较"><a href="#常见MQ比较" class="headerlink" title="常见MQ比较"></a>常见MQ比较</h3><p>ActiveMQ,RabbitMQ吞吐量为万级，RocketMQ，Kafka吞吐量为十万级别，</p>
<p>RocketMQ topic可以达到几百，几千个级别吞吐量会有较小幅度的下降，Kafka  topic从几十个到几百个的时候，吞吐量会大幅度下降</p>
<p>ActiveMQ,，RocketMQ，Kafka时效性都为ms，而RabbitMQ时效性为微秒</p>
<p>ActiveMQ,RabbitMQ可用性高，基于主从架构实现高可用性，RocketMQ和Kafka可用性非常高，采用的都是分布式架构</p>
<p>消息可靠性，ActiveMQ有较低概率丢失数据，RocketMQ，Kafka经过参数优化匹配，消息可以做到0丢失。</p>
<h3 id="RabbitMQ高可用的实现"><a href="#RabbitMQ高可用的实现" class="headerlink" title="RabbitMQ高可用的实现"></a>RabbitMQ高可用的实现</h3><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/MQ.assets/image-20220325121554889.png" alt="image-20220325121554889"></p>
<p>这种模式，才是所谓的 rabbitmq 的高可用模式，跟普通集群模式不一样的是，你创建的queue，无论元数据还是 queue 里的消息都会存在于多个实例上，然后每次你写消息到 queue 的时候，都会自动把消息到多个实例的 queue 里进行消息同步。类似 Redis 的主从复制。</p>
<p>这样的话，好处在于，你任何一个机器宕机了，没事儿，别的机器都可以用。坏处在于，第一，这个性能开销也太大了吧，，消息同步所有机器，导致网络带宽压力和消耗很重！第二，这么玩儿，就没有扩展性可言了，如果某个 queue 负载很重，你加机器，新增的机器也包含个queue的所有数据，并没有办法线性扩展你的 queue。<br>那么怎么开启这个镜像集群模式呢？我这里简单说一下，避免面试人家问你你不知道，其实很简单rabbitmq 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候可以要求数据同步到所有节点的，也可以要求就同步到指定数量的节点，然后你再次创建queue的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</p>
<h3 id="RabbitMQ如何保证消息不被重复消费"><a href="#RabbitMQ如何保证消息不被重复消费" class="headerlink" title="RabbitMQ如何保证消息不被重复消费"></a>RabbitMQ如何保证消息不被重复消费</h3><ol>
<li>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。</li>
<li>比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。</li>
<li>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</li>
<li>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据</li>
</ol>
<h3 id="如何保证消息的可靠性传输"><a href="#如何保证消息的可靠性传输" class="headerlink" title="如何保证消息的可靠性传输"></a>如何保证消息的可靠性传输</h3><h3 id="如何保证消息的消费顺序"><a href="#如何保证消息的消费顺序" class="headerlink" title="如何保证消息的消费顺序"></a>如何保证消息的消费顺序</h3><p>先看看顺序会错乱的俩场景 </p>
<p>（1）rabbitmq：一个 queue，多个 consumer，这不明显乱了，因为消费数据的顺序不同，有可能 2,3,1， 按正常来说应该 1,2,3 进行消费，如下图：</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/MQ.assets/image-20220330114518890.png" alt="image-20220330114518890"></p>
<p>（1）如何保证消息的顺序性呢？<br>拆分多个queue，每个queue一个consumer，就是多一些queue而已，确实是麻烦点；或者就一个 queue但是对应一个consumer，然后这个consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。如下图所示：</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/MQ.assets/image-20220330114300040.png" alt="image-20220330114300040"></p>
<h3 id="如何解决消息队列的延时以及过期失效的问题？"><a href="#如何解决消息队列的延时以及过期失效的问题？" class="headerlink" title="如何解决消息队列的延时以及过期失效的问题？"></a>如何解决消息队列的延时以及过期失效的问题？</h3><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/MQ.assets/image-20220330114732891.png" alt="image-20220330114732891"></p>
<p>（1）大量消息在 mq 里积压了几个小时了还没解决</p>
<p>几千万条数据在 MQ 里积压了七八个小时，从下午 4 点多，积压到了晚上很晚，10 点多，11 点多 </p>
<p>这个是我们真实遇到过的一个场景，确实是线上故障了，这个时候要不然就是修复 consumer 的问题， 让他恢复消费速度，然后傻傻的等待几个小时消费完毕。这个肯定不能在面试的时候说吧。 </p>
<p>一个消费者一秒是 1000 条，一秒 3 个消费者是 3000 条，一分钟是 18 万条，1000 多万条 所以如果你积压了几百万到上千万的数据，即使消费者恢复了，也需要大概 1 小时的时间才能恢复 过来 </p>
<p>一般这个时候，只能操作临时紧急扩容了，具体操作步骤和思路如下： </p>
<ol>
<li>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 cnosumer 都停掉 </li>
<li>新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍或者 20 倍的 queue 数量 </li>
<li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不 做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue </li>
<li>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据 </li>
<li>这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数 据 </li>
<li>等快速消费完积压数据之后，得恢复原先部署架构，重新用原先的 consumer 机器来消费消息</li>
</ol>
<p>上面的 topic，partition，queue 的关系弄不清楚，所以我总结如下：</p>
<p>修复原来生产者的问题，并停掉，然后新建一些生产者，快速消费消息，并不做耗时的处理，那么 这些消息如何快速消费呢？扩展集群，零时征用 10 倍的机器部署消费者，消费前边消费者转发过来 的消息，这样就很快消费掉队列里边堆积的消息了。</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/MQ.assets/image-20220330115507603.png" alt="image-20220330115507603"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/06/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/06/JVM/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-06 15:16:01 / 修改时间：15:24:59" itemprop="dateCreated datePublished" datetime="2022-04-06T15:16:01+08:00">2022-04-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<h3 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h3><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220315164232268.png" alt="image-20220315164232268"></p>
<p><strong>虚拟机栈</strong>描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都 会同步创建一个栈帧[1]（Stack Frame）用于<strong>存储局部变量表、操作数栈、动态连接、方法出口</strong>等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、 float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始 地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress<br>类型（指向了一条字节码指令的地址）。</p>
<p>Java<strong>堆</strong>是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。</p>
<p><strong>方法区（Method Area）</strong>与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<p>类加载会在方法区内加载，虚拟机栈包含了局部变量表和对象引用类型(stu,args),本地方法栈包含一些本地方法，而Hotspot虚拟机将本地方法栈合并到虚拟机栈中，解释器将Java字节码转换成机器码，对同一行代码反复解释，对于频繁执行的代码（热点代码），即时编译器发现热点代码将热点代码缓存，下次调用便会从缓存中读取。</p>
<h3 id="哪些区域会产生内存溢出"><a href="#哪些区域会产生内存溢出" class="headerlink" title="哪些区域会产生内存溢出"></a>哪些区域会产生内存溢出</h3><h4 id="产生OutOfMemoryError的情况"><a href="#产生OutOfMemoryError的情况" class="headerlink" title="产生OutOfMemoryError的情况"></a>产生OutOfMemoryError的情况</h4><ol>
<li>堆内存耗尽会出现<strong>OutOfMemoryError</strong></li>
<li>方法区内存耗尽-加载的类越来越多，很多框架都会动态的产生类，此时会产生OutOfMemoryError</li>
<li>​    虚拟机栈累积，每个线程最多占用1M内存，<strong>线程个数</strong>越来越多而又长时间不销毁，(<strong>在创建线程申请内存时就无法获得足够内</strong>存)，则会产生OutOfMemoryError</li>
</ol>
<h4 id="产生StackOverFlowError的情况"><a href="#产生StackOverFlowError的情况" class="headerlink" title="产生StackOverFlowError的情况"></a>产生StackOverFlowError的情况</h4><ol>
<li>​    HotSpot虚拟机不支持动态扩展，所以当<strong>线程内部方法</strong>调用次数过多时，虚拟机栈只会产生<strong>StackOverFlowError</strong>，而不会产生OutOfMemoryError</li>
</ol>
<h3 id="方法区与永久代、元空间的关系"><a href="#方法区与永久代、元空间的关系" class="headerlink" title="方法区与永久代、元空间的关系"></a>方法区与永久代、元空间的关系</h3><ul>
<li><strong>方法区</strong>是 JVM 规范中定义的一块内存区域，用来存储类元数据、方法字节码、即时编译器需要的信息等</li>
<li><strong>永久代</strong>是 Hotspot 虚拟机对 JVM 规范的实现（1.8 之前）</li>
<li><strong>元空间</strong>是 Hotspot 虚拟机对 JVM 规范的另一种实现（1.8 以后），使用本地内存作为这些信息的存储空间</li>
</ul>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831170457337.png" alt="image-20210831170457337"></p>
<p>从这张图学到三点</p>
<ul>
<li>当第一次用到某个类是，由类加载器将 class 文件的类元信息读入，并存储于元空间</li>
<li>X，Y 的类元信息是存储于元空间中，无法直接访问</li>
<li>可以用 X.class，Y.class 间接访问类元信息，它们俩属于 java 对象，我们的代码中可以使用</li>
</ul>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831170512418.png" alt="image-20210831170512418"></p>
<p>从这张图可以学到</p>
<ul>
<li>堆内存中：当一个<strong>类加载器对象</strong>，这个类加载器对象加载的所有<strong>类对象</strong>，这些类对象对应的所有<strong>实例对象</strong>都没人引用时，GC 时就会对它们占用的对内存进行释放</li>
<li>元空间中：内存释放<strong>以类加载器为单位</strong>，当堆中类加载器内存释放时，对应的元空间中的类元信息也会释放</li>
</ul>
<h3 id="Java虚拟机参数"><a href="#Java虚拟机参数" class="headerlink" title="Java虚拟机参数"></a>Java虚拟机参数</h3><p>-Xss  控制每个虚拟机栈的内存，Linux默认为1m</p>
<p><strong>堆内存，按大小设置</strong></p>
<p>-Xmx Java虚拟机最大内存是多少</p>
<p>-Xms Java虚拟机最小内存数</p>
<p>-Xmn 虚拟机新生代的占的内存</p>
<p>-XX:SurvivorRatio 伊甸园区和from部分的占比</p>
<p>-XX:NewRatio 控制新生代的占比</p>
<p>新生代分为伊甸园区和from区和to 区，Survivor区是from和to占的大小</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220316081701537.png" alt="image-20220316081701537"></p>
<p><strong>元空间内存设置</strong></p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831173118634.png" alt="image-20210831173118634"></p>
<p>解释：</p>
<ul>
<li>class space 存储类的基本信息，最大值受 -XX:CompressedClassSpaceSize 控制</li>
<li>non-class space 存储除类的基本信息以外的其它信息（如方法字节码、注解等）</li>
<li>class space 和 non-class space 总大小受 -XX:MaxMetaspaceSize 控制</li>
</ul>
<p>注意：</p>
<ul>
<li>这里 -XX:CompressedClassSpaceSize 这段空间还与是否开启了指针压缩有关，这里暂不深入展开，可以简单认为指针压缩默认开启</li>
</ul>
<p><strong>代码缓存内存设置</strong></p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220316082300452.png" alt="image-20220316082300452"></p>
<p>解释：</p>
<ul>
<li>如果 -XX:ReservedCodeCacheSize &lt; 240m，所有优化机器代码不加区分存在一起</li>
<li>否则，分成三个区域（图中笔误 mthod 拼写错误，少一个 e）<ul>
<li>non-nmethods - JVM 自己用的代码</li>
<li>profiled nmethods - 部分优化的机器码</li>
<li>non-profiled nmethods - 完全优化的机器码</li>
</ul>
</li>
</ul>
<h3 id="Java垃圾回收器"><a href="#Java垃圾回收器" class="headerlink" title="Java垃圾回收器"></a>Java垃圾回收器</h3><h4 id="Java的四种引用"><a href="#Java的四种引用" class="headerlink" title="Java的四种引用"></a>Java的四种引用</h4><p>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为<strong>强引用（Strongly Re-ference）、软 引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）</strong>4种，这4种引用强 度依次逐渐减弱。</p>
<ul>
<li>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object  obj&#x3D;new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回 收掉被引用的对象。</li>
</ul>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220317143558133.png" alt="image-20220317143558133"></p>
<ul>
<li><p>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，<strong>在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。</strong>在JDK 1.2版之后提供了SoftReference类来实现软引用。</p>
<p>SoftReference a&#x3D;new SoftReference(new A); 软引用自身内存不会释放，软引用需要配合引用队列来释放，典型例子是反射数据</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220317143547828.png" alt="image-20220317143547828"></p>
</li>
<li><p>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。<strong>当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</strong>在JDK 1.2版之后提供了WeakReference类来实现弱引用。</p>
</li>
</ul>
<p>​       WeakReference a&#x3D;new WeakReference(new A);弱引用自身需要配合队列来释放，典型例子是ThreadLocalMap中的Entry对象</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220317143612879.png" alt="image-20220317143612879"></p>
<ul>
<li><p>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。<strong>为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</strong>在JDK 1.2版之后提供<br>了PhantomReference类来实现虚引用。</p>
<p>PhantomReference a&#x3D;new PhantomReference(new A());必须配合引用队列一起使用，当虚引用的对象被回收时，会将虚引用对象入队，由Reference Handler线程释放其关联的外部资源，典型例子是Cleaner释放DirectByteBuffer占用的直接内存。</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210901112157901.png" alt="image-20210901112157901"></p>
</li>
</ul>
<h4 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h4><p>任何一个对象finalize方法都只会被系统调用一次，如果对象面临下一次回收，它的finalize方法不会再次执行。建议使用trl-finally方式代替finalize()</p>
<ul>
<li>它是 Object 中的一个方法，如果子类重写它，垃圾回收时此方法会被调用，可以在其中进行资源释放和清理工作</li>
<li>将资源释放和清理放在 finalize 方法中非常不好，非常影响性能，严重时甚至会引起 OOM，从 Java9 开始就被标注为 @Deprecated，不建议被使用了</li>
</ul>
<p><strong>finalize 原理</strong></p>
<ol>
<li>对 finalize 方法进行处理的核心逻辑位于 java.lang.ref.Finalizer 类中，它包含了名为 unfinalized 的静态变量（双向链表结构），Finalizer 也可被视为另一种引用对象（地位与软、弱、虚相当，只是不对外，无法直接使用）</li>
<li>当重写了 finalize 方法的对象，在构造方法调用之时，JVM 都会将其包装成一个 Finalizer 对象，并加入 unfinalized 链表中</li>
</ol>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210901121032813.png" alt="image-20210901121032813"></p>
<ol start="3">
<li>Finalizer 类中还有另一个重要的静态变量，即 ReferenceQueue 引用队列，刚开始它是空的。当狗对象可以被当作垃圾回收时，就会把这些狗对象对应的 Finalizer 对象加入此引用队列</li>
<li>但此时 Dog 对象还没法被立刻回收，因为 unfinalized -&gt; Finalizer 这一引用链还在引用它嘛，为的是【先别着急回收啊，等我调完 finalize 方法，再回收】</li>
<li>FinalizerThread 线程会从 ReferenceQueue 中逐一取出每个 Finalizer 对象，把它们从链表断开并真正调用 finallize 方法</li>
</ol>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210901122228916.png" alt="image-20210901122228916"></p>
<ol start="6">
<li>由于整个 Finalizer 对象已经从 unfinalized 链表中断开，这样没谁能引用到它和狗对象，所以下次 gc 时就被回收了</li>
</ol>
<p><strong>finalize 缺点</strong></p>
<ul>
<li>无法保证资源释放：FinalizerThread 是守护线程，代码很有可能没来得及执行完，线程就结束了，造成资源没有正确释放。</li>
<li>无法判断是否发生错误：执行 finalize 方法时，会吞掉任意异常（Throwable）</li>
<li>内存释放不及时：重写了 finalize 方法的对象在第一次被 gc 时，并不能及时释放它占用的内存，因为要等着 FinalizerThread 调用完 finalize，把它从 unfinalized 队列移除后，第二次 gc 时才能真正释放内存</li>
<li>可以想象gc本就因为内存不足引起，finalize调用又很慢(两个队列的移除操作，都是串行执行的，用来释放连接类的资源也应该不快)，不能及时释放内存，对象释放不及时就会逐渐移入老年代，老年代垃圾积累过多容易引起full gc，full gc后释放速度如果仍然跟不上创建新对象的速度，就会OOM。</li>
<li>有的文章提到【Finalizer 线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的CPU时间较少，因此它永远也赶不上主线程的步伐】这个显然是错误的，FinalizerThread 的优先级较普通线程更高，原因应该是 finalize 串行执行慢等原因综合导致</li>
</ul>
<h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h4><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220316085947530.png" alt="image-20220316085947530"></p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220316090003045.png" alt="image-20220316090003045"></p>
<h4 id="JVM垃圾回收算法"><a href="#JVM垃圾回收算法" class="headerlink" title="JVM垃圾回收算法"></a>JVM垃圾回收算法</h4><p><strong>三种垃圾回收算法</strong></p>
<p>标记清除法</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831211008162.png" alt="image-20210831211008162"></p>
<p>解释：</p>
<ol>
<li>找到 GC Root 对象，即那些一定不会被回收的对象，如正执行方法内局部变量引用的对象、静态变量引用的对象</li>
<li>标记阶段：沿着 GC Root 对象的引用链找，直接或间接引用到的对象加上标记</li>
<li>清除阶段：释放未加标记的对象占用的内存</li>
</ol>
<p>要点：</p>
<ul>
<li>标记速度与存活对象线性关系</li>
<li>清除速度与内存大小线性关系</li>
<li>缺点是会产生内存碎片</li>
</ul>
<p>标记整理法</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831211641241.png" alt="image-20210831211641241"></p>
<p>解释：</p>
<ol>
<li>前面的标记阶段、清理阶段与标记清除法类似</li>
<li>多了一步整理的动作，将存活对象向一端移动，可以避免内存碎片产生</li>
</ol>
<p>特点：</p>
<ul>
<li><p>标记速度与存活对象线性关系</p>
</li>
<li><p>清除与整理速度与内存大小成线性关系</p>
</li>
<li><p>缺点是性能上较慢</p>
</li>
</ul>
<p>标记复制法</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831212125813.png" alt="image-20210831212125813"></p>
<p>解释：</p>
<ol>
<li>将整个内存分成两个大小相等的区域，from 和 to，其中 to 总是处于空闲，from 存储新创建的对象</li>
<li>标记阶段与前面的算法类似</li>
<li>在找出存活对象后，会将它们从 from 复制到 to 区域，复制的过程中自然完成了碎片整理</li>
<li>复制完成后，交换 from 和 to 的位置即可</li>
</ol>
<p>特点：</p>
<ul>
<li>标记与复制速度与存活对象成线性关系</li>
<li>缺点是会占用成倍的空间</li>
</ul>
<h4 id="GC-与分代回收算法"><a href="#GC-与分代回收算法" class="headerlink" title="GC 与分代回收算法"></a>GC 与分代回收算法</h4><p>GC 的目的在于实现无用对象内存自动释放，减少内存碎片、加快分配速度</p>
<p>GC 要点：</p>
<ul>
<li>回收区域是<strong>堆内存</strong>，不包括虚拟机栈</li>
<li>判断无用对象，使用<strong>可达性分析算法</strong>，<strong>三色标记法</strong>标记存活对象，回收未标记对象</li>
<li>GC 具体的实现称为<strong>垃圾回收器</strong></li>
<li>GC 大都采用了<strong>分代回收思想</strong><ul>
<li>理论依据是大部分对象朝生夕灭，用完立刻就可以回收，另有少部分对象会长时间存活，每次很难回收</li>
<li>根据这两类对象的特性将回收区域分为<strong>新生代</strong>和<strong>老年代</strong>，新生代采用标记复制法、老年代一般采用标记整理法</li>
</ul>
</li>
<li>根据 GC 的规模可以分成 <strong>Minor GC</strong>，<strong>Mixed GC</strong>，<strong>Full GC</strong><ul>
<li><p>Minor GC 发生在新生代的垃圾回收，暂停时间短</p>
</li>
<li><p>Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有</p>
</li>
<li><p>Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a><strong>分代回收</strong></h5><ol>
<li>伊甸园 eden，最初对象都分配到这里，与幸存区 survivor（分成 from 和 to）合称新生代，</li>
</ol>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213622704.png" alt="image-20210831213622704"></p>
<ol start="2">
<li>当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象</li>
</ol>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213640110.png" alt="image-20210831213640110"></p>
<ol start="3">
<li>将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放</li>
</ol>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213657861.png" alt="image-20210831213657861"></p>
<ol start="4">
<li>将 from 和 to 交换位置</li>
</ol>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213708776.png" alt="image-20210831213708776"></p>
<ol start="5">
<li>经过一段时间后伊甸园的内存又出现不足</li>
</ol>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213724858.png" alt="image-20210831213724858"></p>
<ol start="6">
<li>标记伊甸园与 from（现阶段没有）的存活对象</li>
</ol>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213737669.png" alt="image-20210831213737669"></p>
<ol start="7">
<li>将存活对象采用复制算法复制到 to 中</li>
</ol>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213804315.png" alt="image-20210831213804315"></p>
<ol start="8">
<li>复制完毕后，伊甸园和 from 内存都得到释放</li>
</ol>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213815371.png" alt="image-20210831213815371"></p>
<ol start="9">
<li>将 from 和 to 交换位置</li>
</ol>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213826017.png" alt="image-20210831213826017"></p>
<ol start="10">
<li>老年代 old，当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）</li>
</ol>
<h4 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h4><p>即用三种颜色记录对象的标记状态</p>
<ul>
<li>黑色 – 已标记</li>
<li>灰色 – 标记中</li>
<li>白色 – 还未标记</li>
</ul>
<ol>
<li>起始的三个对象还未处理完成，用灰色表示</li>
</ol>
<img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215016566.png" alt="image-20210831215016566" style="zoom:50%;" />

<ol start="2">
<li>该对象的引用已经处理完成，用黑色表示，黑色引用的对象变为灰色</li>
</ol>
<img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215033510.png" alt="image-20210831215033510" style="zoom:50%;" />

<ol start="3">
<li>依次类推</li>
</ol>
<img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215105280.png" alt="image-20210831215105280" style="zoom:50%;" />

<ol start="4">
<li>沿着引用链都标记了一遍</li>
</ol>
<img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215146276.png" alt="image-20210831215146276" style="zoom:50%;" />

<ol start="5">
<li>最后为标记的白色对象，即为垃圾</li>
</ol>
<img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215158311.png" alt="image-20210831215158311" style="zoom:50%;" />

<h4 id="并发漏标问题"><a href="#并发漏标问题" class="headerlink" title="并发漏标问题"></a>并发漏标问题</h4><p>比较先进的垃圾回收器都支持<strong>并发标记</strong>，即在标记过程中，用户线程仍然能工作。但这样带来一个新的问题，如果用户线程修改了对象引用，那么就存在漏标问题。例如：</p>
<p>1.黑色的多了一条引用而黑色不能使得连接的白色变为灰色状态</p>
<ol>
<li>如图所示标记工作尚未完成</li>
</ol>
<img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215846876.png" alt="image-20210831215846876" style="zoom:50%;" />

<ol start="2">
<li>用户线程同时在工作，断开了第一层 3、4 两个对象之间的引用，这时对于正在处理 3 号对象的垃圾回收线程来讲，它会将 4 号对象当做是白色垃圾</li>
</ol>
<img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215904073.png" alt="image-20210831215904073" style="zoom:50%;" />

<ol start="3">
<li>但如果其他用户线程又建立了 2、4 两个对象的引用，这时因为 2 号对象是黑色已处理对象了，因此垃圾回收线程不会察觉到这个引用关系的变化，从而产生了漏标</li>
</ol>
<img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215919493.png" alt="image-20210831215919493" style="zoom:50%;" />

<ol start="4">
<li>如果用户线程让黑色对象引用了一个新增对象，一样会存在漏标问题</li>
</ol>
<img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831220004062.png" alt="image-20210831220004062" style="zoom:50%;" />

<p>因此对于<strong>并发标记</strong>而言，必须解决漏标问题，也就是要记录标记过程中的变化。有两种解决方法：</p>
<ol>
<li>Incremental Update 增量更新法，CMS 垃圾回收器采用<ul>
<li>思路是拦截每次赋值动作，只要赋值发生，被赋值的对象就会被记录下来，在重新标记阶段再确认一遍</li>
</ul>
</li>
<li>Snapshot At The Beginning，SATB 原始快照法，G1 垃圾回收器采用<ul>
<li>思路也是拦截每次赋值动作，不过记录的对象不同，也需要在重新标记阶段对这些对象二次处理</li>
<li>新加对象会被记录</li>
<li>被删除引用关系的对象也被记录</li>
</ul>
</li>
</ol>
<h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><h5 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h5><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220316113515282.png" alt="image-20220316113515282"></p>
<p>迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的默认新生 代收集器，有着优于其他收集器的地方，那就是简单而高效（与其他收集器的单线程相比），对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）[1]最小的</p>
<h5 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h5><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220316113853294.png" alt="image-20220316113853294"></p>
<h5 id="垃圾回收器-Parallel-GC"><a href="#垃圾回收器-Parallel-GC" class="headerlink" title="垃圾回收器 - Parallel GC"></a><strong>垃圾回收器 - Parallel GC</strong></h5><ul>
<li><p>eden 内存不足发生 Minor GC，采用标记复制算法，需要暂停用户线程</p>
</li>
<li><p>old 内存不足发生 Full GC，采用标记整理算法，需要暂停用户线程</p>
</li>
<li><p><strong>注重吞吐量</strong></p>
</li>
</ul>
<p><strong>垃圾回收器 - ConcurrentMarkSweep GC</strong></p>
<ul>
<li><p>它是工作在 old 老年代，支持<strong>并发标记</strong>的一款回收器，采用<strong>并发清除</strong>算法</p>
<ul>
<li>并发标记时不需暂停用户线程</li>
<li>重新标记时仍需暂停用户线程</li>
</ul>
</li>
<li><p>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</p>
</li>
<li><p><strong>注重响应时间</strong></p>
</li>
</ul>
<h5 id="垃圾回收器-G1-GC"><a href="#垃圾回收器-G1-GC" class="headerlink" title="垃圾回收器 - G1 GC"></a>垃圾回收器 - G1 GC</h5><ul>
<li><strong>响应时间与吞吐量兼顾</strong></li>
<li>划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备</li>
<li>分成三个阶段：新生代回收、并发标记、混合收集</li>
<li>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</li>
</ul>
<p>-XX:G1HeapRegionSize 设定区域大小</p>
<h3 id="面试题：项目什么情况下会内存溢出，怎么解决的"><a href="#面试题：项目什么情况下会内存溢出，怎么解决的" class="headerlink" title="面试题：项目什么情况下会内存溢出，怎么解决的"></a>面试题：项目什么情况下会内存溢出，怎么解决的</h3><p><strong>典型情况</strong></p>
<ul>
<li>误用线程池导致的内存溢出<ul>
<li>参考 day03.TestOomThreadPool</li>
</ul>
</li>
<li>查询数据量太大导致的内存溢出<ul>
<li>参考 day03.TestOomTooManyObject</li>
</ul>
</li>
<li>动态生成类导致的内存溢出<ul>
<li>参考 day03.TestOomTooManyClass</li>
</ul>
</li>
</ul>
<h3 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h3><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220316183823997.png" alt="image-20220316183823997"></p>
<h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><ol>
<li><p>加载</p>
<ol>
<li><p>将类的字节码载入方法区，并创建类.class 对象</p>
</li>
<li><p>如果此类的父类没有加载，先加载父类</p>
</li>
<li><p>加载是懒惰执行</p>
</li>
</ol>
</li>
<li><p>链接</p>
<ol>
<li>验证 – 验证类是否符合 Class 规范，合法性、安全性检查</li>
<li>准备 – 为 static 变量分配空间，设置默认值</li>
<li>解析 – 将常量池的符号引用解析为直接引用</li>
</ol>
</li>
<li><p>初始化</p>
<ol>
<li>静态代码块、static 修饰的变量赋值、static final 修饰的引用类型变量赋值，会被合并成一个 <code>&lt;cinit&gt;</code> 方法，在初始化时被调用</li>
<li>static final 修饰的基本类型变量赋值，在链接阶段就已完成</li>
<li>初始化是懒惰执行</li>
</ol>
</li>
</ol>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220317101838367.png" alt="image-20220317101838367"></p>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220317105643388.png" alt="image-20220317105643388"></p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 首先，检查请求的类是否已经被加载过了 </span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name); </span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123; </span><br><span class="line">                c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">             &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">             &#125;        </span><br><span class="line">             &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; </span><br><span class="line">             <span class="comment">// 如果父类加载器抛出ClassNotFoundException </span></span><br><span class="line">             <span class="comment">// 说明父类加载器无法完成加载请求</span></span><br><span class="line">             &#125; </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 在父类加载器无法加载时 </span></span><br><span class="line">            <span class="comment">// 再调用本身的findClass方法来进行类加载 </span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">             &#125;</span><br><span class="line">     &#125; </span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123; </span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所谓的双亲委派，就是指优先委派上级类加载器进行加载，如果上级类加载器</p>
<ul>
<li>能找到这个类，由上级加载，加载后该类也对下级加载器可见</li>
<li>找不到这个类，则下级类加载器才有资格执行加载</li>
</ul>
<p>双亲委派的目的有两点</p>
<ol>
<li><p>让上级类加载器中的类对下级共享（反之不行），即能让你的类能依赖到 jdk 提供的核心类</p>
</li>
<li><p>让类的加载有优先次序，保证核心类优先加载</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
