<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="RedisRedis数据类型 StringString 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 512M。 内部实现内部采用SDS和int实现  应用场景 直接缓存整个对象的 JSON，命令例子： SET user:1 &#39;&amp;#123;&quot;nam">
<meta property="og:type" content="article">
<meta property="og:title" content="akurisu">
<meta property="og:url" content="http://example.com/2022/07/30/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="akurisu">
<meta property="og:description" content="RedisRedis数据类型 StringString 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 512M。 内部实现内部采用SDS和int实现  应用场景 直接缓存整个对象的 JSON，命令例子： SET user:1 &#39;&amp;#123;&quot;nam">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220808110832693.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220808105717390.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220808194020899.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220808120047468.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220808120529975.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220808120545981.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220808132154707.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220808122633895.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/f46cbe347f65ded522f1cc3fd8dba549.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/4d2dc376b5fd68dae70d9284ae82b73a.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/c5fb0a602d4caaca37ff0357f05b0abf.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220715093023899.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220715093108737.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220324193934603.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220723094825571.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220723095842950.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220719093109827.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220719093138974.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220719094753392.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220719094906627.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220719095054114.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/202105270918298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70#pic_center">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220721080705435.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220721080829984.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220721081355956.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220318153604522.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220328085422484.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220318145732696.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220421140709273.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220724075603496.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220723184351706.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220723184518103.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220723185132753.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220724072855513.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220724073033117.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220724073649081.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220724074041209.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220724080758005.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220724081138586.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220812094124513.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220519102745874.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220322100227889.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220528155203737.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220528155232603.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220519111841066.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220525153937993.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220522194306979.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220807094226788.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220522200801731.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220807102539309.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220315164232268.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220528203537611.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220317143558133.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220317143547828.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220317143612879.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210901112157901.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220815144915712.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220508160355202.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831215016566.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831215033510.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831215105280.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831215146276.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831215158311.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831211008162.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831211641241.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831212125813.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220528181312681.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220528181746538.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220528181928513.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220528182156806.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220528182333168.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220528182416937.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220528182613800.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220528183751168.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220529124640256.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE/image-20211021201630363.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220403142212814.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220730114554571.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220403202731069.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220403202737106.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220817112549978.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220817112645364.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220817112700752.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220729080301788.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220728115002308.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220812082435159.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220807082301849.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831084325075.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831084723383.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831084855348.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831085329449.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831085543224.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220322111243513.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220812150731267.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220313185422470.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220531115851184.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220818102503236.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329122500251.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329125857983.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220805131205112.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220330100416720.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329083907417.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329085636059.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220808093337518.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220531173501221.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220313162307775.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220716093807299.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220330100701382.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220730152312793.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220801153852073.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220731185057916.png">
<meta property="article:published_time" content="2022-07-30T02:29:50.563Z">
<meta property="article:modified_time" content="2022-08-18T04:29:54.832Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220808110832693.png">

<link rel="canonical" href="http://example.com/2022/07/30/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | akurisu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">akurisu</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/30/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-30 10:29:50" itemprop="dateCreated datePublished" datetime="2022-07-30T10:29:50+08:00">2022-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-18 12:29:54" itemprop="dateModified" datetime="2022-08-18T12:29:54+08:00">2022-08-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220808110832693.png" alt="image-20220808110832693"></p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 <code>512M</code>。</p>
<h4 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h4><p>内部采用SDS和int实现</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220808105717390.png" alt="image-20220808105717390"></p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>直接缓存整个对象的 JSON，命令例子： <code>SET user:1 &#39;&#123;&quot;name&quot;:&quot;xiaolin&quot;, &quot;age&quot;:18&#125;&#39;</code>。</li>
<li>采用将 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值，命令例子： <code>MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20</code>。</li>
<li>计算访问次数、点赞、转发、库存数量等等。</li>
<li>共享Session信息</li>
<li>实现分布式锁</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>List 列表是简单的字符串列表，<strong>按照插入顺序排序</strong>，可以从头部或尾部向 List 列表添加元素。</p>
<p>列表的最大长度为 <code>2^32 - 1</code>，也即每个列表支持超过 <code>40 亿</code>个元素。</p>
<h4 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h4><p>双向链表或者压缩列表</p>
<ul>
<li>如果列表的元素个数小于 <code>512</code> 个（默认值，可由 <code>list-max-ziplist-entries</code> 配置），列表每个元素的值都小于 <code>64</code> 字节（默认值，可由 <code>list-max-ziplist-value</code> 配置），Redis 会使用<strong>压缩列表</strong>作为 List 类型的底层数据结构；</li>
<li>如果列表的元素不满足上面的条件，Redis 会使用<strong>双向链表</strong>作为 List 类型的底层数据结构；</li>
</ul>
<p>Redis3.2使用quickList实现。</p>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>消息队列</p>
<ol>
<li>使用BRPOP阻塞式读取，保证再没有读取到的时候一直等待数据写入队列</li>
<li>实现重复消息的判断，每次手动为每条消息生成一个全局唯一的ID</li>
<li>保证消息的可靠，为了留存消息，List 类型提供了 <code>BRPOPLPUSH</code> 命令，这个命令的<strong>作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存</strong>。</li>
</ol>
<h4 id="应用场景的缺陷"><a href="#应用场景的缺陷" class="headerlink" title="应用场景的缺陷"></a>应用场景的缺陷</h4><p><strong>List 不支持多个消费者消费同一条消息</strong>，因为一旦消费者拉取一条消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费。</p>
<p>要实现一条消息可以被多个消费者消费，那么就要将多个消费者组成一个消费组，使得多个消费者可以消费同一条消息，但是 <strong>List 类型并不支持消费组的实现</strong>。</p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p>Hash 类型的底层数据结构是由<strong>压缩列表或哈希表</strong>实现的：</p>
<ul>
<li>如果哈希类型元素个数小于 <code>512</code> 个（默认值，可由 <code>hash-max-ziplist-entries</code> 配置），所有值小于 <code>64</code> 字节（默认值，可由 <code>hash-max-ziplist-value</code> 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构；</li>
<li>如果哈希类型元素不满足上面条件，Redis 会使用<strong>哈希表</strong>作为 Hash 类型的 底层数据结构。</li>
</ul>
<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li><p>缓存对象</p>
</li>
<li><p>购物车，用户id作为key，商品id为field，商品数量为value</p>
<p>涉及的命令如下：</p>
<ul>
<li>添加商品：<code>HSET cart:&#123;用户id&#125; &#123;商品id&#125; 1</code></li>
<li>添加数量：<code>HINCRBY cart:&#123;用户id&#125; &#123;商品id&#125; 1</code></li>
<li>商品总数：<code>HLEN cart:&#123;用户id&#125;</code></li>
<li>删除商品：<code>HDEL cart:&#123;用户id&#125; &#123;商品id&#125;</code></li>
<li>获取购物车所有商品：<code>HGETALL cart:&#123;用户id&#125;</code></li>
</ul>
<p>当前仅仅是将商品ID存储到了Redis 中，在回显商品具体信息的时候，还需要拿着商品 id 查询一次数据库，获取完整的商品的信息。</p>
</li>
</ol>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。</p>
<p>一个集合最多可以存储 <code>2^32-1</code> 个元素。概念和数学中个的集合基本类似，可以交集，并集，差集等等，所以 Set 类型除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。</p>
<h4 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h4><p>Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p>
<ul>
<li>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li>
<li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li>
</ul>
<h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li>点赞</li>
<li>共同关注，利用set的交集匀速那</li>
<li>抽奖活动，保证同一个用户不会中奖两次</li>
</ol>
<h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。</p>
<p>有序集合保留了集合不能有重复成员的特性（分值可以重复），但不同的是，有序集合中的元素可以排序。</p>
<h4 id="内部实现-2"><a href="#内部实现-2" class="headerlink" title="内部实现"></a>内部实现</h4><p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p>
<ul>
<li>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li>
<li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li>
</ul>
<h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li>排行榜。</li>
<li>电话、姓名排序。</li>
</ol>
<h3 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h3><p>Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap通过最小的单位bit来进行<code>0|1</code>的设置，表示某个元素的值或者状态，时间复杂度为O(1)。</p>
<p>由于 bit 是计算机中最小的单位，使用它进行储存将非常节省空间，特别适合一些数据量大且使用<strong>二值统计的场景</strong>。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220808194020899.png" alt="image-20220808194020899"></p>
<h4 id="内部实现-3"><a href="#内部实现-3" class="headerlink" title="内部实现"></a>内部实现</h4><p>Bitmap 本身是用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。</p>
<p>String 类型是会保存为二进制的字节数组，所以，Redis 就把字节数组的每个 bit 位利用起来，用来表示一个元素的二值状态，你可以把 Bitmap 看作是一个 bit 数组。</p>
<h4 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li>签到统计</li>
<li>判断用户登陆态</li>
<li>连续签到用户总数</li>
</ol>
<h3 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h3><h4 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>百万级UV计数</li>
</ul>
<h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3><p>Redis GEO 是 Redis 3.2 版本新增的数据类型，主要用于存储地理位置信息，并对存储的信息进行操作。</p>
<p>在日常生活中，我们越来越依赖搜索“附近的餐馆”、在打车软件上叫车，这些都离不开基于位置信息服务（Location-Based Service，LBS）的应用。LBS 应用访问的数据是和人或物关联的一组经纬度信息，而且要能查询相邻的经纬度范围，GEO 就非常适合应用在 LBS 服务的场景中。</p>
<h4 id="应用场景-7"><a href="#应用场景-7" class="headerlink" title="应用场景"></a>应用场景</h4><h4 id="滴滴叫车"><a href="#滴滴叫车" class="headerlink" title="滴滴叫车"></a>滴滴叫车</h4><p>这里以滴滴叫车的场景为例，介绍下具体如何使用 GEO 命令：GEOADD 和 GEORADIUS 这两个命令。</p>
<p>假设车辆 ID 是 33，经纬度位置是（116.034579，39.030452），我们可以用一个 GEO 集合保存所有车辆的经纬度，集合 key 是 cars:locations。</p>
<p>执行下面的这个命令，就可以把 ID 号为 33 的车辆的当前经纬度位置存入 GEO 集合中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOADD cars:locations 116.034579 39.030452 33</span><br></pre></td></tr></table></figure>

<p>当用户想要寻找自己附近的网约车时，LBS 应用就可以使用 GEORADIUS 命令。</p>
<p>例如，LBS 应用执行下面的命令时，Redis 会根据输入的用户的经纬度信息（116.054579，39.030452 ），查找以这个经纬度为中心的 5 公里内的车辆信息，并返回给 LBS 应用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEORADIUS cars:locations 116.054579 39.030452 5 km ASC COUNT 10</span><br></pre></td></tr></table></figure>

<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>Redis Stream 是 Redis 5.0 版本新增加的数据类型，Redis 专门为消息队列设计的数据类型。</p>
<p>在 Redis 5.0 Stream 没出来之前，消息队列的实现方式都有着各自的缺陷，例如：</p>
<ul>
<li>发布订阅模式，不能持久化也就无法可靠的保存消息，并且对于离线重连的客户端不能读取历史消息的缺陷；</li>
<li>List 实现消息队列的方式不能重复消费，一个消息消费完就会被删除，而且生产者需要自行实现全局唯一 ID。</li>
</ul>
<p>基于以上问题，Redis 5.0 便推出了 Stream 类型也是此版本最重要的功能，用于完美地实现消息队列，它支持消息的持久化、支持自动生成全局唯一 ID、支持 ack 确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠。</p>
<h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><h3 id="SDS-简单动态字符串"><a href="#SDS-简单动态字符串" class="headerlink" title="SDS(简单动态字符串)"></a>SDS(简单动态字符串)</h3><h4 id="SDS-与-C-字符串的区别"><a href="#SDS-与-C-字符串的区别" class="headerlink" title="SDS 与 C 字符串的区别"></a>SDS 与 C 字符串的区别</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr&#123;</span><br><span class="line"> <span class="type">int</span> len; <span class="comment">//当前长度</span></span><br><span class="line"> <span class="type">int</span> free; <span class="comment">//未使用的长度</span></span><br><span class="line"> <span class="type">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>计数方式不同，可以O（1）的方式获取字符串的长度。</li>
<li>杜绝缓冲区溢出<ol>
<li>拼接的时候判断free是否能放下，长度够直接执行，不够扩容，而C语言则是遍历到结尾才进行扩容。</li>
</ol>
</li>
<li>减少修改字符串时带来的内存重分配次数<ol>
<li>当我们执行完一个字符串缩减的操作，redis并不会马上收回我们的空间，因为可以预防你继续添加的操作，这样可以减少分配空间带来的消耗，但是当你再次操作还是没用到多余空间的时候，Redis也还是会收回对于的空间，防止内存的浪费的。</li>
</ol>
</li>
<li>二进制安全<ol>
<li>解决中间有\0的问题</li>
</ol>
</li>
</ol>
<p>Redis 在编程上还<strong>使用了专门的编译优化来节省内存空间</strong>，即在 struct 声明了 <code>__attribute__ ((packed))</code> ，它的作用是：<strong>告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐</strong>。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>Redis封装了list的数据结构，使得操作更方便</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">//链表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//链表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值比较函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">//链表节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p>list 结构为链表提供了链表头指针 head、链表尾节点 tail、链表节点数量 len、以及可以自定义实现的 dup、free、match 函数。</p>
<p>举个例子，下面是由 list 结构和 3 个 listNode 结构组成的链表。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220808120047468.png" alt="image-20220808120047468"></p>
<h4 id="链表的优势与缺陷"><a href="#链表的优势与缺陷" class="headerlink" title="链表的优势与缺陷"></a>链表的优势与缺陷</h4><p>Redis 的链表实现优点如下：</p>
<ul>
<li>listNode 链表节点的结构里带有 prev 和 next 指针，<strong>获取某个节点的前置节点或后置节点的时间复杂度只需O(1)，而且这两个指针都可以指向 NULL，所以链表是无环链表</strong>；</li>
<li>list 结构因为提供了表头指针 head 和表尾节点 tail，所以**获取链表的表头节点和表尾节点的时间复杂度只需O(1)**；</li>
<li>list 结构因为提供了链表节点数量 len，所以**获取链表中的节点数量的时间复杂度只需O(1)**；</li>
<li>listNode 链表节使用 void* 指针保存节点值，并且可以通过 list 结构的 dup、free、match 函数指针为节点设置该节点类型特定的函数，因此<strong>链表节点可以保存各种不同类型的值</strong>；</li>
</ul>
<p>链表的缺陷也是有的：</p>
<ul>
<li>链表每个节点之间的内存都是不连续的，意味着<strong>无法很好利用 CPU 缓存</strong>。能很好利用 CPU 缓存的数据结构就是数组，因为数组的内存是连续的，这样就可以充分利用 CPU 缓存来加速访问。</li>
<li>还有一点，保存一个链表节点的值都需要一个链表节点结构头的分配，<strong>内存开销较大</strong>。</li>
</ul>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>压缩列表的最大特点，就是它被设计成一种内存紧凑型的数据结构，占用一块连续的内存空间，不仅可以利用 CPU 缓存，而且会针对不同长度的数据，进行相应编码，这种方法可以有效地节省内存开销。</p>
<p>但是，压缩列表的缺陷也是有的：</p>
<ul>
<li>不能保存过多的元素，否则查询效率就会降低；</li>
<li>新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题。</li>
</ul>
<h4 id="压缩列表结构设计"><a href="#压缩列表结构设计" class="headerlink" title="压缩列表结构设计"></a>压缩列表结构设计</h4><p>压缩列表是 Redis 为了节约内存而开发的，它是<strong>由连续内存块组成的顺序型数据结构</strong>，有点类似于数组。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220808120529975.png" alt="image-20220808120529975"></p>
<p>压缩列表在表头有三个字段：</p>
<ul>
<li><em><strong>zlbytes</strong></em>，记录整个压缩列表占用对内存字节数；</li>
<li><em><strong>zltail</strong></em>，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；</li>
<li><em><strong>zllen</strong></em>，记录压缩列表包含的节点数量；</li>
<li><em><strong>zlend</strong></em>，标记压缩列表的结束点，固定值 0xFF（十进制255）。</li>
</ul>
<p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而<strong>查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了，因此压缩列表不适合保存过多的元素</strong>。</p>
<p>另外，压缩列表节点（entry）的构成如下：</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220808120545981.png" alt="image-20220808120545981"></p>
<p>压缩列表节点包含三部分内容：</p>
<ul>
<li><em><strong>prevlen</strong></em>，记录了「前一个节点」的长度；</li>
<li><em><strong>encoding</strong></em>，记录了当前节点实际数据的类型以及长度；</li>
<li><em><strong>data</strong></em>，记录了当前节点的实际数据；</li>
</ul>
<p>当我们往压缩列表中插入数据时，压缩列表就会根据数据是字符串还是整数，以及数据的大小，会使用不同空间大小的 prevlen 和 encoding 这两个元素里保存的信息，<strong>这种根据数据大小和类型进行不同的空间大小分配的设计思想，正是 Redis 为了节省内存而采用的</strong>。</p>
<p>分别说下，prevlen 和 encoding 是如何根据数据的大小和类型来进行不同的空间大小分配。</p>
<p>压缩列表里的每个节点中的 prevlen 属性都记录了「前一个节点的长度」，而且 prevlen 属性的空间大小跟前一个节点长度值有关，比如：</p>
<ul>
<li>如果<strong>前一个节点的长度小于 254 字节</strong>，那么 prevlen 属性需要用 <strong>1 字节的空间</strong>来保存这个长度值；</li>
<li>如果<strong>前一个节点的长度大于等于 254 字节</strong>，那么 prevlen 属性需要用 <strong>5 字节的空间</strong>来保存这个长度值；</li>
</ul>
<p>encoding 属性的空间大小跟数据是字符串还是整数，以及字符串的长度有关：</p>
<ul>
<li>如果<strong>当前节点的数据是整数</strong>，则 encoding 会使用 <strong>1 字节的空间</strong>进行编码。</li>
<li>如果<strong>当前节点的数据是字符串，根据字符串的长度大小</strong>，encoding 会使用 <strong>1 字节&#x2F;2字节&#x2F;5字节的空间</strong>进行编码。</li>
</ul>
<h4 id="压缩列表的缺陷（连锁更新）"><a href="#压缩列表的缺陷（连锁更新）" class="headerlink" title="压缩列表的缺陷（连锁更新）"></a>压缩列表的缺陷（连锁更新）</h4><p><strong>压缩列表新增某个元素或修改某个元素时，如果空间不不够，压缩列表占用的内存空间就需要重新分配。而当新插入的元素较大时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起「连锁更新」问题，导致每个元素的空间都要重新分配，造成访问压缩列表性能的下降</strong>。</p>
<p>将一个长度大于等于254的节点插入表头，会导致后续节点prevLen进行扩容，导致连锁更新，使得性能变差。</p>
<h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p>Redis 只有 Zset 对象的底层实现用到了跳表，跳表的优势是能支持平均 O(logN) 复杂度的节点查找。</p>
<p>zset 结构体里有两个数据结构：一个是跳表，一个是哈希表。这样的好处是既能进行高效的范围查询，也能进行高效单点查询。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p>Zset 对象能支持范围查询（如 ZRANGEBYSCORE 操作），这是因为它的数据结构设计采用了跳表，而又能以常数复杂度获取元素权重（如 ZSCORE 操作），这是因为它同时采用了哈希表进行索引。</p>
<p>可能很多人会奇怪，为什么我开头说 Zset 对象的底层数据结构是「压缩列表」或者「跳表」，而没有说哈希表呢？</p>
<p>Zset 对象在使用跳表作为数据结构的时候，是使用由「哈希表+跳表」组成 zset 结构体，但是我们讨论的时候，都会说跳表是 Zset 对象的底层数据结构，而不会提及哈希表，是因为 zset 结构体中的哈希表只是用于以常数复杂度获取元素权重，大部分操作都是跳表实现的。</p>
<h4 id="跳表结构设计"><a href="#跳表结构设计" class="headerlink" title="跳表结构设计"></a>跳表结构设计</h4><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220808132154707.png" alt="image-20220808132154707"></p>
<p>这就需要看「跳表节点」的数据结构了，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//Zset 对象的元素值</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="comment">//元素权重值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">//后向指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//节点的level数组，保存每层上的前向指针和跨度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p>问题来了，由谁定义哪个跳表节点是头节点呢？这就介绍「跳表」结构体了，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<p>跳表结构里包含了：</p>
<ul>
<li>跳表的头尾节点，便于在O(1)时间复杂度内访问跳表的头节点和尾节点；</li>
<li>跳表的长度，便于在O(1)时间复杂度获取跳表节点的数量；</li>
<li>跳表的最大层数，便于在O(1)时间复杂度获取跳表中层高最大的那个节点的层数量；</li>
</ul>
<h4 id="跳表的查询过程"><a href="#跳表的查询过程" class="headerlink" title="跳表的查询过程"></a>跳表的查询过程</h4><p>查找一个跳表节点的过程时，跳表会从头节点的最高层开始，逐一遍历每一层。在遍历某一层的跳表节点时，会用跳表节点中的 SDS 类型的元素和元素的权重来进行判断，共有两个判断条件：</p>
<ul>
<li>如果当前节点的权重「小于」要查找的权重时，跳表就会访问该层上的下一个节点。</li>
<li>如果当前节点的权重「等于」要查找的权重时，并且当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点。</li>
</ul>
<p>如果上面两个条件都不满足，或者下一个节点为空时，跳表就会使用目前遍历到的节点的 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。</p>
<h4 id="跳表层数设置"><a href="#跳表层数设置" class="headerlink" title="跳表层数设置"></a>跳表层数设置</h4><p>跳表的相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O(logN)。</p>
<h4 id="跳表怎么维持相邻两层的节点的比例为2-1呢？"><a href="#跳表怎么维持相邻两层的节点的比例为2-1呢？" class="headerlink" title="跳表怎么维持相邻两层的节点的比例为2:1呢？"></a>跳表怎么维持相邻两层的节点的比例为2:1呢？</h4><p>Redis 则采用一种巧妙的方法是，<strong>跳表在创建节点的时候，随机生成每个节点的层数</strong>，并没有严格维持相邻两层的节点数量比例为 2 : 1 的情况。</p>
<p>具体的做法是，<strong>跳表在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong>。</p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>采用链式哈希的方式解决哈希冲突</p>
<h4 id="哈希表结构设计"><a href="#哈希表结构设计" class="headerlink" title="哈希表结构设计"></a>哈希表结构设计</h4><p>Redis 的哈希表结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">//哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;  </span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="comment">//该哈希表已有的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<p>可以看到，哈希表是一个数组（dictEntry **table），数组的每个元素是一个指向「哈希表节点（dictEntry）」的指针。</p>
<h4 id="哈希表rehash（扩容）"><a href="#哈希表rehash（扩容）" class="headerlink" title="哈希表rehash（扩容）"></a>哈希表rehash（扩容）</h4><p>Redis的哈希表里面有两个哈希表</p>
<p>在正常服务请求阶段，插入的数据，都会写入到「哈希表 1」，此时的「哈希表 2 」 并没有被分配空间。</p>
<p>随着数据逐步增多，触发了 rehash 操作，这个过程分为三步：</p>
<ul>
<li>给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍；</li>
<li>将「哈希表 1 」的数据迁移到「哈希表 2」 中；</li>
<li>迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备。</li>
</ul>
<p>采用渐进式的rehash</p>
<p>渐进式 rehash 步骤如下：</p>
<ul>
<li>给「哈希表 2」 分配空间；</li>
<li><strong>在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value 迁移到「哈希表 2」 上</strong>；</li>
<li>随着处理客户端发起的哈希表操作请求数量越多，最终在某个时间点会把「哈希表 1 」的所有 key-value 迁移到「哈希表 2」，从而完成 rehash 操作。</li>
</ul>
<p>在进行渐进式 rehash 的过程中，会有两个哈希表，所以在渐进式 rehash 进行期间，哈希表元素的删除、查找、更新等操作都会在这两个哈希表进行。</p>
<p>比如，查找一个 key 的值的话，先会在「哈希表 1」 里面进行查找，如果没找到，就会继续到哈希表 2 里面进行找到。</p>
<p>另外，在渐进式 rehash 进行期间，新增一个 key-value 时，会被保存到「哈希表 2 」里面，而「哈希表 1」 则不再进行任何添加操作，这样保证了「哈希表 1 」的 key-value 数量只会减少，随着 rehash 操作的完成，最终「哈希表 1 」就会变成空表。</p>
<h4 id="rehash触发条件"><a href="#rehash触发条件" class="headerlink" title="rehash触发条件"></a>rehash触发条件</h4><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220808122633895.png" alt="image-20220808122633895"></p>
<p>触发 rehash 操作的条件，主要有两个：</p>
<ul>
<li><strong>当负载因子大于等于 1 ，并且 Redis 没有在执行 bgsave 命令或者 bgrewiteaof 命令，也就是没有执行 RDB 快照或没有进行 AOF 重写的时候，就会进行 rehash 操作。</strong></li>
<li><strong>当负载因子大于等于 5 时，此时说明哈希冲突非常严重了，不管有没有有在执行 RDB 快照或 AOF 重写，都会强制进行 rehash 操作。</strong></li>
</ul>
<h3 id="整数数组"><a href="#整数数组" class="headerlink" title="整数数组"></a>整数数组</h3><p>整数集合是 Set 对象的底层实现之一。当一个 Set 对象只包含整数值元素，并且元素数量不大时，就会使用整数集这个数据结构作为底层实现。</p>
<h4 id="整数集合结构设计"><a href="#整数集合结构设计" class="headerlink" title="整数集合结构设计"></a>整数集合结构设计</h4><p>整数集合本质上是一块连续内存空间，它的结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">//编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>可以看到，保存元素的容器是一个 contents 数组，虽然 contents 被声明为 int8_t 类型的数组，但是实际上 contents 数组并不保存任何 int8_t 类型的元素，contents 数组的真正类型取决于 intset 结构体里的 encoding 属性的值。比如：</p>
<ul>
<li>如果 encoding 属性值为 INTSET_ENC_INT16，那么 contents 就是一个 int16_t 类型的数组，数组中每一个元素的类型都是 int16_t；</li>
<li>如果 encoding 属性值为 INTSET_ENC_INT32，那么 contents 就是一个 int32_t 类型的数组，数组中每一个元素的类型都是 int32_t；</li>
<li>如果 encoding 属性值为 INTSET_ENC_INT64，那么 contents 就是一个 int64_t 类型的数组，数组中每一个元素的类型都是 int64_t；</li>
</ul>
<p>不同类型的 contents 数组，意味着数组的大小也会不同。</p>
<h3 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h3><p>其实 quicklist 就是「双向链表 + 压缩列表」组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表。</p>
<p>quicklist 解决办法，<strong>通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。</strong></p>
<h4 id="quicklist-结构设计"><a href="#quicklist-结构设计" class="headerlink" title="quicklist 结构设计"></a>quicklist 结构设计</h4><p>quicklist 的结构体跟链表的结构体类似，都包含了表头和表尾，区别在于 quicklist 的节点是 quicklistNode。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    <span class="comment">//quicklist的链表头</span></span><br><span class="line">    quicklistNode *head;      <span class="comment">//quicklist的链表头</span></span><br><span class="line">    <span class="comment">//quicklist的链表头</span></span><br><span class="line">    quicklistNode *tail; </span><br><span class="line">    <span class="comment">//所有压缩列表中的总元素个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;</span><br><span class="line">    <span class="comment">//quicklistNodes的个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;       </span><br><span class="line">    ...</span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>

<p>接下来看看，quicklistNode 的结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//前一个quicklistNode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span>     <span class="comment">//前一个quicklistNode</span></span><br><span class="line">    <span class="comment">//下一个quicklistNode</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span>     <span class="comment">//后一个quicklistNode</span></span><br><span class="line">    <span class="comment">//quicklistNode指向的压缩列表</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;              </span><br><span class="line">    <span class="comment">//压缩列表的的字节大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;                </span><br><span class="line">    <span class="comment">//压缩列表的元素个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;        <span class="comment">//ziplist中的元素个数 </span></span><br><span class="line">    ....</span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure>

<p>可以看到，quicklistNode 结构体里包含了前一个节点和下一个节点指针，这样每个 quicklistNode 形成了一个双向链表。但是链表节点的元素不再是单纯保存元素值，而是保存了一个压缩列表，所以 quicklistNode 结构体里有个指向压缩列表的指针 *zl。</p>
<p>我画了一张图，方便你理解 quicklist 数据结构。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f46cbe347f65ded522f1cc3fd8dba549.png" alt="img"></p>
<p>在向 quicklist 添加一个元素的时候，不会像普通的链表那样，直接新建一个链表节点。而是会检查插入位置的压缩列表是否能容纳该元素，如果能容纳就直接保存到 quicklistNode 结构里的压缩列表，如果不能容纳，才会新建一个新的 quicklistNode 结构。</p>
<p>quicklist 会控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来规避潜在的连锁更新的风险，但是这并没有完全解决连锁更新的问题。</p>
<h3 id="listpack"><a href="#listpack" class="headerlink" title="listpack"></a>listpack</h3><p>quicklist 虽然通过控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来减少连锁更新带来的性能影响，但是并没有完全解决连锁更新的问题。</p>
<p>因为 quicklistNode 还是用了压缩列表来保存元素，压缩列表连锁更新的问题，来源于它的结构设计，所以要想彻底解决这个问题，需要设计一个新的数据结构。</p>
<p>于是，Redis 在 5.0 新设计一个数据结构叫 listpack，目的是替代压缩列表，它最大特点是 listpack 中每个节点<strong>不再包含前一个节点的长度了，压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患</strong>。</p>
<p><strong>我看了 Redis 的 Github，在最新 6.2 发行版本中，Redis Hash 对象、ZSet 对象的底层数据结构的压缩列表还未被替换成 listpack，而 Redis 的最新代码（还未发布版本）已经将所有用到压缩列表底层数据结构的 Redis 对象替换成 listpack 数据结构来实现，估计不久将来，Redis 就会发布一个将压缩列表为 listpack 的发行版本</strong>。</p>
<h4 id="listpack-结构设计"><a href="#listpack-结构设计" class="headerlink" title="listpack 结构设计"></a>listpack 结构设计</h4><p>listpack 采用了压缩列表的很多优秀的设计，比如还是用一块连续的内存空间来紧凑地保存数据，并且为了节省内存的开销，listpack 节点会采用不同的编码方式保存不同大小的数据。</p>
<p>我们先看看 listpack 结构：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4d2dc376b5fd68dae70d9284ae82b73a.png" alt="img"></p>
<p>listpack 头包含两个属性，分别记录了 listpack 总字节数和元素数量，然后 listpack 末尾也有个结尾标识。图中的 listpack entry 就是 listpack 的节点了。</p>
<p>每个 listpack 节点结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c5fb0a602d4caaca37ff0357f05b0abf.png" alt="img"></p>
<p>主要包含三个方面内容：</p>
<ul>
<li>encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码；</li>
<li>data，实际存放的数据；</li>
<li>len，encoding+data的总长度；</li>
</ul>
<p>可以看到，<strong>listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题</strong>。</p>
<h2 id="Redis数据结构-1"><a href="#Redis数据结构-1" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220715093023899.png" alt="image-20220715093023899"></p>
<p>Redis 对所有的键值对，有一个全局的 hash 表来存储。哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。Redis 解决哈希冲突的方式，就是链式哈希，对于链表的 on 的时间复杂度是不可以接收的。所以，Redis 会对哈希表做 rehash 操作。</p>
<ol>
<li>给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍； </li>
<li>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中； </li>
<li>释放哈希表 1 的空间。</li>
</ol>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220715093108737.png" alt="image-20220715093108737"></p>
<ol>
<li><ol>
<li></li>
</ol>
</li>
</ol>
<h2 id="Redis五大数据结构"><a href="#Redis五大数据结构" class="headerlink" title="Redis五大数据结构"></a>Redis五大数据结构</h2><p>string，list，hash，set，zset(sorted set)</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220324193934603.png" alt="image-20220324193934603"></p>
<p>String 简单动态字符串</p>
<p>list 双向链表，压缩列表</p>
<p>hash哈希表，压缩列表</p>
<p>sorted set跳表，压缩列表</p>
<p>set 哈希表，整形数组</p>
<h2 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a>Redis的应用场景</h2><p>缓存，排行榜系统，计数器应用，社交网络 赞&#x2F;踩、粉丝、共同好友&#x2F;喜好、推送、下拉刷新等是社交网站的必备功能，由于社交网站访问量通常比较大，而且传统的关系型数据不太适合保存 这种类型的数据，Redis提供的数据结构可以相对比较容易地实现这些功能。</p>
<h2 id="Redis和Memcached的相似与区别"><a href="#Redis和Memcached的相似与区别" class="headerlink" title="Redis和Memcached的相似与区别"></a>Redis和Memcached的相似与区别</h2><h3 id="相似"><a href="#相似" class="headerlink" title="相似"></a>相似</h3><ul>
<li>Redis和Memcached都是内存数据存储系统，都用作内存中的键值数据存储。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常高。</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>Redis 支持的数据类型更丰富（String、Hash、List、Set、ZSet），而 Memcached 只支持最简单的 key-value 数据类型；</li>
<li>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 没有持久化功能，数据全部存在内存之中，Memcached 重启或者挂掉后，数据就没了；</li>
<li>Redis 原生支持集群模式，Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；</li>
<li>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持；</li>
<li>Redis密钥最大长度2GB而Memcached最大长度250字节。</li>
</ul>
<h2 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h2><h3 id="Redis-是单线程吗？"><a href="#Redis-是单线程吗？" class="headerlink" title="Redis 是单线程吗？"></a>Redis 是单线程吗？</h3><p><strong>Redis 单线程指的是「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发生数据给客户端」这个过程是由一个线程（主线程）来完成的</strong>，这也是我们常说 Redis 是单线程的原因。</p>
<p>但是，<strong>Redis 程序并不是单线程的</strong>，Redis 在启动的时候，是会<strong>启动后台线程（BIO）</strong>的：</p>
<h3 id="Redis为什么单线程还那么快？"><a href="#Redis为什么单线程还那么快？" class="headerlink" title="Redis为什么单线程还那么快？"></a>Redis为什么单线程还那么快？</h3><ul>
<li>首先，单线程是指，Redis 的网络 IO和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程</li>
<li>Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。</li>
</ul>
<ol>
<li>首先，大部分操作内存中完成。</li>
<li>加上高效的数据结构，如哈希表和跳表。</li>
<li>Redis使用了单线程模型可以避免了多线程之间的竞争，省去多线程切换带来的时间和性能上的开销。</li>
<li>然后，Redis 采用了多路复用机制，使其在网络 IO操作中能并发处理大量的客户端请求，实现高吞吐率，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select&#x2F;epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</li>
</ol>
<h3 id="Redis-6-0-之前为什么使用单线程？"><a href="#Redis-6-0-之前为什么使用单线程？" class="headerlink" title="Redis 6.0 之前为什么使用单线程？"></a>Redis 6.0 之前为什么使用单线程？</h3><p><strong>CPU 并不是制约 Redis 性能表现的瓶颈所在</strong>，更多情况下是受到内存大小和网络I&#x2F;O的限制，所以 Redis 核心网络模型使用单线程并没有什么问题，如果你想要使用服务的多核CPU，可以在一台服务器上启动多个节点或者采用分片集群的方式。</p>
<p>使用了单线程后，可维护性高，多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，<strong>增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗</strong>。</p>
<h3 id="Redis-6-0-之后为什么引入了多线程？"><a href="#Redis-6-0-之后为什么引入了多线程？" class="headerlink" title="Redis 6.0 之后为什么引入了多线程？"></a>Redis 6.0 之后为什么引入了多线程？</h3><p>虽然 Redis 的主要工作（网络 I&#x2F;O 和执行命令）一直是单线程模型，但是<strong>在 Redis 6.0 版本之后，也采用了多个 I&#x2F;O 线程来处理网络请求</strong>，<strong>这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I&#x2F;O 的处理上</strong>。</p>
<p>所以为了提高网络请求处理的并行度，Redis 6.0 对于网络请求采用多线程来处理。**但是对于读写命令，Redis 仍然使用单线程来处理，*<em>所以大家*<em>不要误解</em></em> Redis 有多线程同时执行命令。</p>
<h2 id="Redis的多路复用是如何保证读写的顺序正确？"><a href="#Redis的多路复用是如何保证读写的顺序正确？" class="headerlink" title="*Redis的多路复用是如何保证读写的顺序正确？"></a>*Redis的多路复用是如何保证读写的顺序正确？</h2><p>Redis 会将每个客户端套接字都关联一个指令队列。客户端的指令通过队列来排队进行顺序处理，先到先服务</p>
<p>Redis-client 在操作的时候，会产生具有不同事件类型的 Socket。在服务端，有一段 I&#x2F;O 多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。</p>
<h2 id="Redis过期策略"><a href="#Redis过期策略" class="headerlink" title="Redis过期策略"></a>Redis过期策略</h2><h3 id="Redis过期的类别"><a href="#Redis过期的类别" class="headerlink" title="Redis过期的类别"></a>Redis过期的类别</h3><p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p>
<p>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p>
<ol>
<li><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
</ol>
<p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 。</p>
<p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p>
<h3 id="Redis怎么判断过期"><a href="#Redis怎么判断过期" class="headerlink" title="Redis怎么判断过期"></a>Redis怎么判断过期</h3><p>字典实际上是哈希表，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找。当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：</p>
<ul>
<li>如果不在，则正常读取键值；</li>
<li>如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。</li>
</ul>
<h3 id="Redis-是怎么实现惰性删除的？"><a href="#Redis-是怎么实现惰性删除的？" class="headerlink" title="Redis 是怎么实现惰性删除的？"></a>Redis 是怎么实现惰性删除的？</h3><p>Redis 的惰性删除策略由 db.c 文件中的 <code>expireIfNeeded</code> 函数实现，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 key 是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/* 删除过期键 */</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 如果 server.lazyfree_lazy_expire 为 1 表示异步删除，反之同步删除；</span></span><br><span class="line">    <span class="keyword">return</span> server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :</span><br><span class="line">                                         dbSyncDelete(db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redis 在访问或者修改 key 之前，都会调用 expireIfNeeded 函数对其进行检查，检查 key 是否过期：</p>
<ul>
<li>如果过期，则删除该 key，至于选择异步删除，还是选择同步删除，根据 <code>lazyfree_lazy_expire</code> 参数配置决定（Redis 4.0版本开始提供参数），然后返回 null 客户端；</li>
<li>如果没有过期，不做任何处理，然后返回正常的键值对给客户端；</li>
</ul>
<p>惰性删除的流程图如下：</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220723094825571.png" alt="image-20220723094825571"></p>
<h3 id="Redis-是怎么实现定期删除的？"><a href="#Redis-是怎么实现定期删除的？" class="headerlink" title="Redis 是怎么实现定期删除的？"></a>Redis 是怎么实现定期删除的？</h3><p>再回忆一下，定期删除策略的做法：<strong>每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</strong></p>
<p>在 Redis 中，默认每秒进行 10 次过期检查一次数据库，此配置可通过 Redis 的配置文件 redis.conf 进行配置，配置键为 hz 它的默认值是 hz 10。</p>
<p>接下来，详细说说 Redis 的定期删除的流程：</p>
<ol>
<li>从过期字典中随机抽取 20 个 key；</li>
<li>检查这 20 个 key 是否过期，并删除已过期的 key；</li>
<li>如果本轮检查的已过期 key 的数量，超过 5 个（20&#x2F;4），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。</li>
</ol>
<p>那 Redis 为了保证定期删除不会出现循环过度，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms。</p>
<h2 id="Redis内存淘汰机制"><a href="#Redis内存淘汰机制" class="headerlink" title="Redis内存淘汰机制"></a>Redis内存淘汰机制</h2><p>在 Redis 4.0 版本之前有 6 种策略，4.0 增加了 2种，主要新增了 LFU 算法。</p>
<ul>
<li>不进行淘汰的策略</li>
</ul>
<p>​         noevition，此策略不会对缓存的数据进行淘汰，当内存不够了就会报错，因此，如果真实数据集大小大于缓存容量，就不要使用此策略了。</p>
<ul>
<li><p>会进行淘汰的策略</p>
</li>
<li><ul>
<li>allkeys-random：随机删除</li>
<li>allkeys-lru：使用 LRU 算法进行筛选删除</li>
<li>allkeys-lfu：使用 LFU 算法进行筛选删除</li>
<li>volatile-random：随机删除</li>
<li>volatile-ttl：根据过期时间先后进行删除，越早过期的越先被删除</li>
<li>volatile-lru：使用 LRU 算法进行筛选删除</li>
<li>volatile-lfu：使用 LFU 算法进行筛选删除</li>
<li>在设置了过期时间的数据中筛选</li>
<li>在所有数据中筛选</li>
</ul>
</li>
</ul>
<p>以 volatile 开头的策略只针对设置了过期时间的数据，即使缓存没有被写满，如果数据过期也会被删除。</p>
<p>以 allkeys 开头的策略是针对所有数据的，如果数据被选中了，即使过期时间没到，也会被删除。当然，如果它的过期时间到了但未被策略选中，同样会被删除。</p>
<p>LFU的全称为Least Frequently Used，意思就是最不频繁使用，所以，LFU算法会淘汰掉使用频率最低的数据。如果存在相同使用频率的数据，则再根据使用时间间隔，将最久未使用的数据淘汰。</p>
<h3 id="如何修改-Redis-内存淘汰策略？"><a href="#如何修改-Redis-内存淘汰策略？" class="headerlink" title="如何修改 Redis 内存淘汰策略？"></a>如何修改 Redis 内存淘汰策略？</h3><p>设置内存淘汰策略有两种方法：</p>
<ul>
<li>方式一：通过“<code>config set maxmemory-policy &lt;策略&gt;</code>”命令设置。它的优点是设置之后立即生效，不需要重启 Redis 服务，缺点是重启 Redis 之后，设置就会失效。</li>
<li>方式二：通过修改 Redis 配置文件修改，设置“<code>maxmemory-policy &lt;策略&gt;</code>”，它的优点是重启 Redis 服务后配置不会丢失，缺点是必须重启 Redis 服务，设置才能生效。</li>
</ul>
<h3 id="Redis里LRU实现方式"><a href="#Redis里LRU实现方式" class="headerlink" title="Redis里LRU实现方式"></a>Redis里LRU实现方式</h3><p>Redis 实现的是一种<strong>近似 LRU 算法</strong>，目的是为了更好的节约内存，它的<strong>实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间</strong>。</p>
<p>当 Redis 进行内存淘汰时，会使用<strong>随机采样的方式来淘汰数据</strong>，它是随机取 5 个值（此值可配置），然后<strong>淘汰最久没有使用的那个</strong>。</p>
<p>Redis 实现的 LRU 算法的优点：</p>
<ul>
<li>不用为所有的数据维护一个大链表，节省了空间占用；</li>
<li>不用在每次数据访问时都移动链表项，提升了缓存的性能；</li>
</ul>
<p>但是 LRU 算法有一个问题，<strong>无法解决缓存污染问题</strong>，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染。</p>
<h3 id="Redis里LFU实现方式"><a href="#Redis里LFU实现方式" class="headerlink" title="Redis里LFU实现方式"></a>Redis里LFU实现方式</h3><p>LFU 算法相比于 LRU 算法的实现，多记录了「数据的访问频次」的信息。Redis 对象的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 24 bits，用于记录对象的访问信息</span></span><br><span class="line">    <span class="type">unsigned</span> lru:<span class="number">24</span>;  </span><br><span class="line">    ...</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>Redis 对象头中的 lru 字段，在 LRU 算法下和 LFU 算法下使用方式并不相同。</p>
<p><strong>在 LRU 算法中</strong>，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key。</p>
<p><strong>在 LFU 算法中</strong>，Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，低 8bit 存储 logc(Logistic Counter)。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220723095842950.png" alt="image-20220723095842950"></p>
<ul>
<li>ldt 是用来记录 key 的访问时间戳；</li>
<li>logc 是用来记录 key 的访问频次，它的值越小表示使用频率越低，越容易淘汰，每个新加入的 key 的logc 初始值为 5。</li>
</ul>
<p>注意，logc 并不是单纯的访问次数，而是访问频次（访问频率），因为 <strong>logc 会随时间推移而衰减的</strong>。</p>
<p>在每次 key 被访问时，会先对 logc 做一个衰减操作，衰减的值跟前后访问时间的差距有关系，如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大，这样实现的 LFU 算法是根据<strong>访问频率</strong>来淘汰数据的，而不只是访问次数。访问频率需要考虑 key 的访问是多长时间段内发生的。key 的先前访问距离当前时间越长，那么这个 key 的访问频率相应地也就会降低，这样被淘汰的概率也会更大。</p>
<p>对 logc 做完衰减操作后，就开始对 logc 进行增加操作，增加操作并不是单纯的 + 1，而是根据概率增加，如果 logc 越大的 key，它的 logc 就越难再增加。</p>
<p>所以，Redis 在访问 key 时，对于 logc 是这样变化的：</p>
<ol>
<li>先按照上次访问距离当前的时长，来对 logc 进行衰减；</li>
<li>然后，再按照一定概率增加 logc 的值</li>
</ol>
<p>redis.conf 提供了两个配置项，用于调整 LFU 算法从而控制 logc 的增长和衰减：</p>
<ul>
<li><code>lfu-decay-time</code> 用于调整 logc 的衰减速度，它是一个以分钟为单位的数值，默认值为1，lfu-decay-time 值越大，衰减越慢；</li>
<li><code>lfu-log-factor</code> 用于调整 logc 的增长速度，lfu-log-factor 值越大，logc 增长越慢。</li>
</ul>
<h2 id="Redis的同步机制"><a href="#Redis的同步机制" class="headerlink" title="Redis的同步机制"></a>Redis的同步机制</h2><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。</p>
<h2 id="Redis是怎么持久化的？服务主从数据怎么交互的？"><a href="#Redis是怎么持久化的？服务主从数据怎么交互的？" class="headerlink" title="Redis是怎么持久化的？服务主从数据怎么交互的？"></a>Redis是怎么持久化的？服务主从数据怎么交互的？</h2><p>RDB做镜像全量持久化，AOF做增量持久化。因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。</p>
<h2 id="Redis持久化策略"><a href="#Redis持久化策略" class="headerlink" title="Redis持久化策略"></a>Redis持久化策略</h2><p>Redis 共有三种数据持久化的方式：</p>
<ul>
<li><strong>AOF 日志</strong>：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；</li>
<li><strong>RDB 快照</strong>：将某一时刻的内存数据，以二进制的方式写入磁盘；</li>
<li><strong>混合持久化方式</strong>：Redis 4.0 新增的方式，集成了 AOF 和 RDB 的优点；</li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>Redis 在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220719093109827.png" alt="image-20220719093109827"></p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220719093138974.png" alt="image-20220719093138974"></p>
<h4 id="为什么先执行命令，再把数据写入日志呢？"><a href="#为什么先执行命令，再把数据写入日志呢？" class="headerlink" title="为什么先执行命令，再把数据写入日志呢？"></a>为什么先执行命令，再把数据写入日志呢？</h4><p>好处</p>
<ul>
<li><strong>避免额外的检查开销：</strong>因为如果先将写操作命令记录到 AOF 日志里，再执行该命令的话，如果当前的命令语法有问题，那么如果不进行命令语法检查，该错误的命令记录到 AOF 日志里后，Redis 在使用日志恢复数据时，就可能会出错。</li>
<li><strong>不会阻塞当前写操作命令的执行</strong>：因为当写操作命令执行成功后，才会将命令记录到 AOF 日志。</li>
</ul>
<p>风险</p>
<ul>
<li><strong>数据可能会丢失：</strong> 执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有丢失的风险。</li>
<li><strong>可能阻塞其他操作：</strong> 由于写操作命令执行成功后才记录到 AOF 日志，所以不会阻塞当前命令的执行，但因为 AOF 日志也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。</li>
</ul>
<h4 id="AOF-写回策略有几种？"><a href="#AOF-写回策略有几种？" class="headerlink" title="AOF 写回策略有几种？"></a>AOF 写回策略有几种？</h4><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220719094753392.png" alt="image-20220719094753392"></p>
<p>具体说说：</p>
<ol>
<li>Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区；</li>
<li>然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；</li>
<li>具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。</li>
</ol>
<p>Redis 提供了 3 种写回硬盘的策略，控制的就是上面说的第三步的过程。 在 Redis.conf 配置文件中的 appendfsync 配置项可以有以下 3 种参数可填：</p>
<ul>
<li><strong>Always</strong>，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</li>
<li><strong>Everysec</strong>，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</li>
<li><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220719094906627.png" alt="image-20220719094906627"></p>
<p>如果想要应用程序向文件写入数据后，能立马将数据同步到硬盘，就可以调用 <code>fsync()</code> 函数，这样内核就会将内核缓冲区的数据直接写入到硬盘，等到硬盘写操作完成后，该函数才会返回。</p>
<ul>
<li>Always 策略就是每次写入 AOF 文件数据后，就执行 fsync() 函数；</li>
<li>Everysec 策略就会创建一个异步任务来执行 fsync() 函数；</li>
<li>No 策略就是永不执行 fsync() 函数;</li>
</ul>
<h4 id="AOF-日志过大，会触发什么机制？"><a href="#AOF-日志过大，会触发什么机制？" class="headerlink" title="AOF 日志过大，会触发什么机制？"></a>AOF 日志过大，会触发什么机制？</h4><p>Redis 为了避免 AOF 文件越写越大，提供了 <strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p>
<p>AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。</p>
<p>举个例子，在没有使用重写机制前，假设前后执行了「<em>set name xiaolin</em>」和「<em>set name xiaolincoding</em>」这两个命令的话，就会将这两个命令记录到 AOF 文件。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220719095054114.png" alt="image-20220719095054114"></p>
<p>但是<strong>在使用重写机制后，就会读取 name 最新的 value（键值对） ，然后用一条 「set name xiaolincoding」命令记录到新的 AOF 文件</strong>，之前的第一个命令就没有必要记录了，因为它属于「历史」命令，没有作用了。这样一来，一个键值对在重写日志中只用一条命令就行了。</p>
<p>重写工作完成后，就会将新的 AOF 文件覆盖现有的 AOF 文件，这就相当于压缩了 AOF 文件，使得 AOF 文件体积变小了。</p>
<h4 id="重写机制原理"><a href="#重写机制原理" class="headerlink" title="重写机制原理"></a>重写机制原理</h4><p>Redis 的<strong>重写 AOF 过程是由后台子进程 *bgrewriteaof* 来完成的</strong>，这么做可以达到两个好处：</p>
<ul>
<li>子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程；</li>
<li>子进程带有主进程的数据副本（<em>数据副本怎么产生的后面会说</em>），这里使用子进程而不是线程，因为如果是使用线程，多线程之间会共享内存，那么在修改共享内存数据的时候，需要通过加锁来保证数据的安全，而这样就会降低性能。而使用子进程，创建子进程时，父子进程是共享内存数据的，不过这个共享的内存只能以只读的方式，而当父子进程任意一方修改了该共享内存，就会发生「写时复制」，于是父子进程就有了独立的数据副本，就不用加锁来保证数据安全。</li>
</ul>
<p>写时复制顾名思义，<strong>在发生写操作的时候，操作系统才会去复制物理内存</strong>，这样是为了防止 fork 创建子进程时，由于物理内存数据的复制时间过长而导致父进程长时间阻塞的问题。</p>
<p>当然，操作系统复制父进程页表的时候，父进程也是阻塞中的，不过页表的大小相比实际的物理内存小很多，所以通常复制页表的过程是比较快的。</p>
<p>如果此时<strong>主进程修改了已经存在 key-value，就会发生写时复制，注意这里只会复制主进程修改的物理内存数据，没修改物理内存还是与子进程共享的</strong>。</p>
<p>重写 AOF 日志过程中，如果主进程修改了已经存在 key-value，此时这个 key-value 数据在子进程的内存数据就跟主进程的内存数据不一致了，这时要怎么办呢？</p>
<p>为了解决这种数据不一致问题，Redis 设置了一个 <strong>AOF 重写缓冲区</strong>，这个缓冲区在创建 bgrewriteaof 子进程之后开始使用。</p>
<p>在重写 AOF 期间，当 Redis 执行完一个写命令之后，它会<strong>同时将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/202105270918298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>也就是说，在 bgrewriteaof 子进程执行 AOF 重写期间，主进程需要执行以下三个工作:</p>
<ul>
<li>执行客户端发来的命令；</li>
<li>将执行后的写命令追加到 「AOF 缓冲区」；</li>
<li>将执行后的写命令追加到 「AOF 重写缓冲区」；</li>
</ul>
<p>当子进程完成 AOF 重写工作（<em>扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志</em>）后，会向主进程发送一条信号，信号是进程间通讯的一种方式，且是异步的。</p>
<ul>
<li>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；</li>
<li>新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</li>
</ul>
<p>AOF 日志是后写日志（防止错误的命令记录到AOF日志里，避免恢复时额外的检查开销），记录的是具体的操作命令。</p>
<p>为什么重写机制可以把日志文件变小呢? 实际上，重写机制具有“多变一”功能。所谓的“多 变一”，也就是说，旧日志文件中的多条命令，在重写后的新日志中变成了一条命令。我们知道， AOF 文件是以追加的方式，逐一记录接收到的写命令的。当一个键值对被多条写命令反复修改时， AOF 文件会记录相应的多条命令。但是，在重写的时候，是根据这个键值对当前的最新状态，为它 生成对应的写入命令。这样一来，一个键值对在重写日志中只用一条命令就行了，而且，在日志恢 复时，只用执行这条命令，就可以直接完成这个键值对的写入了。 </p>
<p>AOF 重写会阻塞么？和 AOF 日志由主线程写回不同，重写过程是由后台子进程 bgrewriteaof  来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。我把重写的过程总结为<strong>“一个拷贝， 两处日志”</strong>。“一个拷贝”就是指，每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。 此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。 然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写 日志。“两处日志”又是什么呢？因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写 操作，<strong>第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。</strong>这样一来， 即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。而<strong>第二处日志，就是指新的 AOF  重写日志。</strong>这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到 拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以 保证数据库最新状态的记录。此时，我们就可以用新的 AOF 文件替代旧文件了。</p>
<h4 id="AOF日志阻塞"><a href="#AOF日志阻塞" class="headerlink" title="AOF日志阻塞"></a>AOF日志阻塞</h4><p>在AOF中，如果AOF缓冲区的文件同步策略为everysec，则在主线程中，命令写入aof_buf后调用操作系统write操作，write完成后主线程返回；fsysnc同步文件操作由专门的文件同步线程每秒调用一次。</p>
<p>这种做法的问题在于，如果硬盘负载过高，那么fsysnc操作可能会超过1s；如果Redis主线程持续高速向aof_buf写入命令，硬盘的负载可能会越来越大，IO资源消耗会更快。如果此时Redis异常退出，会导致数据丢失可能远超过1s。</p>
<p>为此，Redis的处理策略是这样的：主线程每次进行AOF会对比上次fsync成功的时间；如果距上次不到2s，主线程直接返回；如果超过2s，则主线程阻塞直到fsync同步完成。因此，如果系统硬盘负载过大导致fsync速度太慢，会导致Redis主线程的阻塞；此外，使用everysec配置，AOF最多可能丢失2s的数据，而不是1s。</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>如果AOF追加阻塞频繁发生，说明系统的硬盘负载太大；可以考虑更换IO速度更快的硬盘，或者通过IO监控分析工具对系统的IO负载进行分析，如iostat（系统级io）、iotop（io版的top）、pidstat等。</p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>Redis 提供了两个命令来生成 RDB 文件，分别是 <code>save</code> 和 <code>bgsave</code>，他们的区别就在于是否在「主线程」里执行：</p>
<ul>
<li>执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</li>
<li>执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞</strong>；</li>
</ul>
<p>RDB 文件的加载工作是在服务器启动时自动执行的，Redis 并没有提供专门用于加载 RDB 文件的命令。</p>
<h4 id="执行快照时，数据能被修改吗？"><a href="#执行快照时，数据能被修改吗？" class="headerlink" title="执行快照时，数据能被修改吗？"></a>执行快照时，数据能被修改吗？</h4><p>执行 bgsave 过程中，Redis 依然<strong>可以继续处理操作命令</strong>的，也就是数据是能被修改的。</p>
<p>那具体如何做到到呢？关键的技术就在于<strong>写时复制技术（Copy-On-Write, COW）。</strong></p>
<p>执行 bgsave 命令的时候，会通过 <code>fork()</code> 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220721080705435.png" alt="image-20220721080705435"></p>
<p>只有在发生修改内存数据的情况时，物理内存才会被复制一份。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220721080829984.png" alt="image-20220721080829984"></p>
<p>当主线程（父进程）对这些共享的内存数据也都是只读操作，那么，主线程（父进程）和 bgsave 子进程相互不影响。</p>
<p>但是，如果主线程（父进程）要<strong>修改共享数据里的某一块数据</strong>（比如键值对 <code>A</code>）时，就会发生写时复制，于是这块数据的<strong>物理内存就会被复制一份（键值对 <code>A&#39;</code>）</strong>，然后<strong>主线程在这个数据副本（键值对 <code>A&#39;</code>）进行修改操作</strong>。与此同时，<strong>bgsave 子进程可以继续把原来的数据（键值对 <code>A</code>）写入到 RDB 文件</strong>。</p>
<h3 id="RDB和AOF结合"><a href="#RDB和AOF结合" class="headerlink" title="RDB和AOF结合"></a>RDB和AOF结合</h3><p>如果想要开启混合日志</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure>

<p>当开启了混合持久化时，在 AOF 重写日志时，<code>fork</code> 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p>
<p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220721081355956.png" alt="image-20220721081355956"></p>
<p>RDB 记录的是某一时刻的数据，并不是操作,执行的是全量快照，也就是说，把内存中的所有数据都记录到磁盘中，Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。 save：在主线程中执行，会导致阻塞；bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了 主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。好了，这个时候，我们就可以通过 bgsave  命令来执行全量快照，这既提供了数据的可靠性保证，也避免了对 Redis 的性能影响。</p>
<p>为了快照而暂停写操作，肯定是不能接受的。所以这个时候，Redis 就会借助操作系统提供的 写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。简单来说，bgsave 子 进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取 主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些数据也都是读操作（例如 图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响。<strong>但是，如果主线程要修改一块数 据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本（键值对 C’）。</strong> 然后，主线程在这个数据副本上进行修改。同时，bgsave 子进程可以继续把原来的数据（键值对 C） 写入 RDB 文件。</p>
<h3 id="AOF和RDB混合使用方法"><a href="#AOF和RDB混合使用方法" class="headerlink" title="AOF和RDB混合使用方法"></a>AOF和RDB混合使用方法</h3><p>Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。简单来说，内存快照以一定的 频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。这样一来，快照不用很频 繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作， 也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。 如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势，颇有点“鱼和熊掌可以 兼得”的感觉，建议你在实践中用起来。</p>
<h3 id="AOF和RDB的优缺点"><a href="#AOF和RDB的优缺点" class="headerlink" title="AOF和RDB的优缺点"></a>AOF和RDB的优缺点</h3><p>RDB</p>
<p>优点</p>
<ol>
<li>体积更小：相同的数据量rdb数据比aof的小，因为rdb是紧凑型文件</li>
<li>恢复更快：因为rdb是数据的快照，基本上就是数据的复制，不用重新读取再写入内存</li>
<li>性能更高：父进程在保存rdb时候只需要fork一个子进程，无需父进程的进行其他io操作，也保证了服务器的性能。</li>
</ol>
<p>缺点</p>
<ol>
<li><p>故障丢失:因为rdb是全量的，我们一般是使用shell脚本实现30分钟或者1小时或者每天对redis进行rdb备份，（注，也可以是用自带的策略），但是最少也要5分钟进行一次的备份，所以当服务死掉后，最少也要丢失5分钟的数据。</p>
</li>
<li><p>耐久性差:相对aof的异步策略来说，因为rdb的复制是全量的，即使是fork的子进程来进行备份，当数据量很大的时候对磁盘的消耗也是不可忽视的，尤其在访问量很高的时候，fork的时间也会延长，导致cpu吃紧，耐久性相对较差。</p>
</li>
</ol>
<p>AOF</p>
<p>优点：</p>
<ol>
<li>数据保证：我们可以设置fsync策略，一般默认是everysec，也可以设置每次写入追加，所以即使服务死掉了，咱们也最多丢失一秒数据</li>
<li>自动缩小：当aof文件大小到达一定程度的时候，后台会自动的去执行aof重写，此过程不会影响主进程，重写完成后，新的写入将会写到新的aof中，旧的就会被删除掉。但是此条如果拿出来对比rdb的话还是没有必要算成优点，只是官网显示成优点而已。</li>
</ol>
<p>缺点：</p>
<ol>
<li>性能相对较差：它的操作模式决定了它会对redis的性能有所损耗</li>
<li>体积相对更大：尽管是将aof文件重写了，但是毕竟是操作过程和操作结果仍然有很大的差别，体积也毋庸置疑的更大。</li>
<li>恢复速度更慢：</li>
</ol>
<h2 id="Redis缓存穿透和缓存击穿和缓存雪崩"><a href="#Redis缓存穿透和缓存击穿和缓存雪崩" class="headerlink" title="Redis缓存穿透和缓存击穿和缓存雪崩"></a>Redis缓存穿透和缓存击穿和缓存雪崩</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>  缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中，通常出于容错的考虑，如果从存储层查不到数据则不写入缓存层，就会产生缓存穿透。</p>
<h4 id="后果"><a href="#后果" class="headerlink" title="后果"></a>后果</h4><p> 缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓 存保护后端存储的意义。缓存穿透问题可能会使后端存储负载加大，由于很多后端存储不具备高并发性，甚至可能造成后端存储宕掉。通常可以在程序中分别统计总调用 数、缓存层命中数、存储层命中数，如果发现大量存储层空命中，可能就是出现了缓存穿透问题。</p>
<h4 id="造成原因"><a href="#造成原因" class="headerlink" title="造成原因"></a>造成原因</h4><p> 造成缓存穿透的基本原因有两个。第一，自身业务代码或者数据出现问题，第二，一些恶意攻击、爬虫等造成大量空命中。</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><h5 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h5><p>缓存空</p>
<p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。</p>
<p>这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<p>缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。 例如过期时间设置为5分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据 </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">cacheValue</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line"><span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(cacheValue)) &#123; </span><br><span class="line">        <span class="comment">// 从存储中获取 </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">storageValue</span> <span class="operator">=</span> storage.get(key); cache.set(key, storageValue); </span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒) </span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="literal">null</span>) &#123; </span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">       &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 缓存非空 </span></span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h5><p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220318153604522.png" alt="image-20220318153604522"></p>
<p><strong>当一个元素加入布隆过滤器中的时候，会进行如下操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p><strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220328085422484.png" alt="image-20220328085422484"></p>
<h5 id="非法请求的限制"><a href="#非法请求的限制" class="headerlink" title="非法请求的限制"></a>非法请求的限制</h5><p>当有大量恶意请求访问不存在的数据的时候，也会发生缓存穿透，因此在 API 入口处我们要判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。</p>
<h5 id="缓存空对象和布隆过滤器的对比"><a href="#缓存空对象和布隆过滤器的对比" class="headerlink" title="缓存空对象和布隆过滤器的对比"></a>缓存空对象和布隆过滤器的对比</h5><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220318145732696.png" alt="image-20220318145732696"></p>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p>
<h5 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a><strong>解决方案：</strong></h5><ol>
<li>设置热点数据永远不过期，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；</li>
<li>加互斥锁，互斥锁参考代码如下：保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li>
</ol>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220421140709273.png" alt="image-20220421140709273"></p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>
<p>举个例子：系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。</p>
<p>还有一种缓存雪崩的场景是：<strong>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</strong> 这样的情况，有下面几种解决办法：</p>
<p>举个例子 ：秒杀开始 12 个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕</p>
<p>可以看到，发生缓存雪崩有两个原因：</p>
<ul>
<li>大量数据同时过期；</li>
<li>Redis 故障宕机；</li>
</ul>
<p>不同的诱因，应对的策略也会不同。</p>
<h4 id="有哪些解决办法？"><a href="#有哪些解决办法？" class="headerlink" title="有哪些解决办法？"></a>有哪些解决办法？</h4><p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li>服务熔断或请求限流机制；</li>
<li>构建 Redis 缓存高可靠集群；<ul>
<li>如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。</li>
</ul>
</li>
</ol>
<p><strong>针对热点缓存失效的情况：</strong></p>
<ol>
<li><p>均匀设置过期时间；</p>
<ul>
<li>如果要给缓存数据设置过期时间，应该避免将大量的数据设置成同一个过期时间。我们可以在对缓存数据设置过期时间时，<strong>给这些数据的过期时间加上一个随机数</strong>，这样就保证数据不会在同一时间过期。</li>
</ul>
</li>
<li><p>互斥锁；</p>
<ul>
<li>当业务线程在处理用户请求时，<strong>如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</strong>（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li>
<li>实现互斥锁的时候，最好设置<strong>超时时间</strong>，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。</li>
</ul>
</li>
<li><p>双 key 策略；</p>
<ul>
<li>我们对缓存数据可以使用两个 key，一个是<strong>主 key，会设置过期时间</strong>，一个是<strong>备 key，不会设置过期</strong>，它们只是 key 不一样，但是 value 值是一样的，相当于给缓存数据做了个副本。</li>
<li>当业务线程访问不到「主 key 」的缓存数据时，就直接返回「备 key 」的缓存数据，然后在更新缓存的时候，<strong>同时更新「主 key 」和「备 key 」的数据。</strong></li>
</ul>
</li>
<li><p>后台更新缓存；</p>
<ul>
<li>第一种方式，后台线程不仅负责定时更新缓存，而且也负责<strong>频繁地检测缓存是否有效</strong>，检测到缓存失效了，原因可能是系统紧张而被淘汰的，于是就要马上从数据库读取数据，并更新到缓存。</li>
<li>第二种方式，在业务线程发现缓存数据失效后（缓存数据被淘汰），<strong>通过消息队列发送一条消息通知后台线程更新缓存</strong>，后台线程收到消息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好。</li>
</ul>
</li>
</ol>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220724075603496.png" alt="image-20220724075603496"></p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220723184351706.png" alt="image-20220723184351706"></p>
<p>所有的数据修改只在主服务器上进行，然后将最新的数据同步给从服务器，这样就使得主从服务器的数据是一致的。</p>
<h3 id="第一次同步"><a href="#第一次同步" class="headerlink" title="第一次同步"></a>第一次同步</h3><p>比如，现在有服务器 A 和 服务器 B，我们在服务器 B 上执行下面这条命令：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 服务器 B 执行这条命令</span><br><span class="line">replicaof &lt;服务器 A 的 IP 地址&gt; &lt;服务器 A 的 Redis 端口号&gt;</span><br></pre></td></tr></table></figure>

<p>接着，服务器 B 就会变成服务器 A 的「从服务器」，然后与主服务器进行第一次同步。</p>
<p>主从服务器间的第一次同步的过程可分为三个阶段：</p>
<ul>
<li>第一阶段是建立链接、协商同步；</li>
<li>第二阶段是主服务器同步数据给从服务器；</li>
<li>第三阶段是主服务器发送新写操作命令给从服务器。</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220723184518103.png" alt="image-20220723184518103"></p>
<h4 id="第一阶段：建立链接、协商同步"><a href="#第一阶段：建立链接、协商同步" class="headerlink" title="第一阶段：建立链接、协商同步"></a><em>第一阶段：建立链接、协商同步</em></h4><p>执行了 replicaof 命令后，从服务器就会给主服务器发送 <code>psync</code> 命令，表示要进行数据同步。</p>
<p>psync 命令包含两个参数，分别是<strong>主服务器的 runID</strong> 和<strong>复制进度 offset</strong>。</p>
<ul>
<li>runID，每个 Redis 服务器在启动时都会自动生产一个随机的 ID 来唯一标识自己。当从服务器和主服务器第一次同步时，因为不知道主服务器的 run ID，所以将其设置为 “?”。</li>
<li>offset，表示复制的进度，第一次同步时，其值为 -1。</li>
</ul>
<p>主服务器收到 psync 命令后，会用 <code>FULLRESYNC</code> 作为响应命令返回给对方。</p>
<p>并且这个响应命令会带上两个参数：主服务器的 runID 和主服务器目前的复制进度 offset。从服务器收到响应后，会记录这两个值。</p>
<p>FULLRESYNC 响应命令的意图是采用<strong>全量复制</strong>的方式，也就是主服务器会把所有的数据都同步给从服务器。</p>
<p>所以，第一阶段的工作时为了全量复制做准备。</p>
<p>那具体怎么全量同步呀呢？我们可以往下看第二阶段。</p>
<h4 id="第二阶段：主服务器同步数据给从服务器"><a href="#第二阶段：主服务器同步数据给从服务器" class="headerlink" title="第二阶段：主服务器同步数据给从服务器"></a><em>第二阶段：主服务器同步数据给从服务器</em></h4><p>接着，主服务器会执行 bgsave 命令来生成 RDB 文件，然后把文件发送给从服务器。</p>
<p>从服务器收到 RDB 文件后，会先清空当前的数据，然后载入 RDB 文件。</p>
<p>这里有一点要注意，主服务器生成 RDB 这个过程是不会阻塞主线程的，因为 bgsave 命令是产生了一个子进程来做生成 RDB 文件的工作，是异步工作的，这样 Redis 依然可以正常处理命令。</p>
<p>但是，这期间的写操作命令并没有记录到刚刚生成的 RDB 文件中，这时主从服务器间的数据就不一致了。那么为了保证主从服务器的数据一致性，<strong>主服务器在下面这三个时间间隙中将收到的写操作命令，写入到 replication buffer 缓冲区里。</strong></p>
<ul>
<li>主服务器生成 RDB 文件期间；</li>
<li>主服务器发送 RDB 文件给从服务器期间；</li>
<li>「从服务器」加载 RDB 文件期间；</li>
</ul>
<h4 id="第三阶段：主服务器发送新写操作命令给从服务器"><a href="#第三阶段：主服务器发送新写操作命令给从服务器" class="headerlink" title="第三阶段：主服务器发送新写操作命令给从服务器"></a><em>第三阶段：主服务器发送新写操作命令给从服务器</em></h4><p>在主服务器生成的 RDB 文件发送完，从服务器加载完 RDB 文件后，然后将 replication buffer 缓冲区里所记录的写操作命令发送给从服务器，然后「从服务器」重新执行这些操作，至此主从服务器的数据就一致了。</p>
<p>至此，主从服务器的第一次同步的工作就完成了。</p>
<h3 id="当网络断开又恢复时发生了什么？"><a href="#当网络断开又恢复时发生了什么？" class="headerlink" title="当网络断开又恢复时发生了什么？"></a>当网络断开又恢复时发生了什么？</h3><p>如果此时断开的网络，又恢复正常了，要怎么继续保证主从服务器的数据一致性呢？</p>
<p>在 Redis 2.8 之前，如果主从服务器在命令同步时出现了网络断开又恢复的情况，从服务器就会和主服务器重新进行一次全量复制，很明显这样的开销太大了，必须要改进一波。</p>
<p>所以，从 Redis 2.8 开始，网络断开又恢复后，从主从服务器会采用<strong>增量复制</strong>的方式继续同步，也就是只会把网络断开期间主服务器接收到的写操作命令，同步给从服务器。</p>
<p>网络恢复后的增量复制过程如下图：</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220723185132753.png" alt="image-20220723185132753"></p>
<p>主要有三个步骤：</p>
<ul>
<li>从服务器在恢复网络后，会发送 psync 命令给主服务器，此时的 psync 命令里的 offset 参数不是 -1；</li>
<li>主服务器收到该命令后，然后用 CONTINUE 响应命令告诉从服务器接下来采用增量复制的方式同步数据；</li>
<li>然后主服务将主从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令。</li>
</ul>
<p>网络断开后，当从服务器重新连上主服务器时，从服务器会通过 psync 命令将自己的复制偏移量 slave_repl_offset 发送给主服务器，主服务器根据自己的 master_repl_offset 和 slave_repl_offset 之间的差距，然后来决定对从服务器执行哪种同步操作：</p>
<ul>
<li>如果判断出从服务器要读取的数据还在 repl_backlog_buffer 缓冲区里，那么主服务器将采用<strong>增量同步</strong>的方式；</li>
<li>相反，如果判断出从服务器要读取的数据已经不存在 repl_backlog_buffer 缓冲区里，那么主服务器将采用<strong>全量同步</strong>的方式。</li>
</ul>
<p>当主服务器在 repl_backlog_buffer 中找到主从服务器差异（增量）的数据后，就会将增量的数据写入到 replication buffer 缓冲区，这个缓冲区我们前面也提到过，它是缓存将要传播给从服务器的命令。</p>
<h3 id="怎么判断-redis-某个节点是否正常工作？"><a href="#怎么判断-redis-某个节点是否正常工作？" class="headerlink" title="怎么判断 redis 某个节点是否正常工作？"></a>怎么判断 redis 某个节点是否正常工作？</h3><p>redis 判断接点是否正常工作，基本都是通过互相的 ping-pong 心态检测机制，如果有一半以上的节点去 ping 一个节点的时候没有 pong 回应，集群就会认为这个节点挂掉了，会断开与这个节点的连接。</p>
<p>redis 主从节点发送的心态间隔是不一样的，而且作用也有一点区别：</p>
<ul>
<li>redis 主节点默认每隔 10 秒对从节点发送 ping 命令，判断从节点的存活性和连接状态，可通过参数repl-ping-slave-period控制发送频率。</li>
<li>redis 从节点每隔 1 秒发送 replconf ack{offset} 命令，给主节点上报自身当前的复制偏移量，目的是为了：<ul>
<li>实时监测主从节点网络状态；</li>
<li>上报自身复制偏移量， 检查复制数据是否丢失， 如果从节点数据丢失， 再从主节点的复制缓冲区中拉取丢失数据。</li>
</ul>
</li>
</ul>
<h3 id="主从复制架构中，过期key如何处理？"><a href="#主从复制架构中，过期key如何处理？" class="headerlink" title="主从复制架构中，过期key如何处理？"></a>主从复制架构中，过期key如何处理？</h3><p>主节点处理了一个key或者通过淘汰算法淘汰了一个key，这个时间主节点模拟一条del命令发送给从节点，从节点收到该命令后，就进行删除key的操作。</p>
<h3 id="主从复制中两个-Buffer-replication-buffer-、repl-backlog-buffer-有什么区别？"><a href="#主从复制中两个-Buffer-replication-buffer-、repl-backlog-buffer-有什么区别？" class="headerlink" title="主从复制中两个 Buffer(replication buffer 、repl backlog buffer)有什么区别？"></a>主从复制中两个 Buffer(replication buffer 、repl backlog buffer)有什么区别？</h3><p>replication buffer 、repl backlog buffer 区别如下：</p>
<ul>
<li>replication buffer 是在全量复制阶段会出现，<strong>主库会给每个新连接的从库，分配一个</strong> replication buffer；repl backlog buffer 是在增量复制阶段出现，<strong>一个主库只分配一个</strong>repl backlog buffer；</li>
<li>这两个 Buffer 都有大小限制的，当缓冲区满了之后。repl backlog buffer，因为是环形结构，会直接<strong>覆盖起始位置数据</strong>，replication buffer则会导致连接断开，删除缓存，从库重新连接，<strong>重新开始全量复制</strong>。</li>
</ul>
<h3 id="脑裂情况"><a href="#脑裂情况" class="headerlink" title="脑裂情况"></a>脑裂情况</h3><p>如果主节点的网络突然发生了问题，它与所有的从节点都失联了，但是此时的主节点和客户端的网络是正常的，这个客户端并不知道 redis 内部已经出现了问题，还在照样的向这个失联的主节点写数据（过程A），此时这些数据被旧主节点缓存到了缓冲区里，因为主从节点之间的网络问题，这些数据都是无法同步给从节点的。</p>
<p>这时，哨兵也发现主节点失联了，它就认为主节点挂了（但实际上主节点正常运行，只是网络出问题了），于是哨兵就会在从节点中选举出一个 leeder 作为主节点，这时集群就有两个主节点了 —— <strong>脑裂出现了</strong>。</p>
<p>这时候网络突然好了，哨兵因为之前已经选举出一个新主节点了，它就会把旧主节点降级为从节点（A），然后从节点（A）会向新主节点请求数据同步，<strong>因为第一次同步是全量同步的方式，此时的从节点（A）会清空掉自己本地的数据，然后再做全量同步。所以，之前客户端在过程 A 写入的数据就会丢失了，也就是集群产生脑裂数据丢失的问题</strong>。</p>
<h3 id="脑裂的解决方案"><a href="#脑裂的解决方案" class="headerlink" title="脑裂的解决方案"></a>脑裂的解决方案</h3><p>当主节点发现从节点下线或者通信超时的总数量小于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。</p>
<h4 id="主从复制的坑"><a href="#主从复制的坑" class="headerlink" title="主从复制的坑"></a>主从复制的坑</h4><ol>
<li>主从数据不一致<ol>
<li>原因，主库收到新的写命令后，会发送给从库。但是，主库并不会等到从库实际执行完命令后， 再把结果返回给客户端，而是主库自己在本地执行完命令后，就会向客户端返回结果了。如果从库 还没有执行主库同步过来的命令，主从库间的数据就不一致了。</li>
<li>解决方案们要尽量保证主从库间的网络连接状况良好，还可以开发一个外部程序来监控主从库间的复制进度。监控程序可以一直监控着从库的复制进度， 当从库的复制进度又赶上主库时，我们就允许客户端再次跟这些从库连接。</li>
</ol>
</li>
<li>读取到过期数据<ol>
<li>在惰性删除的情况下，如果直接查询从库的数据，不会执行删除，查到了过期的数据，在Redis3.2之后从库虽然不会删除但是会返回空值，解决了这个问题。</li>
</ol>
</li>
</ol>
<h2 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h2><h3 id="如何判断主节点真的故障了？"><a href="#如何判断主节点真的故障了？" class="headerlink" title="如何判断主节点真的故障了？"></a>如何判断主节点真的故障了？</h3><p>哨兵会每隔 1 秒给所有主从节点发送 PING 命令，当主从节点收到 PING 命令后，会发送一个响应命令给哨兵，这样就可以判断它们是否在正常运行。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220724072855513.png" alt="image-20220724072855513"></p>
<p>如果主节点或者从节点没有在规定的时间内响应哨兵的 PING 命令，哨兵就会将它们标记为「<strong>主观下线</strong>」。这个「规定的时间」是配置项 <code>down-after-milliseconds</code> 参数设定的，单位是毫秒。</p>
<h3 id="主客观节点下线"><a href="#主客观节点下线" class="headerlink" title="主客观节点下线"></a>主客观节点下线</h3><p>之所以针对「主节点」设计「主观下线」和「客观下线」两个状态，是因为有可能「主节点」其实并没有故障，可能只是因为主节点的系统压力比较大或者网络发送了拥塞，导致主节点没有在规定时间内响应哨兵的 PING 命令。</p>
<p>所以，为了减少误判的情况，哨兵在部署的时候不会只部署一个节点，而是用多个节点部署成<strong>哨兵集群</strong>（<em>最少需要三台机器来部署哨兵集群</em>），<strong>通过多个哨兵节点一起判断，就可以就可以避免单个哨兵因为自身网络状况不好，而误判主节点下线的情况</strong>。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低。</p>
<p>具体是怎么判定主节点为「客观下线」的呢？</p>
<p>当一个哨兵判断主节点为「主观下线」后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220724073033117.png" alt="image-20220724073033117"></p>
<p>当这个哨兵的赞同票数达到哨兵配置文件中的 quorum 配置项设定的值后，这时主节点就会被该哨兵标记为「客观下线」。</p>
<p>例如，现在有 3 个哨兵，quorum 配置的是 2，那么一个哨兵需要 2 张赞成票，就可以标记主节点为“客观下线”了。这 2 张赞成票包括哨兵自己的一张赞成票和另外两个哨兵的赞成票。</p>
<p>PS：quorum 的值一般设置为哨兵个数的二分之一加1，例如 3 个哨兵就设置 2。</p>
<p>哨兵判断完主节点客观下线后，哨兵就要开始在多个「从节点」中，选出一个从节点来做新主节点。</p>
<h3 id="主从故障转移"><a href="#主从故障转移" class="headerlink" title="主从故障转移"></a>主从故障转移</h3><p>主从故障转移操作包含以下四个步骤：</p>
<ul>
<li>第一步：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点。</li>
<li>第二步：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；</li>
<li>第三步：将新主节点的 IP 地址和信息，通过「发布者&#x2F;订阅者机制」通知给客户端；</li>
<li>第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点；</li>
</ul>
<h4 id="步骤一：选出新主节点"><a href="#步骤一：选出新主节点" class="headerlink" title="步骤一：选出新主节点"></a>步骤一：选出新主节点</h4><p>首先要把网络状态不好的从节点给过滤掉。首先把已经下线的从节点过滤掉，然后把以往网络连接状态不好的从节点也给过滤掉。</p>
<p>怎么判断从节点之前的网络连接状态不好呢？</p>
<p>Redis 有个叫 down-after-milliseconds * 10 配置项，其down-after-milliseconds 是主从节点断连的最大连接超时时间。如果在 down-after-milliseconds 毫秒内，主从节点都没有通过网络联系上，我们就可以认为主从节点断连了。如果发生断连的次数超过了 10 次，就说明这个从节点的网络状况不好，不适合作为新主节点。</p>
<p>至此，我们就把网络状态不好的从节点过滤掉了，接下来要对所有从节点进行三轮考察：<strong>优先级、复制进度、ID 号</strong>。在进行每一轮考察的时候，哪个从节点优先胜出，就选择其作为新主节点。</p>
<ul>
<li>第一轮考察：哨兵首先会根据从节点的优先级来进行排序，优先级越小排名越靠前，<ul>
<li>Redis 有个叫 slave-priority 配置项，可以给从节点设置优先级，每一台从节点的服务器配置不一定是相同的，我们可以根据服务器性能配置来设置从节点的优先级。</li>
</ul>
</li>
<li>第二轮考察：如果优先级相同，则查看复制的下标，哪个从「主节点」接收的复制数据多，哪个就靠前。<ul>
<li>什么是复制进度？主从架构中，主节点会将写操作同步给从节点，在这个过程中，主节点会用 master_repl_offset 记录当前的最新写操作在 repl_backlog_buffer 中的位置（如下图中的「主服务器已经写入的数据」的位置），而从节点会用 slave_repl_offset 这个值记录当前的复制进度（如下图中的「从服务器要读的位置」的位置）。</li>
<li>如果某个从节点的 slave_repl_offset 最接近 master_repl_offset，说明它的复制进度是最靠前的，于是就可以将它选为新主节点。</li>
</ul>
</li>
<li>第三轮考察：如果优先级和下标都相同，就选择从节点 ID 较小的那个。<ul>
<li>如果在第二轮考察中，发现有两个从节点优先级和复制进度都是一样的，那么就会进行第三轮考察，比较两个从节点的 ID 号，ID 号小的从节点胜出。</li>
<li>什么是 ID 号？每个从节点都有一个编号，这个编号就是 ID 号，是用来唯一标识从节点的。</li>
</ul>
</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220724073649081.png" alt="image-20220724073649081"></p>
<p>在发送 <code>SLAVEOF no one</code> 命令之后，哨兵 leader 会以每秒一次的频率向被升级的从节点发送 <code>INFO</code> 命令（没进行故障转移之前，<code>INFO</code> 命令的频率是每十秒一次），并观察命令回复中的角色信息，当被升级节点的角色信息从原来的 slave 变为 master 时，哨兵 leader 就知道被选中的从节点已经顺利升级为主节点了。</p>
<h4 id="步骤二：将从节点指向新主节点"><a href="#步骤二：将从节点指向新主节点" class="headerlink" title="步骤二：将从节点指向新主节点"></a>步骤二：将从节点指向新主节点</h4><p>当新主节点出现之后，哨兵 leader 下一步要做的就是，让已下线主节点属下的所有「从节点」指向「新主节点」，这一动作可以通过向「从节点」发送 <code>SLAVEOF</code> 命令来实现。</p>
<h4 id="步骤三：通知客户的主节点已更换"><a href="#步骤三：通知客户的主节点已更换" class="headerlink" title="步骤三：通知客户的主节点已更换"></a>步骤三：通知客户的主节点已更换</h4><p>经过前面一系列的操作后，哨兵集群终于完成主从切换的工作，那么新主节点的信息要如何通知给客户端呢？</p>
<p>这主要<strong>通过 Redis 的发布者&#x2F;订阅者机制来实现</strong>的。每个哨兵节点提供发布者&#x2F;订阅者机制，客户端可以从哨兵订阅消息。</p>
<p>哨兵提供的消息订阅频道有很多，不同频道包含了主从节点切换过程中的不同关键事件</p>
<p>客户端和哨兵建立连接后，客户端会订阅哨兵提供的频道。<strong>主从切换完成后，哨兵就会向 <code>+switch-master</code> 频道发布新主节点的 IP 地址和端口的消息，这个时候客户端就可以收到这条信息，然后用这里面的新主节点的 IP 地址和端口进行通信了</strong>。</p>
<p>通过发布者&#x2F;订阅者机制机制，有了这些事件通知，客户端不仅可以在主从切换后得到新主节点的连接信息，还可以监控到主从节点切换过程中发生的各个重要事件。这样，客户端就可以知道主从切换进行到哪一步了，有助于了解切换进度。</p>
<h4 id="步骤四：将旧主节点变为从节点"><a href="#步骤四：将旧主节点变为从节点" class="headerlink" title="步骤四：将旧主节点变为从节点"></a>步骤四：将旧主节点变为从节点</h4><p>故障转移操作最后要做的是，继续监视旧主节点，当旧主节点重新上线时，哨兵集群就会向它发送 <code>SLAVEOF</code> 命令，让它成为新主节点的从节点，如下图：</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220724074041209.png" alt="image-20220724074041209"></p>
<h2 id="数据库和缓存一致性"><a href="#数据库和缓存一致性" class="headerlink" title="数据库和缓存一致性"></a>数据库和缓存一致性</h2><h3 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220724080758005.png" alt="image-20220724080758005"></p>
<p><strong>写</strong> ：</p>
<ul>
<li>先更新 DB</li>
<li>然后直接删除 cache 。</li>
</ul>
<p><strong>读</strong> :</p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回</li>
<li>cache中读取不到的话，就从 DB 中读取数据返回</li>
<li>再把数据放到 cache 中。</li>
</ul>
<h3 id="Read-x2F-Write-Through-Pattern（读写穿透）"><a href="#Read-x2F-Write-Through-Pattern（读写穿透）" class="headerlink" title="Read&#x2F;Write Through Pattern（读写穿透）"></a>Read&#x2F;Write Through Pattern（读写穿透）</h3><p><strong>写（Write Through）：</strong></p>
<ul>
<li>先查 cache，cache 中不存在，直接更新 DB。</li>
<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（<strong>同步更新 cache 和 DB</strong>）。</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220724081138586.png" alt="image-20220724081138586"></p>
<p><strong>读(Read Through)：</strong></p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回 。</li>
<li>读取不到的话，先从 DB 加载，写入到 cache 后返回响应。</li>
</ul>
<h3 id="Write-Behind-Pattern（异步缓存写入）"><a href="#Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="Write Behind Pattern（异步缓存写入）"></a>Write Behind Pattern（异步缓存写入）</h3><p>Write Behind Pattern 和 Read&#x2F;Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 DB 的读写。</p>
<p>但是，两个又有很大的不同：<strong>Read&#x2F;Write Through 是同步更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为异步批量的方式来更新 DB。</strong></p>
<p>很明显，这种方式对数据一致性带来了更大的挑战，比如cache数据可能还没异步更新DB的话，cache服务可能就就挂掉了。</p>
<p>这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 InnoDB Buffer Pool 机制都用到了这种策略。</p>
<p>Write Behind Pattern 下 DB 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><h3 id="mybatis，他是怎么防止sql注入的"><a href="#mybatis，他是怎么防止sql注入的" class="headerlink" title="mybatis，他是怎么防止sql注入的"></a>mybatis，他是怎么防止sql注入的</h3><p>不管输入何种参数时，都可以防止sql注入，因为mybatis底层实现了预编译，底层通过prepareStatement预编译实现类对当前传入的sql进行了预编译，这样就可以防止sql注入了。</p>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="IOC基本原理"><a href="#IOC基本原理" class="headerlink" title="IOC基本原理"></a>IOC基本原理</h3><ol>
<li>谁控制谁：在之前的编码过程中，都是需要什么对象自己去创建什么对象，有程序员自己来控制对象，而有了IOC容器之后，就会变成由IOC容器来控制对象，</li>
<li>控制什么：在实现过程中所需要的对象及需要依赖的对象</li>
<li>什么是反转：在没有IOC容器之前我们都是在对象中主动去创建依赖的对象，这是正转的，而有了IOC之后，依赖的对象直接由IOC容器创建后注入到对象中，由主动创建变成了被动接受，这是反转</li>
<li>哪些方面被反转：依赖的对象</li>
</ol>
<h3 id="AOP基本原理"><a href="#AOP基本原理" class="headerlink" title="AOP基本原理"></a>AOP基本原理</h3><p>AOP：Aspect oriented programming 面向切面编程，AOP 是 OOP（面向对象编程）的一种延续。</p>
<p>AOP 另辟蹊径，提出横向抽取机制，将横切逻辑代码和业务逻辑代码分离，代码拆分比较容易，难的是如何在不改变原有业务逻辑的情况下，悄无声息的将横向逻辑代码应用 到原有的业务逻辑中，达到和原来一样的效果。</p>
<p>aop是ioc的一个扩展功能，先有的ioc,再有的aop,只是在ioc的整个流程中新增的一个扩展点而已：BeanPostProcessor<br>总：aop概念，应用场景，动态代理<br>分：<br>bean的创建过程中有一个步骤可以对bean进行扩展实现，aop本身就是一个扩展功能，所以在BeanPostProcessor的后置处理方法<br>中来进行实现<br>1、代理对象的创建过程(advice,切面，切点)<br>2、通过jdk或者cgib的方式来生成代理对象<br>3、在执行方法调用的时候，会调用到生戒的字节码文件中，直接回找到DynamicAdvisoredInterceptor类中的Jintercept方法，从此<br>方法开始执行<br>4、根据之前定义好的通知来生成拦截器链<br>5、从拦截器链中依次获取每一个通知开始进行执行，在执行过程中，为了方便找到下一个通知是哪个，会有一个<br>Invocationlnterceptor的对象，找的时候是从-1的位置一次开始查找并且执行的。●</p>
<h3 id="Spring事务失效的情况"><a href="#Spring事务失效的情况" class="headerlink" title="Spring事务失效的情况"></a>Spring事务失效的情况</h3><ol>
<li>数据库引擎不支持事务</li>
<li>没有被 Spring 管理，比如说impl里面不用@Service</li>
<li>方法不是 public 的</li>
<li>自身调用问题</li>
<li>数据源没有配置事务管理器</li>
<li>不支持事务</li>
<li>如果在加有事务的方法内，使用了try…catch…语句块对异常进行了捕获，而catch语句块没有throw new RuntimeExecption异常，事务也不会回滚。</li>
<li>异常类型错误，抛出的异常和指定的异常不同</li>
</ol>
<h3 id="autowired-和-resource区别"><a href="#autowired-和-resource区别" class="headerlink" title="@autowired 和@resource区别"></a>@autowired 和@resource区别</h3><p>（1）提供方：@Autowired是由org.springframework.beans.factory.annotation.Autowired提供，换句话说就是由Spring提供；@Resource是由javax.annotation.Resource提供，即J2EE提供，需要JDK1.6及以上。</p>
<p>（2）注入方式：@Autowired只按照byType 注入；@Resource默认按byName自动注入，也提供按照byType 注入；</p>
<p>（3）属性：@Autowired按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。@Resource有两个中重要的属性：name和type。name属性指定byName，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。需要注意的是，@Resource如果没有指定name属性，并且按照默认的名称仍然找不到依赖对象时， @Resource注解会回退到按类型装配。但一旦指定了name属性，就只能按名称装配了。</p>
<h3 id="Autowired有多个接口实现怎么办"><a href="#Autowired有多个接口实现怎么办" class="headerlink" title="@Autowired有多个接口实现怎么办"></a>@Autowired有多个接口实现怎么办</h3><ol>
<li>首先给对应的实现接口加上一个@Service(“名字”)</li>
<li>然后可以让接口生成的对象名字和beanName相同</li>
<li>或者可以使用@Qualifier注解进行一个标识</li>
</ol>
<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><h3 id="SpringMVC流程和原理"><a href="#SpringMVC流程和原理" class="headerlink" title="SpringMVC流程和原理"></a>SpringMVC流程和原理</h3><p>1、 用户发送请求至前端控制器DispatcherServlet。</p>
<p>2、 DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p>
<p>3、 处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p>
<p>4、 DispatcherServlet调用HandlerAdapter处理器适配器。</p>
<p>5、 HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器),Controller执行完成返回ModelAndView给DispatcherServlet</p>
<p>6、 DispatcherServlet将ModelAndView传给ViewReslover视图解析器, ViewReslover解析后返回具体View。</p>
<p>7、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）,DispatcherServlet响应用户。</p>
<h2 id="为什么有了Spring还要有SpringBoot？"><a href="#为什么有了Spring还要有SpringBoot？" class="headerlink" title="为什么有了Spring还要有SpringBoot？"></a>为什么有了Spring还要有SpringBoot？</h2><p>1、Spring Boot提供极其快速和简化的操作，让 Spring 开发者快速上手。</p>
<p>2、Spring Boot提供了 Spring 运行的默认配置。</p>
<p>3、Spring Boot为通用 Spring项目提供了很多非功能性特性。</p>
<p>SpringBoot加快了开发的速度，简化了Spring的配置，使得能够更专注于开发使用的代码而不是进行配置，做到了真正的开箱即用。</p>
<h2 id="SpringBoot自动装配的过程"><a href="#SpringBoot自动装配的过程" class="headerlink" title="SpringBoot自动装配的过程"></a>SpringBoot自动装配的过程</h2><p>位于META-INF目录下的spring.factortes文件存放相关组件的配置工厂类；@EnableAutoConfiguration核心配置注解里面有一个AutoConfigurationImportSelector（自动配置文件收集器），收集配置文件中的配置工厂类，然后SpringFactoriesLoader加载组件工程（抽象工厂模式）进行实例化，在spring上下文中生成bean，完成自动配置功能。</p>
<p>SpringBoot在启动的时候会调用run()方法，run()方法会刷新容器，刷新容器的时候，会扫描classpath下面的的包META-INF&#x2F;spring.factories文件，在这个文件中记录了好多的自动配置类，在刷新容器的时候会将这些自动配置类加载到容器中，然后在根据这些配置类中的条件注解，来判断是否将这些配置类在容器中进行实例化，这些条件主要是判断项目是否有相关jar包或是否引入了相关的bean。这样springboot就帮助我们完成了自动装配。</p>
<h2 id="SpringBoot注解有哪几种类型？"><a href="#SpringBoot注解有哪几种类型？" class="headerlink" title="SpringBoot注解有哪几种类型？"></a>SpringBoot注解有哪几种类型？</h2><ul>
<li>springboot中常用的注解主要可以分为三种：放入容器型注解、从容器中取出型注解和功能型注解。其中的放入容器型和从容器中取出型就是我们平时所说的控制反转和依赖注入的概念。</li>
</ul>
<h2 id="SpringBootApplication注解"><a href="#SpringBootApplication注解" class="headerlink" title="SpringBootApplication注解"></a>SpringBootApplication注解</h2><p>我们可以把 @SpringBootApplication看作是 @Configuration、@EnableAutoConfiguration、@ComponentScan 注解的集合。</p>
<ul>
<li>@EnableAutoConfiguration：启用 SpringBoot 的自动配置机制<ul>
<li>@AutoConfigurationPackage  记录标志类所在的包</li>
<li>@Import 分离主配置和从配置，推迟import解析工作</li>
</ul>
</li>
<li>@ComponentScan： 扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描该类所在的包下所有的类，排除所有的自动配置类。</li>
<li>@Configuration：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</li>
</ul>
<h2 id="什么是SpringCloud"><a href="#什么是SpringCloud" class="headerlink" title="什么是SpringCloud"></a>什么是SpringCloud</h2><p>我觉着SpringCloud就是一个分布式微服务架构的一站式解决方案，它提供了很多组件用来解决了分布式架构所带来的一些问题。我在之前工作里用过Eureka、Ribbon、Feign、Hystrix，Zuul这么几个组件。其中Eureka在整个微服务架构中充当注册中心的角色，服务提供者将自身信息注册到Eureka Server中，然后服务消费者就可以从Eureka Server中获取注册的服务提供者的信息，然后就可以向服务提供者发起调用了。Ribbon实现了客户端的负载均衡，它提供了轮询、轮询权重、随机等一些常用的负载均衡策略。Feign我理解的就是简化服务之间的调用，让我们调用远程接口就像在调用本地方法一样。Hystrix的主要功能就是服务熔断、降级和资源隔离，用来保护我们的调用链路，避免发生服务雪崩问题。Zuul在整个微服务架构中充当服务网关的角色，提供请求转发和过滤的功能，可以在服务网关中实现统一身份验证、统一跨域请求处理等功能。以上就是我对SpringCloud的一些简单理解。</p>
<h2 id="SpringBoot自动装配"><a href="#SpringBoot自动装配" class="headerlink" title="SpringBoot自动装配"></a>SpringBoot自动装配</h2><h4 id="什么是SpringBoot自动装配"><a href="#什么是SpringBoot自动装配" class="headerlink" title="什么是SpringBoot自动装配"></a>什么是SpringBoot自动装配</h4><p>在使用SpringBoot的时候，会自动将Bean装配到IOC容器中。例如我们在使用Redis数据库的时候，会引入依赖spring-boot-starter-data-redis。在引入这个依赖后，服务初始化的时候，会将操作Redis需要的组件注入到IoC容器中进行后续使用。</p>
<h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h2><h3 id="创建多线程的方式"><a href="#创建多线程的方式" class="headerlink" title="创建多线程的方式"></a>创建多线程的方式</h3><ol>
<li>继承Thread类。</li>
<li>实现Runnable接口。<ol>
<li>实现call()方法，并且回调可以拿到一个返回值，表示异步计算的结果。</li>
</ol>
</li>
<li>使用Callable和Future创建线程。</li>
<li>利用线程池创建线程。</li>
</ol>
<h3 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220812094124513.png" alt="image-20220812094124513"></p>
<ol>
<li>NEW 跟五种状态里的初始状态是一个意思，刚创建，还没有调用start()方法</li>
<li>RUNNABLE 是当调用了 <code>start()</code> 方法之后的状态，注意，Java API 层面的 <code>RUNNABLE</code> 状态涵盖了操作系统层面的<strong>【可运行状态】、【运行状态】和【阻塞状态】</strong>（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li>
<li><code>BLOCKED</code> ，线程阻塞于锁，两个线程抢占同一个锁，没抢到锁的就会进入到BLOCKED状态</li>
<li><code>WAITING</code> ， 调用wait()或者park()。</li>
<li><code>TIMED_WAITING</code>，调用了sleep()短暂睡眠，wait()。</li>
<li>TERMINATED终止状态。</li>
</ol>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>每个java对象都可以关联一个Monitor对象，如果使用<code>synchronized</code>给对象上锁（重量级），该对象头的Mark Word中就被设置为指向Monitor对象的指针</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220519102745874.png" alt="image-20220519102745874"></p>
<ul>
<li>刚开始时Monitor中的Owner为null</li>
<li>当Thread-2 执行synchronized(obj){}代码时就会将Monitor的所有者Owner 设置为 Thread-2，上锁成功，Monitor中同一时刻只能有一个Owner，MarkWord指向Monitor</li>
<li>当Thread-2 占据锁时，如果线程Thread-3，Thread-4也来执行synchronized(obj){}代码，就会进入EntryList中变成BLOCKED状态</li>
<li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争时是<strong>非公平的</strong></li>
<li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲wait-notify 时会分析</li>
</ul>
<blockquote>
<p>注意：synchronized 必 synchronized 的对象不会关联监视器，不遵从以上规则</p>
</blockquote>
<ul>
<li>轻量级锁 <strong>如果一个对象虽然有多个线程要对它进行加锁，但是加锁的时间是错开的</strong>（也就是没有人可以竞争的）</li>
<li>偏向锁，只有第一次使用CAS时将对象的Mark Word头设置为入锁线程ID，<strong>之后这个入锁线程再进行重入锁时，发现线程ID是自己的，那么就不用再进行CAS了</strong>,当调用hashcode的时候会禁用偏向锁。</li>
</ul>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><ol>
<li>每次指向到synchronized代码块时，都会创建锁记录（Lock Record）对象，每个线程都会包括一个锁记录的结构，锁记录内部可以储存对象的Mark Word和对象引用reference</li>
<li>让锁记录中的Object reference指向对象，并且尝试用cas(compare and sweep)替换Object对象的Mark Word ，将Mark Word 的值存入锁记录中</li>
<li>如果cas替换成功，那么对象的对象头储存的就是锁记录的地址和状态00，表示由该线程给对象加锁，</li>
<li>如果cas失败，有两种情况<ol>
<li>如果是其它线程已经持有了该Object的轻量级锁，那么表示有竞争，将进入<strong>锁膨胀</strong>阶段</li>
<li>如果是自己的线程已经执行了synchronized进行加锁，那么那么再添加一条 Lock Record 作为重入的计数，数据存的是null</li>
</ol>
</li>
<li>当线程退出synchronized代码块的时候，**如果获取的是取值为 null 的锁记录 **，表示有重入，这时重置锁记录，表示重入计数减一</li>
<li>当线程退出synchronized代码块的时候，如果获取的锁记录取值不为 null，那么使用<strong>cas</strong>将Mark Word的值恢复给对象<ol>
<li>成功则解锁成功</li>
<li>失败，则说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li>
</ol>
</li>
</ol>
<h3 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h3><ol>
<li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li>
<li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程<ol>
<li>即为对象申请Monitor锁，让Object指向重量级锁地址。</li>
<li>然后自己进入Monitor 的EntryList 变成BLOCKED状态</li>
</ol>
</li>
<li>当Thread-0 退出synchronized同步块时，使用<strong>CAS</strong>将Mark Word的值恢复给对象头，失败，那么会进入重量级锁的解锁过程，即按照Monitor的地址找到Monitor对象，将Owner设置为null，唤醒EntryList 中的Thread-1线程</li>
</ol>
<h3 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h3><ul>
<li>synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”。</li>
<li>synchronized修饰静态方法，实际上是对该类对象加锁，俗称“类锁”。</li>
</ul>
<h3 id="synchronized和ReentrantLock"><a href="#synchronized和ReentrantLock" class="headerlink" title="synchronized和ReentrantLock"></a>synchronized和ReentrantLock</h3><h4 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h4><p> 1.都是用来协调<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020">多线程</a>对共享对象、变量的访问</p>
<p> 2.都是可<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%87%8D%E5%85%A5%E9%94%81&spm=1001.2101.3001.7020">重入锁</a>，同一线程可以多次获得同一个锁</p>
<p> 3.都保证了可见性和互斥性</p>
<h4 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h4><ol>
<li><p>ReentrantLock显示地获得，释放锁，synchronized隐式获得释放锁</p>
</li>
<li><p>ReentrantLock可响应中断，可轮回，synchronized是不可以响应中断的</p>
</li>
<li><p>ReentrantLock是API级别的，synchronized是JVM级别的</p>
</li>
<li><p>ReentrantLock可以实现公平锁</p>
</li>
<li><p>ReentrantLock通过Condition可以绑定多个条件</p>
</li>
<li><p>底层实现不一样，synchronized是同步阻塞，使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略。</p>
</li>
<li><p>Lock是一个接口，而synchronized是java中的关键字，synchronized是内置的语言实现</p>
</li>
<li><p>synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象， 因此使用 Lock 时需要在 finally 块中释放锁。</p>
</li>
</ol>
<h3 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h3><p>volatile关键字不能保证线程安全，因为volatile不能保证原子性，仍然可能出现多线程争抢的情况。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p><strong>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</strong></p>
<p>线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程 发出了（其对共享变量所做修改的）消息。 </p>
<p>线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息。 </p>
<p><strong>线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。</strong></p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则<strong>确保 volatile写之前的操作不会被编译器重排序到volatile写之后。</strong></p>
<p>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则<strong>确保 volatile读之后的操作不会被编译器重排序到volatile读之前。</strong></p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220322100227889.png" alt="image-20220322100227889"></p>
<p>这里比较有意思的是，volatile写后面的StoreLoad屏障。此屏障的作用是避免volatile写与 后面可能有的volatile读&#x2F;写操作重排序。因为编译器常常无法准确判断在一个volatile写的后面是否需要插入一个StoreLoad屏障（比如，一个volatile写之后方法立即return）。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220528155203737.png" alt="image-20220528155203737"></p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220528155232603.png" alt="image-20220528155232603"></p>
<h2 id="run-和start-的区别"><a href="#run-和start-的区别" class="headerlink" title="run()和start()的区别"></a>run()和start()的区别</h2><ul>
<li>用 start方法来启动线程，是真正实现了多线程， 通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法。但要注意的是，此时无需等待run()方法执行完毕，即可继续执行下面的代码。所以run()方法并没有实现多线程。</li>
<li><strong>run()方法只是类的一个普通方法而已</strong>，如果直接调用run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码。</li>
</ul>
<p>1、start方法用来启动相应的线程；</p>
<p>2、run方法只是thread的一个普通方法，在主线程里执行；</p>
<p>3、需要并行处理的代码放在run方法中，start方法启动线程后自动调用run方法；</p>
<p>4、run方法必去是public的访问权限，返回类型为void。</p>
<h2 id="notify和notifyall的区别"><a href="#notify和notifyall的区别" class="headerlink" title="notify和notifyall的区别"></a>notify和notifyall的区别</h2><p>notify()<br>唤醒正在等待此对象监视器的单个线程。 如果有多个线程在等待，则选择其中一个随机唤醒（由调度器决定），唤醒的线程享有公平竞争资源的权利<br>notifyAll()<br>唤醒正在等待此对象监视器的所有线程，唤醒的所有线程公平竞争资源</p>
<h2 id="wait-vs-sleep"><a href="#wait-vs-sleep" class="headerlink" title="wait vs sleep"></a>wait vs sleep</h2><p><strong>一个共同点，三个不同点</strong></p>
<p>共同点</p>
<ul>
<li>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</li>
<li>它们都可以被打断唤醒</li>
</ul>
<p>不同点</p>
<ul>
<li>方法归属不同<ul>
<li>sleep(long) 是 Thread 的静态方法</li>
<li>而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有</li>
</ul>
</li>
<li>锁特性不同（重点）<ul>
<li>wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制</li>
<li>wait 方法<strong>执行后会释放对象锁</strong>，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）</li>
<li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）</li>
</ul>
</li>
<li>wait如果不加具体时间需要手动唤醒，让其退出wait set，而sleep必须添加休眠时间，时间结束后，自动退出阻塞状态。</li>
<li>wait需要在同步方法中使用，而sleep不会。</li>
</ul>
<h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><ol>
<li>调用 sleep 会让当前线程从 <strong>Running</strong> 进入 <strong>Timed Waiting</strong> 状态（阻塞）</li>
<li>其它线程可以使用 <strong>interrupt 方法</strong>打断正在睡眠的线程，那么被打断的线程这时就会抛出 <code>InterruptedException</code>异常【注意：这里打断的是正在休眠的线程，而不是其它状态的线程】</li>
<li>睡眠结束后的线程未必会立刻得到执行(需要分配到cpu时间片)</li>
<li>建议用 TimeUnit 的 <code>sleep()</code> 代替 Thread 的 <code>sleep()</code>来获得更好的可读性</li>
</ol>
<h2 id="Runnable-和-Callable-有什么区别？"><a href="#Runnable-和-Callable-有什么区别？" class="headerlink" title="Runnable 和 Callable 有什么区别？"></a>Runnable 和 Callable 有什么区别？</h2><ol>
<li>Runnable 接口中的 run() 方法的返回值是 void，它做的事情只是纯粹地去执行 run() 方法中的代码而已；</li>
<li>Callable 接口中的 call() 方法是有返回值的，是一个泛型，和 Future、FutureTask 配合可以用来获取异步执行的结果。</li>
</ol>
<p>Runnable 自 Java 1.0 以来一直存在，但 Callable 仅在 Java 1.5 中引入,目的就是为了来处理 Runnable 不支持的用例。Runnable 接口不会返回结果或抛出检查异常，但是<strong>Callable 接口</strong>可以。所以， 如果任务不需要返回结果或抛出异常推荐使用 Runnable 接口，这样代码看起来会更加简洁。 </p>
<p>工具类 Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换。（Executors.callable （Runnable task）或 Executors.callable（Runnable task，Object resule））。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被线程执行，没有返回值也无法抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Callable.java</span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算结果，或在无法这样做时抛出异常。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 计算得出的结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait notify"></a>wait notify</h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220519111841066.png" alt="image-20220519111841066"></p>
<ul>
<li>Owner线程发现条件不满足，调用wait方法，即可进入WaitSet变为WAITING状态</li>
<li>BLOCKED和WAITING的线程都处于阻塞状态，不占用时间片</li>
<li>BLOCKED线程会在Owner线程释放锁时唤醒</li>
<li>WAITING线程会在Owner线程调用notify或notifyAll时唤醒，但唤醒后并不意味着立刻获得锁，仍需进入EntryList重新竞争</li>
</ul>
<h2 id="lock和synchronized的区别"><a href="#lock和synchronized的区别" class="headerlink" title="lock和synchronized的区别"></a>lock和synchronized的区别</h2><ul>
<li>lock是java的一个接口，synchronized是一个关键字</li>
<li>synchronized遇到异常时候会自动释放锁，而lock必须手动释放锁，一般在finally里加unlock()</li>
<li>synchronized只支持非公平锁，而lock既支持公平锁也支持非公平锁</li>
<li>synchronized采用的是monitor对象监视器，lock的底层原理是AQS</li>
<li>synchronized只有一个同步队列和一个等待队列，而lock有一个同步队列，可以有多个等待队列。</li>
<li>synchronized可以作用在方法和代码块上，而lock只能作用在代码块上。</li>
<li>synchronized没有超时机制，而lock中的trylcok可以支持超时机制。</li>
<li>synchronized不可打断，lock可打断</li>
</ul>
<h2 id="Java中断机制"><a href="#Java中断机制" class="headerlink" title="Java中断机制"></a>Java中断机制</h2><p>Java中对于线程的中断机制是分不同的情况的，如果当前线程处理运行RUNNABLE状态下，那么调用它的interrupt中断方法并不会影响线程的执行，也不会抛出异常，它只会将线程中标志中断状态的Boolean值变更为true；</p>
<p>而如果线程因为sleep或者wait方法进入阻塞或者等待状态下的话，调用interrupt方法，此时线程会修改中断状态然后抛出中断异常。值得一提，如果线程是因为LockSupport.park()方法进入阻塞状态，那此时调用interrupt方法依旧只会改变线程的中断状态为true，而不会抛出异常。</p>
<pre><code> 如果我们要监控一个正在运行的线程的中断状态，可以调用isInterrupt方法去获取线程的中断状态，如果调用interrupted方法则可修改线程中断为false并返回中断状态值。
</code></pre>
<h2 id="线程池相关"><a href="#线程池相关" class="headerlink" title="线程池相关"></a>线程池相关</h2><h3 id="线程池执行原理"><a href="#线程池执行原理" class="headerlink" title="线程池执行原理"></a>线程池执行原理</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220525153937993.png" alt="image-20220525153937993"></p>
<ol>
<li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</li>
<li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。 </li>
<li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程（救急线程）来执行任务。如果已经满了，则交给拒绝策略来处理这个任务</li>
</ol>
<h3 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h3><p>1，降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗<br>2，提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行<br>3，提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</p>
<h3 id="线程池基本参数"><a href="#线程池基本参数" class="headerlink" title="线程池基本参数"></a>线程池基本参数</h3><ol>
<li>corePoolSize 核心线程数目 - 池中会保留的最多线程数</li>
<li>maximumPoolSize 最大线程数目 - 核心线程+救急线程的最大数目</li>
<li>keepAliveTime 生存时间 - 救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</li>
<li>unit 时间单位 - 救急线程的生存时间单位，如秒、毫秒等</li>
<li>workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</li>
<li>threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li>
<li>handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略<ol>
<li>丢弃任务并抛异常 java.util.concurrent.ThreadPoolExecutor.AbortPolicy</li>
<li>由调用者线程执行任务 java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy</li>
<li>丢弃任务并不抛出异常 java.util.concurrent.ThreadPoolExecutor.DiscardPolicy</li>
<li>丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy</li>
</ol>
</li>
</ol>
<h3 id="常见的线程池"><a href="#常见的线程池" class="headerlink" title="常见的线程池"></a>常见的线程池</h3><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><ol>
<li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间</li>
<li>阻塞队列是无界的，可以放任意数量的任务</li>
<li>适用于任务量已知，相对耗时的任务</li>
</ol>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><ol>
<li>核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着<ol>
<li>全部都是救急线程（60s 后可以回收）</li>
<li>救急线程可以无限创建</li>
</ol>
</li>
<li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）SynchronousQueue</li>
</ol>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><p>使用场景：</p>
<ol>
<li><p>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</p>
</li>
<li><p>区别：</p>
<ol>
<li><p>和自己创建单线程执行任务的区别：自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作</p>
</li>
<li><p>Executors.newSingleThreadExecutor() <strong>线程个数始终为1，不能修改</strong></p>
<ol>
<li>FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法</li>
</ol>
</li>
<li><p>和Executors.newFixedThreadPool(1) 初始时为1时的区别：</p>
<p>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改，对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</p>
</li>
</ol>
</li>
</ol>
<h4 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h4><p>这个方法创建了一个固定大小的线程池，支持定时及周期性任务执行。</p>
<p>说白了就是：使用有界队列，控制线程创建数量。</p>
<p>除了避免 OOM 的原因之外，不推荐使用 <code>Executors</code>提供的两种快捷的线程池的原因还有：</p>
<ol>
<li>实际使用中需要根据自己机器的性能、业务场景来手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略等等。</li>
<li>我们应该显示地给我们的线程池命名，这样有助于我们定位问题。</li>
</ol>
<h3 id="Java的七大阻塞队列"><a href="#Java的七大阻塞队列" class="headerlink" title="Java的七大阻塞队列"></a>Java的七大阻塞队列</h3><ol>
<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列，先进先出，不保证线程公平。</li>
<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列，此队列的默认和最大长度为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</li>
<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。默认情况下元素采取自然顺序 升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则， </li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。，支持延时获取元素的无界阻塞队列，队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作， 否则不能继续添加元素。支持公平访问队列。</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列，多了tryTransfer和transfer方法。</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。</li>
</ol>
<h3 id="线程池里的方法"><a href="#线程池里的方法" class="headerlink" title="线程池里的方法"></a>线程池里的方法</h3><h4 id="execute-vs-submit"><a href="#execute-vs-submit" class="headerlink" title="execute() vs submit()"></a>execute() vs submit()</h4><p>可以使用两个方法向线程池提交任务，分别为excute() 和 submit()</p>
<p>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否； </p>
<p>submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当 前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后 立即返回，这时候有可能任务没有执行完。</p>
<p><strong>提交任务的类型：</strong></p>
<p>execute和submit都属于线程池的方法，execute只能提交Runnable类型的任务</p>
<p>submit既能提交Runnable类型任务也能提交Callable类型任务。<br><strong>异常：</strong></p>
<p>execute会直接抛出任务执行时的异常，可以用try、catch来捕获，和普通线程的处理方式完全一致<br>submit会吃掉异常，可通过Future的get方法将任务执行时的异常重新抛出。</p>
<p><strong>返回值：</strong></p>
<p>execute()没有返回值</p>
<p>submit有返回值，所以需要返回值的时候必须使用submit</p>
<h4 id="shutdown-vs-shutdownNow"><a href="#shutdown-vs-shutdownNow" class="headerlink" title="shutdown() vs shutdownNow()"></a>shutdown() vs shutdownNow()</h4><p>原理：遍历线程池里的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p>
<p>shutdown（）：关闭线程池，线程池的状态变为SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。 </p>
<p>shutdownNow（）：关闭线程池，线程的状态变为 STOP。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。 </p>
<h4 id="isTerminated-vs-isShutdown"><a href="#isTerminated-vs-isShutdown" class="headerlink" title="isTerminated() vs isShutdown()"></a>isTerminated() vs isShutdown()</h4><p>isShutDown 当调用 shutdown() 方法后返回为 true。</p>
<p> isTerminated 当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true。</p>
<h3 id="线程池大小如何设置"><a href="#线程池大小如何设置" class="headerlink" title="线程池大小如何设置"></a>线程池大小如何设置</h3><p>根据任务的类型合理选择线程池大小。任务类型有CPU密集型、IO密集型、混合型。</p>
<ul>
<li><p><code>CPU密集型</code>：任务会消耗大量的CPU资源，推荐线程池大小为<strong>CPU核数+1</strong>。因为线程过多时线程切换会带来额外开销。</p>
</li>
<li><p><code>IO密集型</code>：线程数需较大，以便线程等待IO返回时，CPU能执行其他线程的任务。一般2*CPU核数</p>
<p>  最佳线程数目&#x3D; (线程等待时间与线程CPU时间之比 + 1) * CPU核数</p>
</li>
<li><p><code>混合型</code>：考虑拆分成CPU密集型和IO密集型。若CPU密集型和IO密集型的处理时间差不多，可以拆分，会比串行效率高。若CPU密集型和IO密集型的处理时间差很多，处理时间取决于时间长的，还要付出合并结果的开销，可能得不偿失。</p>
</li>
</ul>
<h3 id="线程池刚创建的时候一定会立即创建核心线程吗？"><a href="#线程池刚创建的时候一定会立即创建核心线程吗？" class="headerlink" title="线程池刚创建的时候一定会立即创建核心线程吗？"></a>线程池刚创建的时候一定会立即创建核心线程吗？</h3><p>不会。在刚刚创建ThreadPoolExecutor 的时候，线程并不会立即启动，而是要等到有任务提交时才会启动，除非调用了prestartCoreThread&#x2F;prestartAllCoreThreads 事先启动核心线程。</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal以对象为键，任意对象为值的存储结构，一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。</p>
<ul>
<li><p>ThreadLocal与线程同步机制不同，线程同步机制是<strong>多个线程共享同一个变量</strong>，对这个共享变量的修改，通过<strong>无锁或者有锁</strong>的机制保证线程的安全</p>
</li>
<li><p>而ThreadLocal是为每一个线程，创建一个<strong>只属于它自己的变量副本</strong>，线程可以改变自己所拥有的变量副本，而不会影响其他线程所对应的副本</p>
</li>
<li><p>简而言之，往ThreadLocal中填充的变量<strong>属于当前线程</strong>，该变量对其他线程而言是<strong>隔离</strong>的</p>
</li>
<li><p>一个线程使用自己的<strong>局部变量比使用全局变量方便且安全</strong>，因为<strong>局部变量只有线程自己能看见</strong>，不会影响其他线程</p>
</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>ThreadLocal 可以实现线程间【资源对象】的线程隔离，让每个线程各用各的【资源对象】，避免争用引发的线程安全问题</li>
<li>ThreadLocal 同时实现了线程内的资源共享</li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p>
<ul>
<li>调用 set 方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li>
<li>调用 get 方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li>
<li>调用 remove 方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li>
</ul>
<p>ThreadLocalMap 的一些特点</p>
<ul>
<li>key 的 hash 值统一分配</li>
<li>初始容量 16，扩容因子 2&#x2F;3，扩容容量翻倍</li>
<li>key 索引冲突后用开放寻址法解决冲突</li>
</ul>
<h3 id="为什么key使用弱引用？"><a href="#为什么key使用弱引用？" class="headerlink" title="为什么key使用弱引用？"></a>为什么key使用弱引用？</h3><p>Thread 可能需要长时间运行（如线程池中的线程），如果 key 不再使用，需要在内存不足（GC）时释放其占用的内存，如果设置为强引用不能被垃圾回收掉</p>
<h3 id="值的内存释放时机"><a href="#值的内存释放时机" class="headerlink" title="值的内存释放时机"></a>值的内存释放时机</h3><ul>
<li>被动 GC 释放 key<ul>
<li>仅是让 key 的内存释放，关联 value 的内存并不会释放</li>
</ul>
</li>
<li>懒惰被动释放 value<ul>
<li>get key 时，发现是 null key，则释放其 value 内存，把键加到里面</li>
<li>set key 时，会使用启发式扫描，清除临近的 null key 的 value 内存，启发次数与元素个数，是否发现 null key 有关</li>
</ul>
</li>
<li>主动 remove 释放 key，value<ul>
<li>会同时释放 key，value 的内存，也会清除临近的 null key 的 value 内存</li>
<li>推荐使用它，因为一般使用 ThreadLocal 时都把它作为静态变量（即强引用），因此无法被动依靠 GC 回收</li>
</ul>
</li>
</ul>
<p>推荐使用remove方法不然容易出现内存泄漏</p>
<h3 id="如果线程之间想要共享threadlocal，怎么实现"><a href="#如果线程之间想要共享threadlocal，怎么实现" class="headerlink" title="如果线程之间想要共享threadlocal，怎么实现"></a>如果线程之间想要共享threadlocal，怎么实现</h3><ol>
<li>当父线程中的inheritableThreadLocal被赋值时，会将当前线程的inheritableThreadLocal变量进行createInheritedMap(),</li>
<li>看一下这个方法的具体实现，它会继续调用ThreadLocalMap(parentMap),主要的目的是父线程的变量值赋值给子线程。</li>
<li>这里直接改变的是Entry[],因为ThreadLocalMap只是一个类名，具体数据存储和操作是使用内部的数组搭配Hash算法和Entry内部类实现。</li>
</ol>
<h2 id="乐观锁和悲观锁的区别"><a href="#乐观锁和悲观锁的区别" class="headerlink" title="乐观锁和悲观锁的区别"></a>乐观锁和悲观锁的区别</h2><p>  乐观锁：指的是在操作数据的时候非常乐观，乐观地认为别人不会同时修改数据，因此乐观锁默认是不会上锁的，只有在执行更新的时候才会去判断在此期间别人是否修改了数据，如果别人修改了数据则放弃操作，否则执行操作。</p>
<p>​    冲突比较少的时候, 使用乐观锁(没有悲观锁那样耗时的开销) 由于乐观锁的不上锁特性，所以在性能方面要比悲观锁好，比较适合用在DB的读大于写的业务场景。</p>
<p>悲观锁的概念：</p>
<p>​    悲观锁：指的是在操作数据的时候比较悲观，悲观地认为别人一定会同时修改数据，因此悲观锁在操作数据时是直接把数据上锁，直到操作完成之后才会释放锁，在上锁期间其他人不能操作数据。</p>
<p>​    冲突比较多的时候, 使用悲观锁(没有乐观锁那么多次的尝试)对于每一次数据修改都要上锁，如果在DB读取需要比较大的情况下有线程在执行数据修改操作会导致读操作全部被挂载起来，等修改线程释放了锁才能读到数据，体验极差。所以比较适合用在DB写大于读的情况。</p>
<h2 id="什么是线程安全和线程不安全"><a href="#什么是线程安全和线程不安全" class="headerlink" title="什么是线程安全和线程不安全"></a>什么是线程安全和线程不安全</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>指多个线程在执行同一段代码的时候采用加锁机制，使每次的执行结果和单线程执行的结果都是一样的，不存在执行程序时出现意外结果。</p>
<h3 id="线程不安全-1"><a href="#线程不安全-1" class="headerlink" title="线程不安全"></a>线程不安全</h3><p>是指不提供加锁机制保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。</p>
<h2 id="JUC-1"><a href="#JUC-1" class="headerlink" title="JUC"></a>JUC</h2><h3 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h3><p>CAS指Compare and swap比较和替换是设计并发算法时用到的一种技术，CAS指令有三个操作数，分别是内存位置（在Java中可以简单的理解为变量的内存地址，用V表示），旧的预期值（用A表示）和准备设置的新值（用B表示）。CAS指令在执行的时候，当且仅当V符合A时，处理器才会用B更新V的值，否则它就不会执行更新。</p>
<h3 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h3><p>全称是 AbstractQueuedSynchronizer（抽象队列同步器），是阻塞式锁和相关的同步器工具的框架</p>
<ul>
<li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁<ul>
<li>getState - 获取 state 状态</li>
<li>setState - 设置 state 状态</li>
<li>compareAndSetState - cas 机制设置 state 状态，防止多线程修改时的线程安全</li>
<li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li>
</ul>
</li>
<li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li>
<li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li>
</ul>
<p>AQS是一个并发包的基础组件，用来实现各种锁，各种同步组件的，它包含state变量、加锁线程、等待队列等并发中的核心组件。</p>
<p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）</p>
<ul>
<li>tryAcquire 尝试获得锁</li>
<li>tryRelease 尝试解锁</li>
<li>tryAcquireShared</li>
<li>tryReleaseShared </li>
<li>isHeldExclusively 是否持有独占锁</li>
</ul>
<h3 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h3><p>可以看到ReentrantLock提供了两个同步器，实现公平锁和非公平锁，默认是非公平锁！</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220522194306979.png" alt="image-20220522194306979"></p>
<h4 id="加锁原理"><a href="#加锁原理" class="headerlink" title="加锁原理"></a>加锁原理</h4><ol>
<li>cas修改状态，如果修改成功把owner线程变为当前线程</li>
<li>如果cas修改失败<ol>
<li>再重试加锁一次，如果还失败会创建一个节点对象并加入到队列里，Node队列里面有一个哨兵队列，用来占位不关联线程。</li>
<li>不断在死循环中不断尝试获得锁，获取当前结点前驱结点，如果是头结点，说明node处于第二位还会尝试获取锁。</li>
<li>如果获取失败，把前驱结点的waitStatus状态改为-1，表示有责任唤醒后面的结点，如果失败会再次重新进入循环尝试一次</li>
</ol>
</li>
<li>如果最后获取锁还是失败，Thread阻塞，被唤醒时再次进入循环，进行唤醒。</li>
</ol>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220807094226788.png" alt="image-20220807094226788"></p>
<h4 id="解锁原理"><a href="#解锁原理" class="headerlink" title="解锁原理"></a>解锁原理</h4><p>有多个线程经历上述过程竞争失败，变成这个样子</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220522200801731.png" alt="image-20220522200801731"></p>
<h5 id="解锁竞争成功流程"><a href="#解锁竞争成功流程" class="headerlink" title="解锁竞争成功流程"></a>解锁竞争成功流程</h5><ol>
<li>占用锁的线程把锁使用完了会把state变为0，exclusiveOwnerThread设置为null</li>
<li>获取当前阻塞队列的头结点，看看头结点是否不为空，且对应waitStatus是否不为0</li>
<li>就去唤醒他的后继结点，把头结点之后的结点恢复运行，恢复原理是接上面加锁的for循环进行循环尝试运行，并且把恢复执行的节点变为头结点，关联线程设为空。</li>
</ol>
<h5 id="解锁竞争失败流程"><a href="#解锁竞争失败流程" class="headerlink" title="解锁竞争失败流程"></a>解锁竞争失败流程</h5><ol>
<li>占用锁的线程把锁使用完了会把state变为0，exclusiveOwnerThread设置为null</li>
<li>如果来了一个线程4，获取了锁</li>
<li>如果失败进入for循环中继续阻塞</li>
</ol>
<h4 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h4><ol>
<li><p>获取当前锁的状态是否为0</p>
</li>
<li><p>如果为0改为1</p>
</li>
<li><p>同一个线程再次获取这个值，判断当前线程是否为ower线程，发生锁重入，state++，表示调用两次这个锁</p>
</li>
<li><p>释放是否会调用tryRelase方法，把状态减一</p>
</li>
<li><p>如果state值不为0，不会去释放锁</p>
</li>
<li><p>如果为0释放对应的锁</p>
</li>
</ol>
<h4 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h4><h5 id="不可打断模式"><a href="#不可打断模式" class="headerlink" title="不可打断模式"></a>不可打断模式</h5><p>在不可打断模式中，即使被打断仍会驻留在AQS队列中，等获得锁后方能继续运行。</p>
<h5 id="可打断模式"><a href="#可打断模式" class="headerlink" title="可打断模式"></a>可打断模式</h5><ol>
<li>如果被打断了，就会抛出InterrruptedException，可以停止去等待锁</li>
</ol>
<h4 id="公平锁实现原理"><a href="#公平锁实现原理" class="headerlink" title="公平锁实现原理"></a>公平锁实现原理</h4><ol>
<li>发现没有人占锁，会先去判断队列是否有其他线程<ol>
<li>如果有其他线程就会直接从线程中取</li>
<li>否则的话会调用cas方法，让当前获取锁的线程获取</li>
</ol>
</li>
</ol>
<h4 id="条件变量实现原理"><a href="#条件变量实现原理" class="headerlink" title="条件变量实现原理"></a>条件变量实现原理</h4><h5 id="await实现原理"><a href="#await实现原理" class="headerlink" title="await实现原理"></a>await实现原理</h5><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220807102539309.png" alt="image-20220807102539309"></p>
<ol>
<li>刚开始Thread0持有锁，调用await进入addConditionWaiter流程，创建新的Node状态为-2,关联Thread0加入等待队列尾部</li>
<li>进入fullyRelease流程，把结点所有的锁都释放掉，把重入的锁也都拿掉，state设为0，持有线程设为null</li>
<li>唤醒等待队列的下一个节点，唤醒的取竞争锁</li>
</ol>
<h5 id="signal实现流程"><a href="#signal实现流程" class="headerlink" title="signal实现流程"></a>signal实现流程</h5><ol>
<li>调用signal方法，检查调用的线程是不是锁的持有者，如果不是锁持有者抛出异常</li>
<li>如果是，找到条件变量里面第一个元素，如果第一个元素不为空，调用doSignal流程</li>
<li>把条件变量断开，把节点转移到竞争锁的队列<ol>
<li>转移成功的话结束流程，有的时候等待队列元素可能被打断或者取消。</li>
<li>转移失败尝试唤醒下一个节点，重复流程，走向流程4</li>
</ol>
</li>
<li>成功后把节点加入到等待队列里面，如果成功返回前驱节点，把前驱节点状态改为-1。</li>
</ol>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h2><p>Java源代码编译成java字节码，之后通过java命令执行字节码，之后进行类加载，java虚拟机栈发现没见过的类就去类加载，把类的所有的信息读到方法区（名字，成员变量，方法），一旦遇到没见过的类就会再次类加载，当代码出现new的实例对象后，来自堆内存，局部变量和方法参数在虚拟机栈中。有可能轮到别的线程执行，用程序计数器记录该从哪行代码进行执行。字节码变成机器码，即时编译器对热点代码进行优化。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220315164232268.png" alt="image-20220315164232268"></p>
<p><strong>虚拟机栈</strong>描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都 会同步创建一个栈帧[1]（Stack Frame）用于<strong>存储局部变量表、操作数栈、动态连接、方法出口</strong>等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、 float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始 地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p>
<p>Java<strong>堆</strong>是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。</p>
<p><strong>方法区（Method Area）</strong>与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<p>类加载会在方法区内加载，虚拟机栈包含了局部变量表和对象引用类型(stu,args),本地方法栈包含一些本地方法，而Hotspot虚拟机将本地方法栈合并到虚拟机栈中，解释器将Java字节码转换成机器码，对同一行代码反复解释，对于频繁执行的代码（热点代码），即时编译器发现热点代码将热点代码缓存，下次调用便会从缓存中读取。</p>
<h3 id="方法区和永久代的关系"><a href="#方法区和永久代的关系" class="headerlink" title="方法区和永久代的关系"></a>方法区和永久代的关系</h3><p><strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p>
<h3 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h3><ol>
<li>检查：检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li>
<li>在类加载检查通过后，将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的过程相对于把一块确定大小的内存从java堆中划分出来。那么按照内存是否规整分为两种方式：指针碰撞、空闲列表。</li>
<li>虚拟机将分配到的内存空间都初始化为零值，如果使用了TLAB，这步也可以提至TLAB分配时进行。此过程保证了对象的实例字段不设置初始值也可以正常使用。</li>
<li>对对象进行设置，例如对象属于哪个类的实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄、是否使用偏向锁等等。</li>
<li>执行自定义的（或是自动生成的）构造函数<init>方法进行对象按照程序员的意愿初始化。</li>
</ol>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><h4 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h4><p>一般情况下，JVM的对象都放在堆内存中（发生逃逸分析除外）。当类加载检查通过后，Java虚拟机开始为新生对象分配内存。如果Java堆中内存是绝对规整的，所有被使用过的的内存都被放到一边，空闲的内存放到另外一边，中间放着一个指针作为分界点的指示器，所分配内存仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的实例，这种分配方式就是指针碰撞。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220528203537611.png" alt="image-20220528203537611"></p>
<h4 id="空闲列表"><a href="#空闲列表" class="headerlink" title="空闲列表"></a>空闲列表</h4><p>如果Java堆内存中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，不可以进行指针碰撞啦，虚拟机必须维护一个列表，记录哪些内存是可用的，在分配的时候从列表找到一块大的空间分配给对象实例，并更新列表上的记录，这种分配方式就是空闲列表</p>
<p>对象创建在虚拟机中是非常频繁的行为，可能存在线性安全问题。如果一个线程正在给A对象分配内存，指针还没有来的及修改，同时另一个为B对象分配内存的线程，仍引用这之前的指针指向，这就出「问题」了。</p>
<h4 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h4><p>可以把内存分配的动作按照线程划分在不同的空间之中进行，每个线程在Java堆中预先分配一小块内存,这就是TLAB（Thread Local Allocation Buffer，本地线程分配缓存）。虚拟机通过-XX:UseTLAB设定它的。</p>
<h3 id="对象访问定位的两种方式？"><a href="#对象访问定位的两种方式？" class="headerlink" title="对象访问定位的两种方式？"></a>对象访问定位的两种方式？</h3><ol>
<li><p>句柄访问：在堆内存中划分一个区域存放句柄池，java 栈中存储的refrence 指向的就是句柄池的地址，句柄池里存放的是java 对象实例数据与类型数据各自的地址信息。</p>
</li>
<li><p>直接访问：refrence 里存储的是堆中java 具体实例对象的地址，而堆中java 具体的实例对象自关联到方法区中的类型数据具体信息。</p>
</li>
</ol>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>句柄访问：<br>优点：对象移动时，refrence 引用指针不变，只需改变对象实例数据的指针。<br>缺点：定位速度慢<br>直接引用<br>优点：定位速度快，节省一次指针定位的开销。<br>缺点：对象回收时，指针都需要重新定位，开销大。</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="垃圾判断算法"><a href="#垃圾判断算法" class="headerlink" title="垃圾判断算法"></a>垃圾判断算法</h3><ul>
<li>引用计数法，每当有一个地方引用，计数器就加一，引用失效时，计数器就减一；任何计数器为0的对象都不在使用，会存在依赖引用无法判断的情况</li>
<li>可达性分析算法，通过GC Roots为根的对象作为起始节点，向下搜索，如果不存在与GC Roots相连，就证明此对象补可再使用。</li>
</ul>
<h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><ol>
<li>弱分代假说：绝大多数对象都是朝生夕灭的。</li>
<li>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。</li>
<li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数。</li>
</ol>
<h3 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h3><h4 id="哪些可以作为GC-Roots"><a href="#哪些可以作为GC-Roots" class="headerlink" title="哪些可以作为GC Roots"></a>哪些可以作为GC Roots</h4><ul>
<li><strong>在虚拟机栈（栈帧中的本地变量表）中引用的对象</strong>，譬如各个线程被调用的方法堆栈中使用到的 参数、局部变量、临时变量等。 </li>
<li><strong>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</strong></li>
<li><strong>在方法区中常量引用的对象</strong>，譬如字符串常量池（String Table）里的引用。</li>
<li>在本地方法栈中JNI（即通常所说的<strong>Native方法</strong>）引用的对象。 </li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。 </li>
<li><strong>所有被同步锁（synchronized关键字）持有的对象。</strong></li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ul>
<h4 id="Java中的引用"><a href="#Java中的引用" class="headerlink" title="Java中的引用"></a>Java中的引用</h4><p>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为<strong>强引用（Strongly Re-ference）、软 引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）</strong>4种，这4种引用强 度依次逐渐减弱。</p>
<ul>
<li>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object  obj&#x3D;new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回 收掉被引用的对象。</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220317143558133.png" alt="image-20220317143558133"></p>
<ul>
<li><p>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，<strong>在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。</strong>在JDK 1.2版之后提供了SoftReference类来实现软引用。</p>
<p>SoftReference a&#x3D;new SoftReference(new A); 软引用自身内存不会释放，软引用需要配合引用队列来释放，典型例子是反射数据</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220317143547828.png" alt="image-20220317143547828"></p>
</li>
<li><p>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。<strong>当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</strong>在JDK 1.2版之后提供了WeakReference类来实现弱引用。</p>
</li>
</ul>
<p>​       WeakReference a&#x3D;new WeakReference(new A);弱引用自身需要配合队列来释放，典型例子是ThreadLocalMap中的Entry对象</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220317143612879.png" alt="image-20220317143612879"></p>
<ul>
<li><p>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。<strong>为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</strong>在JDK 1.2版之后提供<br>了PhantomReference类来实现虚引用。</p>
<p>PhantomReference a&#x3D;new PhantomReference(new A());必须配合引用队列一起使用，当虚引用的对象被回收时，会将虚引用对象入队，由Reference Handler线程释放其关联的外部资源，典型例子是Cleaner释放DirectByteBuffer占用的直接内存。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210901112157901.png" alt="image-20210901112157901"></p>
</li>
</ul>
<h4 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h4><p>会使用一个称为OopMap的数据结构来记录对应的对象的引用。</p>
<h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><p>JVM只会在特定的区域记录对应的对象引用，这些特定的区域叫做安全点。</p>
<h6 id="垃圾回收前跑到安全点的方式"><a href="#垃圾回收前跑到安全点的方式" class="headerlink" title="垃圾回收前跑到安全点的方式"></a>垃圾回收前跑到安全点的方式</h6><ol>
<li>抢占式中断：不需要线程的执行代码 主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地 方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件。</li>
<li>主动式中断的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一 个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最 近的安全点上主动中断挂起。轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他 需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。</li>
</ol>
<h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><p>程序处于Sleep状态或者Blocked状态，线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，因而引入安全区域。</p>
<p>安全区域是指能够确保某一段代码片段中，引用关系不会发生变化。</p>
<p>当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时 间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全 区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的 阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</p>
<h4 id="记忆集和卡表"><a href="#记忆集和卡表" class="headerlink" title="记忆集和卡表"></a>记忆集和卡表</h4><p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构，卡表是记忆集的一种实现。</p>
<p>卡表最简单的形式可以只是一个字节数组[2]，而HotSpot虚拟机确实也是这样做的。以下这行代 码是HotSpot默认的卡表标记逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CARD_TABLE [<span class="built_in">this</span> address &gt;&gt; <span class="number">9</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220815144915712.png" alt="image-20220815144915712"></p>
<p>一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代 指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏（Dirty），没有则标识为0。在垃 圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描</p>
<h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><p>写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切 面，在引用对象赋值时会产生一个环形（Around）通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。</p>
<p>应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新 卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，</p>
<h5 id="伪共享问题"><a href="#伪共享问题" class="headerlink" title="伪共享问题"></a>伪共享问题</h5><p>现代中央处理器的缓存系统中是以缓存行（Cache Line） 为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题。</p>
<ol>
<li>先检查卡表标记，只有当卡表元素未被标记过时，才将其标记为变脏。</li>
<li>JDK7之后，HotSpot虚拟机增加了一个新的参数-XX：+UseCondCardMark，用来决定是否开启 卡表更新的条件判断。</li>
</ol>
<h4 id="不可达的对象一定会被回收吗"><a href="#不可达的对象一定会被回收吗" class="headerlink" title="不可达的对象一定会被回收吗"></a>不可达的对象一定会被回收吗</h4><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p>
<p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p>
<h4 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h4><p>即用三种颜色记录对象的标记状态</p>
<ul>
<li>黑色 – 已标记</li>
<li>灰色 – 标记中</li>
<li>白色 – 还未标记</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220508160355202.png" alt="image-20220508160355202"></p>
<ol>
<li>起始的三个对象还未处理完成，用灰色表示</li>
</ol>
<img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831215016566.png" alt="image-20210831215016566" style="zoom:50%;" />

<ol start="2">
<li>该对象的引用已经处理完成，用黑色表示，黑色引用的对象变为灰色</li>
</ol>
<img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831215033510.png" alt="image-20210831215033510" style="zoom:50%;" />

<ol start="3">
<li>依次类推</li>
</ol>
<img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831215105280.png" alt="image-20210831215105280" style="zoom:50%;" />

<ol start="4">
<li>沿着引用链都标记了一遍</li>
</ol>
<img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831215146276.png" alt="image-20210831215146276" style="zoom:50%;" />

<ol start="5">
<li>最后为标记的白色对象，即为垃圾</li>
</ol>
<img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831215158311.png" alt="image-20210831215158311" style="zoom:50%;" />

<h4 id="并发标记引来的问题"><a href="#并发标记引来的问题" class="headerlink" title="并发标记引来的问题"></a>并发标记引来的问题</h4><p>条件一：赋值器插入了一条或者多条从黑色对象到白色对象的新引用。</p>
<p>条件二：赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</p>
<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li><p>增量更新要破坏的是第一个条件（赋值器插入了一条或者多条从黑色对象到白色对象的新引用），当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。可以简化的理解为：黑色对象一旦插入了指向白色对象的引用之后，它就变回了灰色对象。</p>
</li>
<li><p>原始快照要破坏的是第二个条件（赋值器删除了全部从灰色对象到该白色对象的直接或间接引用），当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这个可以简化理解为：无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照开进行搜索。</p>
</li>
</ol>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h4><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831211008162.png" alt="image-20210831211008162"></p>
<p>解释：</p>
<ol>
<li>找到 GC Root 对象，即那些一定不会被回收的对象，如正执行方法内局部变量引用的对象、静态变量引用的对象</li>
<li>标记阶段：沿着 GC Root 对象的引用链找，直接或间接引用到的对象加上标记</li>
<li>清除阶段：释放未加标记的对象占用的内存</li>
</ol>
<p>要点：</p>
<ul>
<li>标记速度与存活对象线性关系</li>
<li>清除速度与内存大小线性关系</li>
<li>缺点是会产生内存碎片</li>
</ul>
<h4 id="标记整理法"><a href="#标记整理法" class="headerlink" title="标记整理法"></a>标记整理法</h4><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831211641241.png" alt="image-20210831211641241"></p>
<p>解释：</p>
<ol>
<li>前面的标记阶段、清理阶段与标记清除法类似</li>
<li>多了一步整理的动作，将存活对象向一端移动，可以避免内存碎片产生</li>
</ol>
<p>特点：</p>
<ul>
<li><p>标记速度与存活对象线性关系</p>
</li>
<li><p>清除与整理速度与内存大小成线性关系</p>
</li>
<li><p>缺点是性能上较慢</p>
</li>
</ul>
<h4 id="标记复制法"><a href="#标记复制法" class="headerlink" title="标记复制法"></a>标记复制法</h4><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831212125813.png" alt="image-20210831212125813"></p>
<p>解释：</p>
<ol>
<li>将整个内存分成两个大小相等的区域，from 和 to，其中 to 总是处于空闲，from 存储新创建的对象</li>
<li>标记阶段与前面的算法类似</li>
<li>在找出存活对象后，会将它们从 from 复制到 to 区域，复制的过程中自然完成了碎片整理</li>
<li>复制完成后，交换 from 和 to 的位置即可</li>
</ol>
<p>特点：</p>
<ul>
<li>标记与复制速度与存活对象成线性关系</li>
<li>缺点是会占用成倍的空间</li>
</ul>
<h3 id="如何回收方法区？"><a href="#如何回收方法区？" class="headerlink" title="如何回收方法区？"></a>如何回收方法区？</h3><ol>
<li>方法区主要回收两部分内容，废弃的常量和不再使用的类型</li>
<li>没有任何对象引用常量池中某个变量，也没有其他地方引用这个字面量，这个时候发生内存回收，如果有必要的话会把对应常量进行回收。</li>
<li>对于类型的话<ol>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ol>
</li>
<li>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。是否回收由虚拟机的参数决定。</li>
</ol>
<h3 id="被标记为垃圾的对象一定会被回收吗？"><a href="#被标记为垃圾的对象一定会被回收吗？" class="headerlink" title="被标记为垃圾的对象一定会被回收吗？"></a>被标记为垃圾的对象一定会被回收吗？</h3><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。  </p>
<p>第一次标记：如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记；</p>
<p>第二次标记：第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。在 finalize() 方法中没有重新与引用链建立关联关系的，将被进行第二次标记。第二次标记成功的对象将真的会被回收，如果对象在 finalize() 方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。</p>
<h3 id="说下你用过的-JVM-监控工具？"><a href="#说下你用过的-JVM-监控工具？" class="headerlink" title="说下你用过的 JVM 监控工具？"></a>说下你用过的 JVM 监控工具？</h3><ol>
<li>jvisualvm：虚拟机监视和故障处理平台</li>
<li>jps ：查看当前 Java 进程</li>
<li>jstat：显示虚拟机运行数据</li>
<li>jmap：内存监控</li>
<li>jhat：分析 heapdump 文件</li>
<li>jstack：线程快照</li>
<li>jinfo：虚拟机配置信息</li>
</ol>
<h3 id="JVM会对永久代进行回收吗？"><a href="#JVM会对永久代进行回收吗？" class="headerlink" title="JVM会对永久代进行回收吗？"></a>JVM会对永久代进行回收吗？</h3><p>方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。回收废弃常量与回收 Java堆中的对象非常类似。在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸的能力，以保证不会对方法区造成过大的内存压力。</p>
<h3 id="常见的垃圾回收器"><a href="#常见的垃圾回收器" class="headerlink" title="常见的垃圾回收器"></a>常见的垃圾回收器</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220528181312681.png" alt="image-20220528181312681"></p>
<p>新生代Serial，ParNew，Parallel Scavenge收集器</p>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220528181746538.png" alt="image-20220528181746538"></p>
<p>这个收集器是一个单线程工作的收集器，更重要的是强调在它进行垃圾收集时，采用标记复制算法且必须暂停其他所有工作线程，直到它收集结束。</p>
<p>Serial收集器对于运行客户端模式下的虚拟机来说是一个很好的选择。</p>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220528181928513.png" alt="image-20220528181928513"></p>
<p>垃圾回收时会STW，采用标记复制方法，可以有多个线程。</p>
<p>ParNew收集器实质上是Serial收集器的多线程并行版本，JDK9ParNew合并入CMS，成为它专门处理新生代的组成部 分。ParNew可以说是HotSpot虚拟机中第一款退出历史舞台的垃圾收集器。</p>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p>基于标记-复制算法实现的收集器，也是 能够并行收集的多线程收集器,Parallel Scavenge收集器的目标则是达到一个可控制的吞吐 量（Throughput）。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值，<br>即：<img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220528182156806.png" alt="image-20220528182156806"></p>
<p>也常被称为吞吐量优先收集器。</p>
<h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220528182333168.png" alt="image-20220528182333168"></p>
<p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。</p>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h4><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220528182416937.png" alt="image-20220528182416937"></p>
<p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p>关注服务的响应速度，基于标记–清除算法实现，过程包括</p>
<p>初始标记和重新标记需要stop the word</p>
<ul>
<li>1）初始标记（CMS initial mark） ，仅仅只是标记一下 GCRoots 能直接关联到的对象，速度很快，需要停顿（STW-Stoptheworld）。</li>
<li>2）并发标记（CMS concurrent mark），不需要停顿用户线程。</li>
<li>3）重新标记（CMS remark，利用<strong>增量更新</strong>，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。</li>
<li>4）并发清除（CMS concurrent sweep），清除删除掉标记阶段判断已经死亡的对象。</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220528182613800.png" alt="image-20220528182613800"></p>
<p>由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一 起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p>在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。</p>
<p>要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，但这样停顿时间就很长了。</p>
<h4 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h4><p>G1跳出了这个樊笼，它可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。</p>
<p>把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的 Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。Region中还有一类特殊的Humongous区域，G1认为只要大小超过了一个 Region容量一半的对象即可判定为大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待。</p>
<p>G1为每一个Region设 计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过<br>程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上</p>
<p>如果内存回收的速度赶不上内存分配的速度， G1收集器也要被迫冻结用户线程执行，导致Full GC而产生长时间“Stop The World。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220528183751168.png" alt="image-20220528183751168"></p>
<ul>
<li>初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要 停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际 并没有额外的停顿。</li>
<li>并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以 后，还要重新处理SATB记录下的在并发时有引用变动的对象。</li>
<li>最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。 </li>
<li>筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</li>
</ul>
<h3 id="JDK默认的垃圾回收器"><a href="#JDK默认的垃圾回收器" class="headerlink" title="JDK默认的垃圾回收器"></a>JDK默认的垃圾回收器</h3><p>jdk1.7 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）</p>
<p>jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）</p>
<p>jdk1.9 默认垃圾收集器G1</p>
<h3 id="内存泄漏和内存溢出"><a href="#内存泄漏和内存溢出" class="headerlink" title="内存泄漏和内存溢出"></a>内存泄漏和内存溢出</h3><h4 id="什么是内存溢出和内存泄漏"><a href="#什么是内存溢出和内存泄漏" class="headerlink" title="什么是内存溢出和内存泄漏"></a>什么是内存溢出和内存泄漏</h4><p>内存泄漏（memory leak）：是指程序在申请内存后，无法释放已申请的内存空间，导致系统无法及时回收内存并且分配给其他进程使用。通常少次数的内存无法及时回收并不会到程序造成什么影响，但是如果在内存本身就比较少获取多次导致内存无法正常回收时，就会导致内存不够用，最终导致内存溢出。<br>内存溢出 （out of memory）：:指程序申请内存时，没有足够的内存供申请者使用，导致数据无法正常存储到内存中。也就是说给你个int类型的存储数据大小的空间，但是却存储一个long类型的数据，这样就会导致内存溢出。</p>
<h4 id="内存溢出和内存泄露的关系以及区别"><a href="#内存溢出和内存泄露的关系以及区别" class="headerlink" title="内存溢出和内存泄露的关系以及区别"></a>内存溢出和内存泄露的关系以及区别</h4><p>1.关系：内存泄露最终会导致内存溢出，由于系统中的内存是有限的，如果过度占用资源而不及时释放，最后会导致内存不足，从而无法给所需要存储的数据提供足够的内存，从而导致内存溢出。导致内存溢出也可能是由于在给数据分配大小时没有根据实际要求分配，最后导致分配的内存无法满足数据的需求，从而导致内存溢出。</p>
<p>2.区别：内存泄露是由于GC无法及时或者无法识别可以回收的数据进行及时的回收，导致内存的浪费；内存溢出是由于数据所需要的内存无法得到满足，导致数据无法正常存储到内存中。内存泄露的多次表现就是会导致内存溢出。</p>
<h4 id="内存泄漏的情况"><a href="#内存泄漏的情况" class="headerlink" title="内存泄漏的情况"></a>内存泄漏的情况</h4><ol>
<li>静态集合类，长生命周期对象持有它的短生命周期引用。</li>
<li>数据库连接，网络连接，IO连接。</li>
<li>变量作用域不合理，把消息存在数据库后，变量还存在。</li>
<li>改变哈希值，存储进集合里，改变了哈希值相关字段，导致使用contains方法寻找引用也找不到，也无法单独删除当前对象，内存泄漏。</li>
</ol>
<h4 id="内存溢出的情况"><a href="#内存溢出的情况" class="headerlink" title="内存溢出的情况"></a>内存溢出的情况</h4><ol>
<li>误用线程池导致的内存溢出<ol>
<li>线程池使用无界队列，前两个任务超时时候一直加入导致溢出</li>
<li>newCachedThreadPool，创建了大量的线程</li>
</ol>
</li>
<li>查询数据量太大导致的内存溢出，最好限制分页</li>
<li>动态生成类导致</li>
</ol>
<h3 id="内存分配区域"><a href="#内存分配区域" class="headerlink" title="内存分配区域"></a>内存分配区域</h3><h4 id="什么时候会触发Young-GC？"><a href="#什么时候会触发Young-GC？" class="headerlink" title="什么时候会触发Young GC？"></a>什么时候会触发Young GC？</h4><p>当新生代的Eden区满了之后就会触发YoungGC，利用标记复制算法回收新生代的垃圾。</p>
<h4 id="什么时候会触发Full-GC"><a href="#什么时候会触发Full-GC" class="headerlink" title="什么时候会触发Full GC?"></a>什么时候会触发Full GC?</h4><p>1、发生Young GC之前进行检查，如果“老年代可用的连续内存空间” &lt; “新生代历次Young GC后升入老年代的对象总和的平均大小”，说明本次Young GC后可能升入老年代的对象大小，可能超过了老年代当前可用内存空间，此时会触发FullGC</p>
<p>2、当老年代没有足够空间存放对象时，会触发一次FullGC</p>
<p>3、如果元空间区域的内存达到了所设定的阈值-XX:MetaspaceSize&#x3D;，也会触发FullGC。</p>
<h4 id="为什么要有suivivor区？"><a href="#为什么要有suivivor区？" class="headerlink" title="为什么要有suivivor区？"></a>为什么要有suivivor区？</h4><p>如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC。<br>又因为老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多。频发的Full GC消耗的时间是非常可观的，这一点会影响大型程序的执行和响应速度。</p>
<p>因此Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。</p>
<h4 id="为什么要设置两个Survivor区"><a href="#为什么要设置两个Survivor区" class="headerlink" title="为什么要设置两个Survivor区"></a>为什么要设置两个Survivor区</h4><p>设置两个Survivor区+使用复制算法，最大的好处就是解决了碎片化。</p>
<p>为什么一个Survivor区不行？刚新建的对象在Eden中，一旦Eden满了，触发一次Minor GC，Eden中的存活对象就会被移动到Survivor区。这样继续循环下去，极易导致内存碎片化。碎片化带来的风险是极大的，堆中没有足够大的连续内存空间。</p>
<p>那么，顺理成章的，应该建立两块Survivor区，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）。S0和Eden被清空，然后下一轮S0与S1交换角色，如此循环往复。如果对象的复制次数达到16次，该对象就会被送到老年代中。</p>
<p>那么，Survivor为什么不分更多块呢？比方说分成三个、四个、五个?显然，如果Survivor区再细分下去，每一块的空间就会比较小，很容易导致Survivor区满，因此，我认为两块Survivor区是经过权衡之后的最佳方案。</p>
<h4 id="survivor满了怎么办"><a href="#survivor满了怎么办" class="headerlink" title="survivor满了怎么办"></a>survivor满了怎么办</h4><p>当幸存区满了之后，没复制完的对象会直接进入old区，次数过多会产生full gc，这种情况下，可以考虑给新生代分配更多的内存。</p>
<h4 id="什么时候对象进入老年代"><a href="#什么时候对象进入老年代" class="headerlink" title="什么时候对象进入老年代"></a>什么时候对象进入老年代</h4><ol>
<li>第一次被移动到survivor区的时候会被设置为1岁，之后每在survivor区熬过一次，则年龄会加一次，默认15岁的时候就会进入到老年代（可以用-XX:MaxTenuringThreshold进行配置）</li>
<li>如果Surivivor中低于或等于某年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代</li>
</ol>
<h2 id="类加载相关"><a href="#类加载相关" class="headerlink" title="类加载相关"></a>类加载相关</h2><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220529124640256.png"></p>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。 </li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 </li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p><strong>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</strong></p>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>连接阶段会对class的信息进行验证、为类变量分配内存空间并对其赋默认值。</p>
<p>（1）验证 :对class内容进行验证看字节信息是否符合JVM规范，包括元数据、字节码、符号引用的验证。</p>
<p>（2）准备: 为静态变量（final 和static定义的变量）分配内存空间，初始化静态变量值( int a&#x3D;0, object&#x3D;null的操作)。</p>
<p>（3）解析：把符号引用转换为直接引用，因为这里类的信息已经被加载到内存了，所以这里会把原来通过全限定名引用的对象替换成对象内存的实际地址。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段主要是执行初始化静态块内容，并且为静态变量进行真正的赋值操作，这里JVM会通过执行编译器自动生成的<clinit>() 方法（此方法是编译器通过搜集类的static{}静态块组成的代码）而完成具体工作。</p>
<h3 id="有几种类加载器？"><a href="#有几种类加载器？" class="headerlink" title="有几种类加载器？"></a>有几种类加载器？</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/%E9%A1%B9%E7%9B%AE/image-20211021201630363.png" alt="image-20211021201630363"></p>
<p>应用类加载器（Application ClassLoader），拓展类加载器（Extension ClassLoader），启动类加载器（Bootstrap ClassLoader）</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请<br>求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 首先，检查请求的类是否已经被加载过了 </span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name); </span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123; </span><br><span class="line">                c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; </span><br><span class="line">            <span class="comment">// 如果父类加载器抛出ClassNotFoundException </span></span><br><span class="line">            <span class="comment">// 说明父类加载器无法完成加载请求</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123; <span class="comment">// 在父类加载器无法加载时 // 再调用本身的findClass方法来进行类加载 </span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">if</span> (resolve) &#123; </span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的逻辑清晰易懂：先检查请求加载的类型是否已经被加载过，若没有则调用父加载器的 loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。假如父类加载器加载失败，抛出ClassNotFoundException异常的话，才调用自己的findClass()方法尝试进行加载。</p>
<h3 id="双亲委派的作用"><a href="#双亲委派的作用" class="headerlink" title="双亲委派的作用"></a>双亲委派的作用</h3><ul>
<li><strong>防止加载同一个.class。</strong>通过委托去询问上级是否已经加载过该.class，如果加载过了，则不需要重新加载。保证了数据安全。</li>
<li><strong>保证核心.class不被篡改。</strong>通过委托的方式，保证核心.class不被篡改，即使被篡改也不会被加载，即使被加载也不会是同一个class对象，因为不同的加载器加载同一个.class也不是同一个Class对象。这样则保证了Class的执行安全。</li>
</ul>
<h3 id="打破双亲委派机制的例子"><a href="#打破双亲委派机制的例子" class="headerlink" title="打破双亲委派机制的例子"></a>打破双亲委派机制的例子</h3><h4 id="一、第一次打破"><a href="#一、第一次打破" class="headerlink" title="一、第一次打破"></a>一、第一次打破</h4><p>第一次被打破是在Java的原始版本，那时候用户自定义类加载器已经存在，双亲委派机制为了兼容这些代码，但又无法保证loadClass不被子类重写，所以提供了findClass的方法。用户加载类的时候就去重写这个方法。如此一来，类加载的时候还是会调用加载器loadClass向上请求，只有当父类加载器请求失败的时候，才会回来调用该类加载器被用户重写的findClass方法。</p>
<p>众所周知，双亲委派机制是通过调用类加载器的loadClass去实现的，一旦被重写，逻辑不符合双亲委派的逻辑，那么双亲委派机制就被打破了。</p>
<h4 id="二、第二次打破"><a href="#二、第二次打破" class="headerlink" title="二、第二次打破"></a>二、第二次打破</h4><p>第二次打破则是由于JNDI服务（JDBC&#x2F;JCE&#x2F;JAXB&#x2F;JBI），JNDI的目的就是对资源进行查找和集中管理，该类由启动类加载器去加载，但是却需要调用其他厂商部署在类路径下的JNDI服务提供者接口，由于父亲不认识儿子，启动类加载器是不认识这些接口的，那怎么办呢？</p>
<p><strong>线程上下文类加载器：提供父类加载器访问子类加载器的行为。</strong>这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方 法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>
<p>这样一来就打通了父类到子类加载器的通道，如何去规范这种行为呢？</p>
<p>使用services配置信息，以责任链模式进行辅助。有兴趣的可以深入去了解一下具体信息。</p>
<h4 id="三、第三次打破"><a href="#三、第三次打破" class="headerlink" title="三、第三次打破"></a>三、第三次打破</h4><p>第三次打破是热部署、热替换引起的。</p>
<p>Java热部署模块的规范化模块是OSGi提供的，热部署实现的关键就是OSGi自定义了类加载器，它为每个模块都配了一个类加载器。当需要动态地更换一个模块的时候，就把模块连通这个模块的类加载器一起替换，从而实现了热替换。</p>
<p>这种情况下，类加载器再也不是树状结构了，而是网状。</p>
<h3 id="如何自定义类加载器"><a href="#如何自定义类加载器" class="headerlink" title="如何自定义类加载器"></a>如何自定义类加载器</h3><p>步骤：</p>
<ol>
<li>继承ClassLoader父类</li>
<li>要遵从双亲委派机制，重写findClass方法<ul>
<li>注意不是重写loadClass方法，否则不会走双亲委派机制</li>
</ul>
</li>
<li>读取类文件的字节码</li>
<li>调用父类的defineClass方法来加载类</li>
<li>使用者调用该类加载器的loadClass方法</li>
</ol>
<h3 id="能不能自己写一个java-lang-String"><a href="#能不能自己写一个java-lang-String" class="headerlink" title="能不能自己写一个java.lang.String"></a>能不能自己写一个java.lang.String</h3><p>1、代码书写后可以编译不会报错<br>2、在另一个类中加载java.lang.String，通过反射调用自己写的String类里的方法，得到结果NoSuchMethod，说明加载的还是原来的String，<strong>因为通过双亲委派机制，会把java.lang.String一直提交给启动类加载器去加载，通过他加载，加载到的永远是&#x2F;lib下面的java.lang.String</strong><br>3、在这个自己写的类中写上main方法public static void main(String[] args)执行main方法报错，因为这个String并不是系统的java.lang.String，所以JVM找不到main方法的签名</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ol>
<li><p>final修饰的实例属性，在实例创建的时候才会赋值。</p>
</li>
<li><p>static修饰的类属性，在类加载的准备阶段赋初值，初始化阶段赋值。</p>
</li>
<li><p>static+final修饰的String类型或者基本类型常量，JVM规范是在初始化阶段赋值，但是HotSpot VM直接在准备阶段就赋值了。</p>
</li>
<li><p>static+final修饰的其他引用类型常量，赋值步骤和第二点的流程是一样的。</p>
</li>
</ol>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><ol>
<li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li>
<li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li>
<li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li>
<li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li>
</ol>
<h3 id="索引的好处"><a href="#索引的好处" class="headerlink" title="索引的好处"></a>索引的好处</h3><ol>
<li>索引把随机IO变为了顺序IO加快了索引的查询</li>
<li>大大减少了服务器需要扫描的数据量</li>
<li>帮助服务器避免排序和临时表</li>
</ol>
<h3 id="B-树索引和哈希索引的区别"><a href="#B-树索引和哈希索引的区别" class="headerlink" title="B+树索引和哈希索引的区别"></a>B+树索引和哈希索引的区别</h3><ol>
<li>hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。</li>
<li>hash索引不支持使用索引进行排序，原理同上。</li>
<li>hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。</li>
<li>hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。</li>
<li>hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</li>
</ol>
<h3 id="mysql是如何确定哪个索引的"><a href="#mysql是如何确定哪个索引的" class="headerlink" title="mysql是如何确定哪个索引的"></a>mysql是如何确定哪个索引的</h3><p>MySQL会根据扫描行数、是否使用了临时表、是否使用文件排序会进行优化，根据扫描行数判断选择哪个索引，扫描行数可能会不准，扫描行数是通过抽样的方式获取的。</p>
<h3 id="联合索引是怎么存储的？"><a href="#联合索引是怎么存储的？" class="headerlink" title="联合索引是怎么存储的？"></a>联合索引是怎么存储的？</h3><p>联合索引是按第一个有序，在相同内做到第二个有序存储的。</p>
<h3 id="B-树高度计算"><a href="#B-树高度计算" class="headerlink" title="B+树高度计算"></a>B+树高度计算</h3><p>B+树的索引树的高度就是logNB(IogN&#x2F;IogB)<br>N表示记录数，B表示每个节点有B个索引。<br>假设有3000W条数据，每个节点保存64个索引。<br>那么索引的高度就是Log2^25&#x2F;log (2 ^ 6)&#x3D;25&#x2F;6&#x3D;4</p>
<h3 id="是否使用了索引"><a href="#是否使用了索引" class="headerlink" title="是否使用了索引"></a>是否使用了索引</h3><p>select * from table where a&#x3D;xx group by b order by c用到abc索引了</p>
<h2 id="MyISAM和InnoDB的区别"><a href="#MyISAM和InnoDB的区别" class="headerlink" title="MyISAM和InnoDB的区别"></a>MyISAM和InnoDB的区别</h2><ol>
<li>是否支持行级锁</li>
<li>是否支持事务</li>
<li>是否支持外键</li>
<li>是否支持数据库异常崩溃的安全恢复(redolog)</li>
<li>InnoDB B+树索引的叶子结点保存数据本身，MyISAM索引的叶子结点保存数据的物理地址</li>
</ol>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务的特性？"><a href="#事务的特性？" class="headerlink" title="事务的特性？"></a>事务的特性？</h3><p>原子性（atomicity）：事务的所有操作在数据库中要么全部反映出来，要么完全不反映。</p>
<p>一致性（consistency）：隔离执行事务时（换言之，在没有其他事务并发执行的情况下）保持数据库的一致性。</p>
<p>隔离性（isolation）：尽管多个事务可能并发执行，但系统保证，对于任何一对事务Ti和Tj，在Ti看来，Tj或者在Ti开始之前已经完成执行，或者在Ti完成之后开始执行。因此，每个事务都感觉不到系统中有其他事务在并发执行。</p>
<p>持久性（durability）：一个事物成功完成后，它对数据库的改变必须是持久的，即使出现系统故障。</p>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul>
<li><strong>读未提交</strong>是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li><strong>读提交</strong>是指，一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li><strong>可重复读</strong>是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。（MySQL默认的隔离级别）</li>
<li><strong>串行化</strong>，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220403142212814.png" alt="image-20220403142212814"></p>
<p>MySQL的可重复读不完全解决了幻读，利用的是mvcc多版本并发控制</p>
<ul>
<li>脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</li>
<li>不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</li>
<li>幻读:事务A 按照一定条件进行数据读取， 期间事务B 插入了相同搜索条件的新数据，事务A再次按照原先条件进行读取时，发现了事务B新插入的数据称为幻读</li>
</ul>
<h3 id="大事务引发的问题"><a href="#大事务引发的问题" class="headerlink" title="大事务引发的问题"></a>大事务引发的问题</h3><ol>
<li>锁定数据过多，容易造成大量的死锁和锁超时</li>
<li>回滚记录占用大量存储空间，事务回滚时间长</li>
<li>执行时间长，容易造成主从延迟<ol>
<li>因为主库上必须等事务执行完成才会写入binlog，再传给备库。所以，如果一个主库上的语句执行10分钟，那这个事务很可能就会导致从库延迟10分钟</li>
</ol>
</li>
</ol>
<h2 id="MySQL-int类型有几种？"><a href="#MySQL-int类型有几种？" class="headerlink" title="MySQL int类型有几种？"></a>MySQL int类型有几种？</h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220730114554571.png" alt="image-20220730114554571"></p>
<h2 id="char和varchar的区别"><a href="#char和varchar的区别" class="headerlink" title="char和varchar的区别"></a>char和varchar的区别</h2><p><strong>char 是一种固定长度的类型，varchar 则是一种可变长度的类型</strong>，它们的区别是：<strong>char(M) 类型的数据列里，每个值都占用 M 个字节，如果某个长度小于 M，MySQL 就会在它的右边用空格字符补足．</strong>（在检索操作中那些填补出来的空格字符将被去掉）在 <strong>varchar(M)类型</strong>的 数据列里，<strong>每个值只占用刚好够用的字节再加上一个用来记录其长度的字节（即总长度为 L+1字节）</strong>,char插入时可省略尾部空格，varchar插入时不会省略尾部空格，查找时省略。</p>
<p>char 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p>
<p>在 MySQL 中用来判断是否需要进行对据列类型转换的规则（但是类型转换可能会走不 了索引。） </p>
<ol>
<li>在一个数据表里，如果每一个数据列的长度都是固定的，那么每一个数据行的长度也 将是固定的． </li>
<li>只要数据表里有一个数据列的长度的可变的，那么各数据行的长度都是可变的． </li>
<li>如果某个数据表里的数据行的长度是可变的，那么，为了节约存储空间，MySQL 会 把这个数据表里的固定长度类型的数据列转换为相应的可变长度类型．例外：长度小于 4 个 字符的 char 数据列不会被转换 varchar 类型</li>
</ol>
<h2 id="MySQL分库分表"><a href="#MySQL分库分表" class="headerlink" title="MySQL分库分表"></a>MySQL分库分表</h2><h2 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h2><h3 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h3><ul>
<li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；<ul>
<li>B+树按照索引值有序排序存储，只能根据前缀进行比较</li>
</ul>
</li>
<li>当我们在查询条件中对索引列使用函数，就会导致索引失效。<ul>
<li>索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</li>
<li>MySQL8.0后加入了函数索引</li>
</ul>
</li>
<li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。<ul>
<li>索引记录的是原始值而不是表达式+1这种值</li>
</ul>
</li>
<li>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li>
<li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。<ul>
<li>原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。</li>
</ul>
</li>
<li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。<ul>
<li>因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。</li>
</ul>
</li>
</ul>
<h2 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h2><p>使用explain + 对应语句？</p>
<h3 id="对应参数"><a href="#对应参数" class="headerlink" title="对应参数"></a>对应参数</h3><table>
<thead>
<tr>
<th>列名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>执行编号，标识select所属的行。如果在语句中没子查询或关联查询，只有唯一的select，每行都将显示1。否则，内层的select语句一般会顺序编号，对应于其在原始语句中的位置</td>
</tr>
<tr>
<td>select_type</td>
<td>显示本行是简单或复杂select。如果查询有任何复杂的子查询，则最外层标记为PRIMARY（DERIVED、UNION、UNION RESUlT）</td>
</tr>
<tr>
<td>table</td>
<td>访问引用哪个表（引用某个查询，如“derived3”）</td>
</tr>
<tr>
<td>type</td>
<td>数据访问&#x2F;读取操作类型（ALL、index、range、ref、eq_ref、const&#x2F;system、NULL）</td>
</tr>
<tr>
<td>possible_keys</td>
<td>揭示哪一些索引可能有利于高效的查找</td>
</tr>
<tr>
<td>key</td>
<td>显示mysql决定采用哪个索引来优化查询</td>
</tr>
<tr>
<td>key_len</td>
<td>显示mysql在索引里使用的字节数</td>
</tr>
<tr>
<td>ref</td>
<td>显示了之前的表在key列记录的索引中查找值所用的列或常量</td>
</tr>
<tr>
<td>rows</td>
<td>为了找到所需的行而需要读取的行数，估算值，不精确。通过把所有rows列值相乘，可粗略估算整个查询会检查的行数</td>
</tr>
<tr>
<td>Extra</td>
<td>额外信息，如using index、filesort等</td>
</tr>
</tbody></table>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>全局锁就是对整个数据库实例加锁。<strong>当你需要让整个库处于只读状态的时候</strong>，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用场景是：做全库逻辑备份。<br>全局锁的命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock</span><br></pre></td></tr></table></figure>

<p>释放全局锁的命令</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure>

<p>当会话断开，全局锁也会被自动释放。</p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>如果我们想对学生表（t_student）加表锁，可以使用下面的命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>表级别的共享锁，也就是读锁；</span><br><span class="line">lock tables t_student read;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>表级别的独占锁，也就是写锁；</span><br><span class="line">lock tables t_stuent write;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</p>
<p>也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。</p>
<p>要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure>

<p>另外，当会话退出后，也会释放所有表锁。</p>
<p>不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，<strong>InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁</strong>。</p>
<h4 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h4><p>再来说说<strong>元数据锁</strong>（MDL）。</p>
<p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p>
<ul>
<li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li>
<li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li>
</ul>
<h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>当产生行级别的锁时候，会产生对应的表级别意向锁(IX,IS)，防止检索锁的速度慢，因为要查到对应的行是很麻烦的。</p>
<p>读取也可以使用排他锁</p>
<p>意向共享锁</p>
<ul>
<li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li>
<li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> 事务要获取某些行的 S 锁，必须先获得表的 <span class="keyword">IS</span> 锁。</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure>

<p>意向排他锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span> <span class="keyword">FROM</span> <span class="keyword">table</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>在5.7及之前版本，select … for update,如果获取不到锁，会一直等待，直到innodb_lock_wait_timeout超时</p>
<ul>
<li>InnoDB 支持 多粒度锁 ，特定场景下，行级锁可以与表级锁共存。 </li>
<li>意向锁之间互不排斥，但除了 IS 与 S 兼容外， 意向锁会与 共享锁 &#x2F; 排他锁 互斥 。 </li>
<li>IX，IS是表级锁，不会和行级的X，S锁发生冲突。只会和表级的X，S发生冲突。 </li>
<li>意向锁在保证并发性的前提下，实现了 行锁和表锁共存 且 满足事务隔离性 的要求。</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220403202731069.png" alt="image-20220403202731069"></p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220403202737106.png" alt="image-20220403202737106"></p>
<p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p>
<p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p>
<p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p>
<h4 id="AUTO-INC锁（自增锁）"><a href="#AUTO-INC锁（自增锁）" class="headerlink" title="AUTO-INC锁（自增锁）"></a>AUTO-INC锁（自增锁）</h4><p>在为某个字段声明 <code>AUTO_INCREMENT</code> 属性时，之后可以在插入数据时，可以不指定该字段的值，数据库会自动给该字段赋值递增的值，这主要是通过 AUTO-INC 锁实现的。</p>
<p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p>
<p>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p>
<p>因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。</p>
<p>一样也是在插入数据的时候，会为被 <code>AUTO_INCREMENT</code> 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</p>
<p>InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。</p>
<ul>
<li>当 innodb_autoinc_lock_mode &#x3D; 0，就采用 AUTO-INC 锁；</li>
<li>当 innodb_autoinc_lock_mode &#x3D; 2，就采用轻量级锁；</li>
<li>当 innodb_autoinc_lock_mode &#x3D; 1，这个是默认值，两种锁混着用，如果能够确定插入记录的数量就采用轻量级锁，不确定时就采用 AUTO-INC 锁。</li>
</ul>
<p>不过，当 innodb_autoinc_lock_mode &#x3D; 2 是性能最高的方式，但是会带来一定的问题。因为并发插入的存在，在每次插入时，自增长的值可能不是连续的，<strong>这在有主从复制的场景中是不安全的</strong>。</p>
<h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>对记录加锁时，<strong>加锁的基本单位是 next-key lock</strong>，它是由记录锁和间隙锁组合而成的，<strong>next-key lock 是前开后闭区间，而间隙锁是前开后开区间</strong>。</p>
<h4 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h4><h5 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h5><p>记录锁也就是仅仅把一条记录锁上，官方的类型名称为：LOCK_REC_NOT_GAP。比如我们把id值为8的那条记录加一个记录锁的示意图如图所示。仅仅是锁住了i值为8的记录，对周围的数据没有影响。</p>
<p>记录锁是有S锁和X锁之分的，称之为S型记录锁和型记录锁。</p>
<ul>
<li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁。</li>
<li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li>
</ul>
<h5 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h5><p>查一个数据之间，比如3-8之间的，则会添加一个间隙锁，如果最后面之后的数，则一直从最后面到无穷大都被间隙锁锁住。</p>
<h5 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h5><p>有时候我们<strong>既想锁住某条记录</strong>，又想&#96;<strong>阻止</strong>其他事务在该记录前边的<strong>间隙插入新记录</strong>，所以InnoDB就提出了一种称之为Next-Key Locks的锁，官方的类型名称为：LOCK_ORDINARY,我们也可以简称为next-key锁。NextKey Locks是在存储擎innodb、事务级别在<strong>可重复读</strong>的情况下使用的数据库锁，innodb默认的锁就是Next-Keylocks。比如，我们把id值为8的那条记录加一个next-key锁的示意图如下：</p>
<h4 id="唯一索引等值查询"><a href="#唯一索引等值查询" class="headerlink" title="唯一索引等值查询"></a>唯一索引等值查询</h4><ul>
<li><strong>当查询的记录是存在的，在用「唯一索引进行等值查询」时，next-key lock 会退化成「记录锁」</strong>。</li>
<li><strong>当查询的记录是不存在的，在用「唯一索引进行等值查询」时，next-key lock 会退化成「间隙锁」</strong>。</li>
</ul>
<h4 id="唯一索引范围查询"><a href="#唯一索引范围查询" class="headerlink" title="唯一索引范围查询"></a>唯一索引范围查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_test where id&gt;=<span class="number">8</span> and id&lt;<span class="number">9</span> <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure>

<ol>
<li>由于是范围查找，就会继续往后找存在的记录，也就是会找到 id &#x3D; 16 这一行停下来，然后加 next-key lock (8, 16]，但由于 id &#x3D; 16 不满足 id &lt; 9，所以会退化成间隙锁，加锁范围变为 (8, 16)。</li>
</ol>
<h4 id="非唯一索引等值查询："><a href="#非唯一索引等值查询：" class="headerlink" title="非唯一索引等值查询："></a>非唯一索引等值查询：</h4><ul>
<li>当查询的记录存在时，除了会加 next-key lock 外，还额外加间隙锁，也就是会加两把锁。<ul>
<li>先会对普通索引 b 加上 next-key lock，范围是(4,8]（查询8）</li>
<li>然后因为是非唯一索引，且查询的记录是存在的，所以还会加上间隙锁，规则是向下遍历到第一个不符合条件的值才能停止，因此间隙锁的范围是(8,16)。</li>
</ul>
</li>
<li>当查询的记录不存在时，只会加 next-key lock，然后会退化为间隙锁，也就是只会加一把锁。<ul>
<li>先会对普通索引 b 加上 next-key lock，范围是(8,16];</li>
<li>但是由于查询的记录是不存在的，所以不会再额外加个间隙锁，但是 next-key lock 会退化为间隙锁，最终加锁范围是 (8,16)。</li>
</ul>
</li>
</ul>
<h4 id="非唯一索引和主键索引的范围查询的加锁规则不同之处在于："><a href="#非唯一索引和主键索引的范围查询的加锁规则不同之处在于：" class="headerlink" title="非唯一索引和主键索引的范围查询的加锁规则不同之处在于："></a>非唯一索引和主键索引的范围查询的加锁规则不同之处在于：</h4><ul>
<li>唯一索引在满足一些条件的时候，next-key lock 退化为间隙锁和记录锁。</li>
<li>非唯一索引范围查询，next-key lock 不会退化为间隙锁和记录锁。</li>
</ul>
<ol>
<li>最开始要找的第一行是 b &#x3D; 8，因此 next-key lock(4,8]，但是由于 b 不是唯一索引，并不会退化成记录锁。</li>
<li>但是由于是范围查找，就会继续往后找存在的记录，也就是会找到 b &#x3D; 16 这一行停下来，然后加 next-key lock (8, 16]，因为是普通索引查询，所以并不会退化成间隙锁。</li>
</ol>
<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h2><h3 id="Java语言的特点？"><a href="#Java语言的特点？" class="headerlink" title="Java语言的特点？"></a>Java语言的特点？</h3><ol>
<li>简单易学；</li>
<li>面向对象（封装，继承，多态）；</li>
<li>平台无关性（ Java 虚拟机实现平台无关性）；</li>
<li>支持多线程</li>
<li>可靠性；</li>
<li>安全性；</li>
<li>支持网络编程并且很方便</li>
<li>编译与解释并存</li>
</ol>
<h3 id="为什么说Java编译与解释共存？"><a href="#为什么说Java编译与解释共存？" class="headerlink" title="为什么说Java编译与解释共存？"></a>为什么说Java编译与解释共存？</h3><p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><h4 id="区别-2"><a href="#区别-2" class="headerlink" title="区别"></a>区别</h4><ul>
<li><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li>
<li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li>
</ul>
<p>深拷贝和浅拷贝最根本的区别在于是否真正获取一个对象的复制实体，而不是引用。</p>
<h4 id="具体应用场景"><a href="#具体应用场景" class="headerlink" title="具体应用场景"></a>具体应用场景</h4><p>浅拷贝</p>
<ol>
<li>直接引用对应类，并进行修改</li>
</ol>
<p>深拷贝</p>
<ol>
<li>构造函数</li>
<li>重载clone()方法</li>
<li>Apache Commons Lang序列化</li>
<li>Gson</li>
<li>Jackson序列化</li>
</ol>
<h3 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h3><ul>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li>
<li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li>
</ul>
<h3 id="什么是序列化？什么是反序列化？"><a href="#什么是序列化？什么是反序列化？" class="headerlink" title="什么是序列化？什么是反序列化？"></a>什么是序列化？什么是反序列化？</h3><ul>
<li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>
</ul>
<h3 id="JVM-vs-JDK-vs-JRE"><a href="#JVM-vs-JDK-vs-JRE" class="headerlink" title="JVM vs JDK vs JRE"></a>JVM vs JDK vs JRE</h3><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>
<p>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
<p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>
<h3 id="Java八大基础类型"><a href="#Java八大基础类型" class="headerlink" title="Java八大基础类型"></a>Java八大基础类型</h3><p>byte 1字节</p>
<p>short 2字节</p>
<p>int 4字节</p>
<p>long 8字节</p>
<p>float 4字节</p>
<p>double 8字节</p>
<p>char 2字节</p>
<p>boolean 1字节</p>
<h3 id="成员变量与局部变量的区别"><a href="#成员变量与局部变量的区别" class="headerlink" title="成员变量与局部变量的区别"></a>成员变量与局部变量的区别</h3><ol>
<li>位置不同，成员变量在类中方法外面，局部变量在方法或者代码块上</li>
<li>在内存的位置不同，成员变量在堆中，局部变量在栈里</li>
<li>生命周期不同，成员变量随对象，局部变量代码块执行完毕或者方法调用完毕就会消失</li>
<li>成员变量有默认初始值，局部变量没有默认初始值</li>
</ol>
<h3 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><ul>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li>
<li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li>
</ul>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="BIO、NIO、BIO"><a href="#BIO、NIO、BIO" class="headerlink" title="BIO、NIO、BIO?"></a>BIO、NIO、BIO?</h3><ul>
<li>BIO(Blocking IO)属于同步阻塞IO模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</li>
<li>NIO (Non-blocking&#x2F;New I&#x2F;O)，同步非阻塞 IO 模型，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>,多路复用器轮询来注册对应的channel，在IO操作时候再用一个线程处理就可以了，也就是一个请求一个线程，有缓冲区进行缓冲。</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220817112549978.png" alt="image-20220817112549978"></p>
<ul>
<li>AIO (Asynchronous I&#x2F;O)AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型，异步 IO 是基于事件和回调机制实现的，也就是应用操作之后<strong>会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</strong></li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220817112645364.png" alt="image-20220817112645364"></p>
<p>最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220817112700752.png" alt="image-20220817112700752"></p>
<h3 id="字节流和字符流的区别？"><a href="#字节流和字符流的区别？" class="headerlink" title="字节流和字符流的区别？"></a>字节流和字符流的区别？</h3><ol>
<li>字节流可用于任何类型的对象，包括二进制对象，而字符流只能处理字符或者字符串</li>
<li>字节流提供了处理任何类型的IO操作的功能，但它不能直接处理Unicode字符，而字符流就可以处理Unicode字符</li>
<li>字节流操作的基本单元是字节；字符流操作的基本单元是字符</li>
<li>字节流默认不使用缓冲区；字符流使用缓冲区</li>
</ol>
<h2 id="Object类下的方法"><a href="#Object类下的方法" class="headerlink" title="Object类下的方法"></a>Object类下的方法</h2><p><strong>（1）clone方法</strong></p>
<p>保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。</p>
<p><strong>（2）getClass方法</strong></p>
<p>final方法，获得运行时类型。</p>
<p><strong>（3）toString方法</strong></p>
<p>该方法用得比较多，一般子类都有覆盖。</p>
<p><strong>（4）finalize方法</strong></p>
<p>该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。</p>
<p><strong>（5）equals方法</strong></p>
<p>该方法是非常重要的一个方法。一般equals和&#x3D;&#x3D;是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。</p>
<p><strong>（6）hashCode方法</strong></p>
<p>该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。</p>
<p>一般必须满足obj1.equals(obj2)&#x3D;&#x3D;true。可以推出obj1.hash- Code()&#x3D;&#x3D;obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。</p>
<p><strong>（7）wait方法</strong></p>
<p>wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。</p>
<p>调用该方法后当前线程进入睡眠状态，直到以下事件发生。</p>
<p>（1）其他线程调用了该对象的notify方法。</p>
<p>（2）其他线程调用了该对象的notifyAll方法。</p>
<p>（3）其他线程调用了interrupt中断该线程。</p>
<p>（4）时间间隔到了。</p>
<p>此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。</p>
<p><strong>（8）notify方法</strong></p>
<p>该方法唤醒在该对象上等待的某个线程。</p>
<p><strong>（9）notifyAll方法</strong></p>
<p>该方法唤醒在该对象上等待的所有线程。</p>
<h2 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h2><ol>
<li>抽象类体现继承关系，一个类只能单继承，接口体现实现关系，一个类可以多实现。</li>
<li>抽象类有构造方法，用于子类实例化使用，接口中没有构造方法</li>
<li>接口和接口支持多继承，类之间只能单继承</li>
<li>抽象类可以有具体的方法 和属性, 接口只能有抽象方法和不可变常量</li>
</ol>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类和普通类的主要有三点区别：</p>
<p>1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。</p>
<p>2）抽象类不能用来创建对象；</p>
<p>3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。</p>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><ol>
<li>重载是发生在同一个类当中的，方法名字相同参数列表不同，重写是发生在有继承关系的类当中的，返回值和形参不能改变</li>
<li>重载的访问等级可以修改，重写的访问等级可以降低，但不能提高</li>
<li>重载的异常可以修改，重写的异常可以减少会删除，不能更广</li>
<li>重载的返回类型可以修改，而重写不能</li>
</ol>
<h2 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>所谓的不可变类是指这个类的实例一旦创建完成后，就不能改变其成员变量值。如JDK内部自带的很多不可变类：Interger、Long和String等。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>线程安全，由于属性不可变保证了线程安全。</li>
<li>易于构造、使用和设计。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>对象会创建的特别多</li>
<li>可能会存在性能瓶颈，因为要频繁的拷贝对象</li>
</ol>
<h2 id="int和Integer的区别"><a href="#int和Integer的区别" class="headerlink" title="int和Integer的区别"></a>int和Integer的区别</h2><ul>
<li>存储位置不同，int 存储在栈中Integer 对象的引用存储在栈空间中，对象的数据存储在堆空间中。</li>
<li>初始值不同，int 初始化值为0，Integer 初始化值为null。</li>
<li>Integer是Int的包装类，Int是八种基本数据类型之一。</li>
<li>Integer变量必须实例化以后才可以使用，而Int变量不需要实例化。</li>
</ul>
<h3 id="怎么判断int和Integer是否相等？"><a href="#怎么判断int和Integer是否相等？" class="headerlink" title="怎么判断int和Integer是否相等？"></a>怎么判断int和Integer是否相等？</h3><p>Integer对象和int使用&#x3D;&#x3D;进行比较是会使用Integer.intValue进行拆箱，比较的就是int值，返回的是true</p>
<h2 id="编译型和解释型语言"><a href="#编译型和解释型语言" class="headerlink" title="编译型和解释型语言"></a>编译型和解释型语言</h2><ul>
<li><strong>编译型</strong> ：编译型语言open in new window会通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</li>
<li><strong>解释型</strong> ：解释型语言open in new window会通过解释器open in new window一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220729080301788.png" alt="image-20220729080301788"></p>
<p>为了优化Java的性能 ，JVM在解释器之外引入了即时（Just In Time）编译器：当程序运行时，解释器首先发挥作用，代码可以直接执行。随着时间推移，即时编译器逐渐发挥作用，把越来越多的代码编译优化成本地代码，来获取更高的执行效率。解释器这时可以作为编译运行的降级手段，在一些不可靠的编译优化出现问题时，再切换回解释执行，保证程序可以正常运行。</p>
<p>即时编译器极大地提高了Java程序的运行速度，而且跟静态编译相比，即时编译器可以选择性地编译热点代码，省去了很多编译时间，也节省很多的空间。目前，即时编译器已经非常成熟了，在性能层面甚至可以和编译型语言相比。不过在这个领域，大家依然在不断探索如何结合不同的编译方式，使用更加智能的手段来提升程序的运行速度。</p>
<h2 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><p>区别：  </p>
<ol>
<li>编程思路不同：面向过程以实现功能的函数开发为主，而面向对象要首先抽象出类、属性及其方法，然后通过实例化类、执行方法来完成功能。</li>
<li>封装性：都具有封装性，但是面向过程是封装是功能，而面向对象封装的是数据和功能。</li>
<li>面向对象具有继承性和多态性，而面向过程没有继承性和多态性，所以面向对象优势很明显。</li>
</ol>
<h2 id="Java三大特性"><a href="#Java三大特性" class="headerlink" title="Java三大特性"></a>Java三大特性</h2><p>继承性、封装、多态</p>
<p>多态是同一个行为具有多个不同表现形式或形态的能力。</p>
<p>多态就是同一个接口，使用不同的实例而执行不同操作，如图所示：</p>
<p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="实现多态的必要条件"><a href="#实现多态的必要条件" class="headerlink" title="实现多态的必要条件"></a>实现多态的必要条件</h3><ol>
<li>子类重写父类方法。</li>
<li>向上转型。</li>
</ol>
<h3 id="多态底层原理"><a href="#多态底层原理" class="headerlink" title="多态底层原理"></a>多态底层原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is Father&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is Son&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDemo</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">            <span class="type">Father</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">            s.test();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220728115002308.png" alt="image-20220728115002308"></p>
<p>当我们在执行代码的时候，首先根据我们所写的语法在栈内存上会创建相对应的引用变量s，相应地在堆内存上开辟空间创建Son的实例对象，并且引用s指向它的实例Son，由类的加载过程我们可知道我们所编写的Class文件会在JVM方法区上建立储存它所含有的类型信息（成员变量、类变量、方法等）并且还会得到一个Class对象（通过反射机制）建立在堆区上，该Class对象会作为方法区访问数据的入口。<br>结合同名方法偏移量相同且是固定的，则在调用方法时，首先会对实例方法的符号引用进行解析，解析的结果就是方法表的偏移量。当我们把子类对象声明为父类类型时，明面上虚拟机通过对象引用的类型得到该类型方法区中类型信息的入口，去查询该类型的方法表（即例中的Father），得到的是父类型的方法表中的test方法的偏移量，<strong>但实际上编译器通过类加载过程获取到Class对象知道了实例对象s的真正类型，转而进入到了真正的子类类型（例中的Son）的方法表中用偏移量寻找方法</strong>，恰好两者偏移量是相等的，我们就顺利成章的拿到了Son类型方法表中的test方法进而去指向test方法入口</p>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><h3 id="String，StringBuilder和StringBuffer的区别"><a href="#String，StringBuilder和StringBuffer的区别" class="headerlink" title="String，StringBuilder和StringBuffer的区别"></a>String，StringBuilder和StringBuffer的区别</h3><p><code>String</code> 是不可变的（后面会详细分析原因）。</p>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
<p><strong>线程安全性</strong></p>
<p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h3 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h3><ol>
<li>length()返回字符串长度</li>
<li>charAt()获取位置上的某个字符</li>
<li>indexOf()返回第一次数显的位置</li>
<li>contains()判断是否包含子串</li>
<li>isEmpty()判断是否为空</li>
<li>equals()判断是否相等</li>
<li>equalsIgnoreCase()判断是否相同，忽略大小写</li>
<li>toCharArray()转换为字符串数组</li>
</ol>
<h3 id="String为什么设置为final类型"><a href="#String为什么设置为final类型" class="headerlink" title="String为什么设置为final类型"></a>String为什么设置为final类型</h3><ol>
<li>final修饰的String，代表这个类不能被继承，而String是一个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=char%E7%B1%BB%E5%9E%8B&spm=1001.2101.3001.7020">char类型</a>的数组，证明它是不可更改的，但这也仅仅是引用地址不可改，再加上被private修饰，证明数组本身也不会改变。只有当字符串本身也不会变的时候才可以使用字符串池，这样节省空间</li>
<li><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=String%E7%B1%BB&spm=1001.2101.3001.7020">String类</a>被final修饰不能被继承，无法修改，在多线程情况下也是安全的。</li>
</ol>
<h3 id="String底层用什么存储数据？"><a href="#String底层用什么存储数据？" class="headerlink" title="String底层用什么存储数据？"></a>String底层用什么存储数据？</h3><ul>
<li>在 Java 8 中，String 内部使用 char 数组存储数据</li>
<li>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。</li>
</ul>
<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><h4 id="String怎么计算hashCode-的？"><a href="#String怎么计算hashCode-的？" class="headerlink" title="String怎么计算hashCode()的？"></a>String怎么计算hashCode()的？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="hashCode-存储在哪里？"><a href="#hashCode-存储在哪里？" class="headerlink" title="hashCode()存储在哪里？"></a>hashCode()存储在哪里？</h4><p>hashCode存储在对象头里</p>
<h3 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h3><p>String是final修饰的，不可变，每次操作都会产生新的String对象<br>StringBuffer和StringBuilder都是在原对象上操作<br>StringBuffer是线程安全的，StringBuilder线程不安全的<br>StringBuffer方法都是synchronized修饰的<br>性能：StringBuilder&gt;StringBuffer&gt;String<br>场景：经常需要改变字符串内容时使用后面两个<br>优先使用StringBuilder,多线程使用共享变量时使用StringBuffer</p>
<h2 id="x3D-x3D-和-equals-的区别"><a href="#x3D-x3D-和-equals-的区别" class="headerlink" title="&#x3D;&#x3D; 和 equals()的区别"></a>&#x3D;&#x3D; 和 equals()的区别</h2><ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<p><code>Object</code> 类 <code>equals()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么重写equals还要重写hashCode"><a href="#为什么重写equals还要重写hashCode" class="headerlink" title="为什么重写equals还要重写hashCode()"></a>为什么重写equals还要重写hashCode()</h2><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220812082435159.png" alt="image-20220812082435159"></p>
<h3 id="Exception和Erroer有什么区别？"><a href="#Exception和Erroer有什么区别？" class="headerlink" title="Exception和Erroer有什么区别？"></a>Exception和Erroer有什么区别？</h3><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p>
<ul>
<li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li>
<li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<h3 id="常见受检时异常"><a href="#常见受检时异常" class="headerlink" title="常见受检时异常"></a>常见受检时异常</h3><ol>
<li>IOException</li>
<li>ClassNotFoundException</li>
</ol>
<h3 id="常见非受检时异常"><a href="#常见非受检时异常" class="headerlink" title="常见非受检时异常"></a>常见非受检时异常</h3><ol>
<li>NullPointerException  输出一个null的</li>
</ol>
<ul>
<li><pre><code>                ArrayIndexOutOfBoundsException
</code></pre>
</li>
<li><pre><code>                ClassCastException
</code></pre>
</li>
<li><pre><code>                NumberFormatException
</code></pre>
</li>
<li><pre><code>                InputMismatchException
</code></pre>
</li>
<li><pre><code>                ArithmeticException
</code></pre>
</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="Java-的泛型是如何工作的-什么是类型擦除"><a href="#Java-的泛型是如何工作的-什么是类型擦除" class="headerlink" title="Java 的泛型是如何工作的 ? 什么是类型擦除 ?"></a>Java 的泛型是如何工作的 ? 什么是类型擦除 ?</h3><p>泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List&lt;String&gt; 在运行时仅用一个 List 来表示。这样做的目的，是确保能和 Java 5 之前的版本开发二进制类库进行兼容。</p>
<p>类型擦除：泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 &lt; T &gt; 则会被转译成普通的 Object 类型，如果指定了上限如 &lt; T extends String &gt; 则类型参数就被替换成类型上限。</p>
<h3 id="什么是泛型中的限定通配符和非限定通配符"><a href="#什么是泛型中的限定通配符和非限定通配符" class="headerlink" title="什么是泛型中的限定通配符和非限定通配符 ?"></a>什么是泛型中的限定通配符和非限定通配符 ?</h3><p>限定通配符对类型进行了限制。有两种限定通配符，一种是&lt; ? extends T &gt; 它通过确保类型必须是 T 的子类来设定类型的上界，另一种是&lt; ? super T &gt;它通过确保类型必须是 T 的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面 &lt; ? &gt; 表示了非限定通配符，因为 &lt; ? &gt; 可以用任意类型来替代。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h3><ol>
<li><p>反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化；</p>
</li>
<li><p>每个类都会有一个与之对应的Class实例，从而每个类都可以获取method反射方法，并作用到其他实例身上；</p>
</li>
<li><p>反射也是考虑了线程安全的，放心使用；</p>
</li>
<li><p>反射使用软引用relectionData缓存class信息，避免每次重新从jvm获取带来的开销；</p>
</li>
<li><p>反射调用多次生成新代理Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器；</p>
</li>
<li><p>当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；</p>
</li>
<li><p>调度反射方法，最终是由jvm执行invoke0()执行；</p>
</li>
</ol>
<ul>
<li><strong>准备阶段</strong>：编译期装载所有的类，将每个类的元信息保存至Class类对象中，每一个类对应一个Class对象</li>
<li><strong>获取Class对象</strong>：调用x.class&#x2F;x.getClass()&#x2F;Class.forName() 获取x的Class对象clz（这些方法的底层都是native方法，是在JVM底层编写好的，涉及到了JVM底层，就先不进行探究了）</li>
<li><strong>进行实际反射操作</strong>：通过clz对象获取Field&#x2F;Method&#x2F;Constructor对象进行进一步操作</li>
</ul>
<h3 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h3><p>在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；</p>
<p>对于任意一个对象，都能够调用它的任意一个方法和属性</p>
<p>这种动态获取信息以及动态调用对象的方法的功能称为java语言的反射机制</p>
<h3 id="反射的优点"><a href="#反射的优点" class="headerlink" title="反射的优点"></a>反射的优点</h3><p>反射提高了程序的灵活性和扩展性，降低耦合性，提高自适应能力。它允许程序创建和控制任何类的对象，无需提前硬编码目标类</p>
<h3 id="反射的缺点"><a href="#反射的缺点" class="headerlink" title="反射的缺点"></a>反射的缺点</h3><p>性能问题，使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和扩展性要求很高的系统框架上，普通程序不建议使用</p>
<h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><ul>
<li><p>Spring框架中的IOC或者Spring的AOP</p>
</li>
<li><p>JDBC使用Class.forName()通过反射加载数据库的驱动程序</p>
</li>
</ul>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><ol>
<li><p>.final关键字用于修饰类：</p>
<ul>
<li><strong>使用当前这个类不能有任何子类</strong>（“太监类”），例如<strong>被final修饰过后的父类，子类将不再能进行继承</strong></li>
</ul>
</li>
<li><p>final关键字用于修饰成员方法：</p>
<ul>
<li>当final关键字用来修饰一个方法的时候，这个方法就是最终方法，<strong>不能够被覆盖重写</strong> <strong>注意</strong>：对于类、方法来说，abstract关键字和final关键字不能同时使用，因为作用相互矛盾</li>
</ul>
</li>
<li><p>final关键字用于修饰局部变量：</p>
<ul>
<li>当final关键字用于修饰局部变量的时候，这个<strong>局部变量就不能更改，“一次赋值，终生不变”</strong> <strong>注意</strong>：对于 <em>基本类型</em> 来说，不可改变指的是<strong>变量当中的数据不可改变</strong>，但是对于 <em>引用类型</em> 来说，不可改变的指的是<strong>变量当中的地址值不可改变</strong></li>
</ul>
</li>
<li><h3 id="final关键字用于修饰成员变量："><a href="#final关键字用于修饰成员变量：" class="headerlink" title="final关键字用于修饰成员变量："></a>final关键字用于修饰成员变量：</h3><ul>
<li>对于成员变量来说，如果使用了final关键字修饰，那么这个变量也照样是不可变的 ① 由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了 ② 对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值，只能二选一 ③ 必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值</li>
</ul>
</li>
</ol>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="集合类详情"><a href="#集合类详情" class="headerlink" title="集合类详情"></a>集合类详情</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220807082301849.png" alt="image-20220807082301849"></p>
<h3 id="ArrayList和LinkedList区别"><a href="#ArrayList和LinkedList区别" class="headerlink" title="ArrayList和LinkedList区别"></a>ArrayList和LinkedList区别</h3><p><strong>LinkedList</strong></p>
<ol>
<li>基于双向链表，无需连续内存</li>
<li>随机访问慢（要沿着链表遍历）</li>
<li>头尾插入删除性能高</li>
<li>占用内存多</li>
</ol>
<p><strong>ArrayList</strong></p>
<ol>
<li>基于数组，需要连续内存</li>
<li>随机访问快（指根据下标访问）实现了RandomAccess</li>
<li>尾部插入、删除性能可以，其它部分插入、删除都会移动数据，因此性能会低</li>
<li>可以利用 cpu 缓存，局部性原理（把数据和相邻的数据读入）</li>
</ol>
<p>ArrayList没有扩张访问复杂度O（1），发生扩张复杂度为O（n），LinkedList插入复杂度为O（1）</p>
<h3 id="fail-fast机制"><a href="#fail-fast机制" class="headerlink" title="fail-fast机制"></a>fail-fast机制</h3><p>fail-fast 机制，即快速失败机制，是java集合(Collection)中的一种错误检测机制。当在迭代集合的过程中该集合在结构上发生改变的时候，就有可能会发生fail-fast，即抛出 ConcurrentModificationException异常。fail-fast机制并不保证在不同步的修改下一定会抛出异常，它只是尽最大努力去抛出，所以这种机制一般仅用于检测bug。</p>
<h3 id="异常的类别"><a href="#异常的类别" class="headerlink" title="异常的类别"></a>异常的类别</h3><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="底层数据结构，1-7和1-8有何不同？"><a href="#底层数据结构，1-7和1-8有何不同？" class="headerlink" title="底层数据结构，1.7和1.8有何不同？"></a>底层数据结构，1.7和1.8有何不同？</h4><ul>
<li>1.7 数组 + 链表</li>
<li>1.8 数组 + （链表 | 红黑树）</li>
</ul>
<p>key值计算，首先经过两次哈希，<strong>最后用第二次哈希值对总容量进行取模运算</strong>。</p>
<p>扩容规则<strong>当超过容量乘以负载因子就会发生扩容，扩容为一倍</strong></p>
<h4 id="树化与退化"><a href="#树化与退化" class="headerlink" title="树化与退化"></a>树化与退化</h4><p><strong>树化意义</strong></p>
<ul>
<li>红黑树用来避免 DoS 攻击，防止链表超长时性能下降，树化应当是偶然情况，是保底策略，如果 hashCode的分布离散良好的话，那么红黑树是很少会被用到的，因为各个值都均匀分布，很少出现链表很长的情况。在理想情况下，链表长度符合泊松分布，各个长度的命中概率依次递减，注释中给我们展示了1-8长度的具体命中概率，当长度为8的时候，概率概率仅为0.00000006，这么小的概率，HashMap的红黑树转换几乎不会发生，因为我们日常使用不会存储那么多的数据，你会存上千万个数据到HashMap中吗？（为什么八个元素从树化）</li>
<li>hash 表的查找，更新的时间复杂度是 O(1)，而红黑树的查找，更新的时间复杂度是 O(log_2⁡n )，TreeNode 占用空间也比普通 Node 的大，如非必要，尽量还是使用链表</li>
<li>hash 值如果足够随机，则在 hash 表内按泊松分布，在负载因子 0.75 的情况下，长度超过 8 的链表出现概率是 0.00000006，树化阈值选择 8 就是为了让树化几率足够小</li>
</ul>
<p><strong>树化规则</strong></p>
<ul>
<li>当链表长度超过树化阈值 8 时，先尝试扩容来减少链表长度，如果数组容量已经 &gt;&#x3D;64，才会进行树化</li>
</ul>
<p><strong>退化规则</strong></p>
<ul>
<li>情况1：在扩容时如果拆分树时，树元素个数 &lt;&#x3D; 6 则会退化链表</li>
<li>情况2：remove 树节点时，若移除之前 <strong>root、root.left、root.right、root.left.left</strong> 有一个为 null ，也会退化为链表</li>
</ul>
<h4 id="索引计算"><a href="#索引计算" class="headerlink" title="索引计算"></a>索引计算</h4><p><strong>索引计算方法</strong></p>
<ul>
<li>首先，计算对象的 hashCode()</li>
<li>再进行调用 HashMap 的 hash() 方法进行二次哈希  (h &#x3D; key.hashCode) ^ (h &gt;&gt;&gt; 16) <ul>
<li>二次 hash() 是为了综合高位数据，让哈希分布更为均匀</li>
</ul>
</li>
<li>最后 &amp; (capacity – 1) 得到索引</li>
</ul>
<p><strong>数组容量为何是 2 的 n 次幂</strong></p>
<ol>
<li>计算索引时效率更高：<strong>如果是 2 的 n 次幂可以使用位与运算代替取模</strong></li>
<li><strong>扩容</strong>时重新计算索引效率更高： hash &amp; oldCap &#x3D;&#x3D; 0 的元素留在原来位置 ，否则新位置 &#x3D; 旧位置 + oldCap</li>
</ol>
<p><strong>注意</strong></p>
<ul>
<li>二次 hash 是为了配合 <strong>容量是 2 的 n 次幂</strong> 这一设计前提，如果 hash 表的容量不是 2 的 n 次幂，则不必二次 hash</li>
<li><strong>容量是 2 的 n 次幂</strong> 这一设计计算索引效率更好，但 hash 的分散性就不好，需要二次 hash 来作为补偿，没有采用这一设计的典型例子是 Hashtable</li>
</ul>
<h4 id="put-与扩容"><a href="#put-与扩容" class="headerlink" title="put 与扩容"></a>put 与扩容</h4><p><strong>put 流程</strong></p>
<ol>
<li>HashMap 是懒惰创建数组的，首次使用才创建数组</li>
<li>计算索引（桶下标）</li>
<li>如果桶下标还没人占用，创建 Node 占位返回</li>
<li>如果桶下标已经有人占用<ol>
<li>已经是 TreeNode 走红黑树的添加或更新逻辑</li>
<li>是普通 Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑</li>
</ol>
</li>
<li>返回前检查容量是否超过阈值，一旦超过进行扩容（先把节点放到旧数组后然后迁移元素）</li>
</ol>
<p><strong>1.7 与 1.8 的区别</strong></p>
<ol>
<li><p>链表插入节点时，1.7 是头插法，1.8 是尾插法</p>
</li>
<li><p><strong>1.7 是大于等于阈值且此时添加的索引位置没有空位时才扩容</strong>，例如索引值为10，此时上面没有元素，则不扩容，若有空位则扩容，而 1.8 是大于阈值就扩容</p>
</li>
<li><p>1.8 在扩容计算 Node 索引时，会优化</p>
</li>
</ol>
<p><strong>扩容（加载）因子为何默认是 0.75f</strong></p>
<ol>
<li>在空间占用与查询时间之间取得较好的权衡</li>
<li>大于这个值，空间节省了，但链表就会比较长影响性能</li>
<li>小于这个值，冲突减少了，但扩容就会更频繁，空间占用也更多</li>
</ol>
<h4 id="HashMap线程安全吗？"><a href="#HashMap线程安全吗？" class="headerlink" title="HashMap线程安全吗？"></a>HashMap线程安全吗？</h4><h5 id="扩容死链（1-7-会存在）"><a href="#扩容死链（1-7-会存在）" class="headerlink" title="扩容死链（1.7 会存在）"></a>扩容死链（1.7 会存在）</h5><p>因为1.7是头插法，1.8是尾插法，所以导致会有这个区别。</p>
<p>1.7 源码如下：<strong>e指向当前迁移元素，next指向下一个元素</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>e 和 next 都是局部变量，用来指向当前节点和下一个节点</li>
<li>线程1（绿色）的临时变量 e 和 next 刚引用了这俩节点，还未来得及移动节点，发生了线程切换，由线程2（蓝色）完成扩容和迁移</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831084325075.png" alt="image-20210831084325075"></p>
<ul>
<li>线程2 扩容完成，由于头插法，链表顺序颠倒。但线程1 的临时变量 e 和 next 还引用了这俩节点，还要再来一遍迁移</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831084723383.png" alt="image-20210831084723383"></p>
<ul>
<li>第一次循环<ul>
<li>循环接着线程切换前运行，注意此时 e 指向的是节点 a，next 指向的是节点 b</li>
<li>e 头插 a 节点，注意图中画了两份 a 节点，但事实上只有一个（为了不让箭头特别乱画了两份）</li>
<li>当循环结束时 e 会指向 next 也就是 b 节点</li>
</ul>
</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831084855348.png" alt="image-20210831084855348"></p>
<ul>
<li>第二次循环<ul>
<li>next 指向了节点 a</li>
<li>e 头插节点 b</li>
<li>当循环结束时，e 指向 next 也就是节点 a</li>
</ul>
</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831085329449.png" alt="image-20210831085329449"></p>
<ul>
<li>第三次循环<ul>
<li>next 指向了 null</li>
<li>e 头插节点 a，<strong>a 的 next 指向了 b</strong>（之前 a.next 一直是 null），b 的 next 指向 a，死链已成</li>
<li>当循环结束时，e 指向 next 也就是 null，因此第四次循环时会正常退出</li>
</ul>
</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20210831085543224.png" alt="image-20210831085543224"></p>
<h5 id="数据错乱（1-7，1-8-都会存在）"><a href="#数据错乱（1-7，1-8-都会存在）" class="headerlink" title="数据错乱（1.7，1.8 都会存在）"></a>数据错乱（1.7，1.8 都会存在）</h5><p>放入经过hash后同一个位置的数据，因为并发问题可能导致一个数据覆盖另一个数据，导致最终数据错乱，前面一个数据丢失。</p>
<h4 id="为什么Map桶中个数超过8才转为红黑树？"><a href="#为什么Map桶中个数超过8才转为红黑树？" class="headerlink" title="为什么Map桶中个数超过8才转为红黑树？"></a>为什么Map桶中个数超过8才转为红黑树？</h4><p>不过理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布，我们可以看到，一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。所以，之所以选择8，是根据概率统计决定的。</p>
<p>红黑树的平均查找长度是log(n)，如果长度为8，平均查找长度为log(8)&#x3D;3，链表的平均查找长度为n&#x2F;2，当长度为8时，平均查找长度为8&#x2F;2&#x3D;4，这才有转换成树的必要；链表长度如果是小于等于6，6&#x2F;2&#x3D;3，而log(6)&#x3D;2.6，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短.</p>
<h3 id="Hashtable-vs-ConcurrentHashMap"><a href="#Hashtable-vs-ConcurrentHashMap" class="headerlink" title="Hashtable vs ConcurrentHashMap"></a>Hashtable vs ConcurrentHashMap</h3><p><strong>Hashtable 对比 ConcurrentHashMap</strong></p>
<ul>
<li>Hashtable 与 ConcurrentHashMap 都是线程安全的 Map 集合</li>
<li>Hashtable 并发度低，整个 Hashtable 对应一把锁，同一时刻，只能有一个线程操作它</li>
<li>ConcurrentHashMap 并发度高，整个 ConcurrentHashMap 对应多把锁，只要线程访问的是不同锁，那么不会冲突</li>
</ul>
<p>HashTable每次扩容2*n+1</p>
<h4 id="ConcurrentHashMap-1-7"><a href="#ConcurrentHashMap-1-7" class="headerlink" title="ConcurrentHashMap 1.7"></a><strong>ConcurrentHashMap 1.7</strong></h4><ul>
<li>数据结构：<code>Segment(大数组容量clevel并发度不能扩容) + HashEntry(小数组) + 链表</code>，每个 Segment 对应一把锁，如果多个线程访问不同的 Segment，则不会冲突</li>
<li>*<em>capacity</em>loadfactor 为小数组的扩容值，一旦大于就扩容，各自小数组分别扩容，小数组等价于原来的HashMap的数组，<img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220322111243513.png" alt="image-20220322111243513">，初始segmment[0]小数组的容量为capacity&#x2F;clevel（最小值为2)**，其他小数组初始化根据这个[0]数组初始化</li>
<li>并发度：Segment 数组大小即并发度，决定了同一时刻最多能有多少个线程并发访问。Segment 数组不能扩容，意味着并发度在 ConcurrentHashMap 创建时就固定了</li>
<li>索引计算<ul>
<li>假设大数组长度是 $2^m$，key 在大数组内的索引是 key 的二次 hash 值的高 m 位</li>
<li>假设小数组长度是 $2^n$，key 在小数组内的索引是 key 的二次 hash 值的低 n 位</li>
</ul>
</li>
<li>扩容：每个小数组的扩容相对独立，小数组在超过扩容因子时会触发扩容，每次扩容翻倍</li>
<li>Segment[0] 原型：首次创建其它小数组时，会以此原型为依据，数组长度，扩容因子都会以原型为准</li>
</ul>
<h4 id="ConcurrentHashMap-1-8"><a href="#ConcurrentHashMap-1-8" class="headerlink" title="ConcurrentHashMap 1.8"></a><strong>ConcurrentHashMap 1.8</strong></h4><p>capcity为要放的数组元素个数，不是数组的个数，因为16放不下16个（只能放下capcity*loadfactor个数,只有初始化时会看loadfactor的值，否则按0.75计算），所以初始会为2^5即32个元素</p>
<ul>
<li>数据结构：<code>Node 数组 + 链表或红黑树</code>，数组的每个头节点作为锁，如果多个线程访问的头节点不同，则不会冲突。首次生成头节点时如果发生竞争，利用 cas 而非 syncronized，进一步提升性能</li>
<li>并发度：Node 数组有多大，并发度就有多大，与 1.7 不同，Node 数组可以扩容</li>
<li>扩容条件<strong>：Node 数组满 3&#x2F;4 时就会扩容</strong></li>
<li>扩容单位：以链表为单位从后向前迁移链表，迁移完成的将旧数组头节点替换为 ForwardingNode，当旧数组所有值都为ForwardingNode就用新数组替换。</li>
<li>扩容时并发 get<ul>
<li>根据是否为 ForwardingNode 来决定是在新数组查找还是在旧数组查找，不会阻塞</li>
<li>如果链表长度超过 1，<strong>则需要对节点进行复制（创建新节点）</strong>，怕的是节点迁移后 next 指针改变。</li>
<li>如果链表最后几个元素扩容后索引不变，则节点无需复制，</li>
</ul>
</li>
<li>扩容时并发 put<ul>
<li>如果 put 的线程与扩容线程操作的链表是同一个，put 线程会阻塞</li>
<li>如果 put 的线程操作的链表还未迁移完成，即头节点不是 ForwardingNode，则可以并发执行</li>
<li>如果 put 的线程操作的链表已经迁移完成，即头结点是 ForwardingNode，则可以协助扩容</li>
</ul>
</li>
<li>与 1.7 相比是懒惰初始化</li>
<li>capacity 代表预估的元素个数，capacity &#x2F; factory 来计算出初始数组大小，需要贴近 $2^n$ </li>
<li>loadFactor 只在计算初始数组大小时首次被使用，之后扩容固定为 3&#x2F;4</li>
<li>超过树化阈值时的扩容问题，如果容量已经是 64，直接树化，否则在原来容量基础上做 3 轮扩容</li>
</ul>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="OSI七层协议和TCP-x2F-IP四层协议"><a href="#OSI七层协议和TCP-x2F-IP四层协议" class="headerlink" title="OSI七层协议和TCP&#x2F;IP四层协议"></a>OSI七层协议和TCP&#x2F;IP四层协议</h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220812150731267.png" alt="image-20220812150731267"></p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220313185422470.png" alt="image-20220313185422470"></p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220531115851184.png" alt="image-20220531115851184"></p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220818102503236.png" alt="image-20220818102503236"></p>
<ol>
<li>应用层：特定应用对接收数据的处理</li>
<li>表示层：设备数据格式与网络标准数据格式转换</li>
<li>会话层：通信管理，建立和断开通信连接</li>
<li>传输层：管理两个网络终端之间的数据传输</li>
<li>网络层：网络地址管理和路由选择</li>
<li>数据链路层：传输有地址的帧以及错误检测功能。</li>
<li>物理层：比特流与电子信号之间的转换。</li>
</ol>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="http请求报文和响应报文包含什么？"><a href="#http请求报文和响应报文包含什么？" class="headerlink" title="http请求报文和响应报文包含什么？"></a>http请求报文和响应报文包含什么？</h4><p>下面提供了一个典型的HTTP请求报文: </p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /somedir/page・html HTTP/1.1 </span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www・someschool•edu </span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close </span><br><span class="line"><span class="attribute">User-agent</span><span class="punctuation">: </span>Mozilla/5•0</span><br><span class="line"><span class="attribute">Accept-language</span><span class="punctuation">: </span>fr</span><br></pre></td></tr></table></figure>

<p>请求行有3个字段：方法字段、URL字段和HTTP版本字段</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329122500251.png" alt="image-20220329122500251"></p>
<p>http 报文头分为两种，一种是请求报文头和响应报文头 包含一下几个部分：<strong>请求行，首部行和实体体</strong>。其中请求行包含了这个请求的方法：有 GET、  POST、PUT、HEAD、DELETE。还包含了 URL 字段和 HTTP 的版本。实体体中，<strong>如果使用的是 get 方法，那么实体体就为空，如果使用的是 post 方法，那么响应的文本内容就会放在实体体中。</strong>HEAD 方法类似于 GET 方法，但是发送一个 HEAD 请求是不会返回请求的对象的。一般用于调试。PUT 方法时允许用户上传对象到指定的 web 服务器上的指定路径。DELETE 就是删除 web 服务器上的对象。首部行里面的信息。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329125857983.png" alt="image-20220329125857983"></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK </span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close Date: Tue, 18 Aug 2015 15:44:04 GMT </span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/2.2.3 (CentOS) </span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Tuer 18 Aug 2015 15:11:03 GMT </span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>6821 </span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line">(data data data data data •••)</span><br></pre></td></tr></table></figure>

<p>我们仔细看一下这个响应报文。它有三个部分：一个初始状态行（status line） , 6个 首部行（headerline）,然后是实体体（entity body）o。</p>
<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><h5 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h5><ol>
<li>https的端口是443，而http的端口是80，且两者的连接方式不同；</li>
<li>http传输是明文的，而https是用ssl进行加密的，https的安全性更高；</li>
<li>https是需要申请证书的，而http不需要。</li>
</ol>
<h5 id="HTTPS的通信流程"><a href="#HTTPS的通信流程" class="headerlink" title="HTTPS的通信流程"></a>HTTPS的通信流程</h5><ol>
<li>客户端向服务端发起建立HTTPS请求<ul>
<li>客户端生成随机数R1 发送给服务端，告诉服务端自己支持哪些加密算法和哈希算法</li>
</ul>
</li>
<li>服务器向客户端发送数字证书。</li>
</ol>
<ul>
<li>服务端生成随机数R2，从客户端支持的加密算法中选择一种双方都支持的加密算法（此算法用于后面的会话密钥生成）和哈希算法用机构的证书公钥解密得到证书的内容和证书签名，服务端生成把证书、随机数R2、会话密钥生成算法，一同发给客户端。</li>
</ul>
<ol start="3">
<li>客户端验证数字证书，证书验证通过后客户端生成会话密钥（双向验证则此处客户端也会向服务器发送证书），利用服务器公钥生成密钥。<ul>
<li>用机构的证书公钥解密得到证书的内容和证书签名，内容包括网站的网址、网站的公钥、证书的有效期等。浏览器会先验证证书签名的合法性。签名通过后，浏览器验证证书记录的网址是否和当前网址是一致的，不一致会提示用户。如果网址一致会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，浏览器就可以安全使用证书中的网站公钥了。</li>
<li>浏览器生成一个随机数 R3，根据会话密钥算法使用R1、R2、R3生成会话密钥。</li>
<li>用服务端证书的公钥加密随机数R3并发送给服务端。</li>
</ul>
</li>
<li>服务器生成会话密钥（双向验证此处服务端也会对客户端的证书验证）。<ul>
<li>服务器用私钥解密客户端发过来的随机数R3</li>
<li>根据会话密钥算法使用R1、R2、R3生成会话密钥</li>
</ul>
</li>
<li>客户端与服务端开始进行加密会话。</li>
</ol>
<h5 id="数字证书的工作流程"><a href="#数字证书的工作流程" class="headerlink" title="数字证书的工作流程"></a>数字证书的工作流程</h5><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220805131205112.png" alt="image-20220805131205112"></p>
<h4 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h4><h5 id="区别-3"><a href="#区别-3" class="headerlink" title="区别"></a>区别</h5><ul>
<li>1.作用范围不同，Cokkie作用于客户端，Session作用于服务端</li>
<li>2.存取方式不同，Cookie只能存ASCLL,Session能保存任意类型</li>
<li>3.有效期不同，Cookie一般长期，Session一般失效时间比较短，客户端关闭或者Session超时都会失效</li>
<li>4、存取大小不同，Cookie保存数据不超过4K,Session可存储更多</li>
</ul>
<h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p>
<p>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p>
<h5 id="禁止了Cokkie怎么办"><a href="#禁止了Cokkie怎么办" class="headerlink" title="禁止了Cokkie怎么办"></a>禁止了Cokkie怎么办</h5><p>第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 <code>xxx?SessionID=123456...</code>。</p>
<p>第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。</p>
<h5 id="如何解决分布式Session问题？"><a href="#如何解决分布式Session问题？" class="headerlink" title="如何解决分布式Session问题？"></a>如何解决分布式Session问题？</h5><ul>
<li>Nginx ip_hash 策略，服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。</li>
<li>Session 复制，任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。</li>
<li>共享 Session，服务端无状态话，将用户的 Session 等信息使用缓存中间件来统一管理，保障分发到每一个服务器的响应结果都一致。</li>
</ul>
<p>一般采用第三种方式</p>
<h5 id="如何解决跨域问题？"><a href="#如何解决跨域问题？" class="headerlink" title="如何解决跨域问题？"></a>如何解决跨域问题？</h5><p>说起跨域请求，必须要了解浏览器的同源策略，同源策略&#x2F;SOP（Same origin policy）是一种约定，由 Netscape 公司 1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSFR 等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。</p>
<p>解决跨域请求的常用方法是：</p>
<ul>
<li>通过代理来避免，比如使用 Nginx 在后端转发请求，避免了前端出现跨域的问题。</li>
<li>通过 Jsonp 跨域</li>
<li>其它跨域解决方案</li>
</ul>
<h4 id="GET、POST、PUT的区别"><a href="#GET、POST、PUT的区别" class="headerlink" title="GET、POST、PUT的区别"></a>GET、POST、PUT的区别</h4><p>POST和PUT都有更改指定URI的语义，但PUT遵循幂等性，PUT两次请求相同，后一个请求会把前一个覆盖掉，一般用来改资源，POST请求后一个请求不会被前一个请求覆盖掉，一般用来增资源。</p>
<p>1、GET参数通过URL传递，POST放在Request body中。<br>2、GET请求会被浏览器<strong>主动cache</strong>，而POST不会，除非手动设置。<br>3、GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。<br>4、Get 请求中有非 ASCII 字符，会在请求之前进行转码，POST不用，因为POST在Request body中，通过 MIME，也就可以传输非 ASCII 字符。</p>
<h4 id="常见的响应码"><a href="#常见的响应码" class="headerlink" title="常见的响应码"></a>常见的响应码</h4><h5 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h5><ul>
<li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li>
</ul>
<h5 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="#2XX 成功"></a><a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html#_2xx-%E6%88%90%E5%8A%9F">#</a>2XX 成功</h5><ul>
<li><strong>200 OK</strong>   请求成功，信息在返回的响应报文中。</li>
<li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>
<li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li>
</ul>
<h5 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="#3XX 重定向"></a><a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html#_3xx-%E9%87%8D%E5%AE%9A%E5%90%91">#</a>3XX 重定向</h5><ul>
<li><strong>301 Moved Permanently</strong> ：永久性重定向</li>
<li><strong>302 Found</strong> ：临时性重定向</li>
<li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li>
<li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li>
<li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>
<li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>
</ul>
<h5 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="#4XX 客户端错误"></a><a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html#_4xx-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF">#</a>4XX 客户端错误</h5><ul>
<li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li>
<li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>
<li><strong>403 Forbidden</strong> ：请求被拒绝。</li>
<li><strong>404 Not Found</strong>：被请求的文档不在服务器上</li>
</ul>
<h5 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="#5XX 服务器错误"></a><a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html#_5xx-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF">#</a>5XX 服务器错误</h5><ul>
<li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li>
<li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</li>
<li><strong>505 HTTP Version Not Supported</strong>：服务器不支持请求报文使用的HTTP协议版本。</li>
</ul>
<h4 id="Content-length引发的问题"><a href="#Content-length引发的问题" class="headerlink" title="Content-length引发的问题"></a>Content-length引发的问题</h4><h4 id="Content-Length-gt-实际长度"><a href="#Content-Length-gt-实际长度" class="headerlink" title="Content-Length&gt;实际长度"></a>Content-Length&gt;实际长度</h4><p>如果Content-.Lengthl比实际的长度大，服务端&#x2F;客户端读取到消息结尾后，会等待下一个字节，自然会无响应直到超时。</p>
<h4 id="Content-Length-lt-实际长度"><a href="#Content-Length-lt-实际长度" class="headerlink" title="Content-Length &lt; 实际长度"></a>Content-Length &lt; 实际长度</h4><p>如果这个长度小于实际长度, 首次请求的消息会被截取, 比如参数为<code>param=piaoruiqing</code>, <code>Content-Length</code>为10, 那么这次请求的消息会被截取为: <code>param=piao</code>。</p>
<p>但, 仅仅是如此吗, 当然不, 我们再来看看第二次请求会发生什么让人意外的事情。</p>
<p>连续的两次请求, 第一次消息被截断, 而第二次没有发生预期的截断, 而是服务端抛出了异常: <code>Request method &#39;ruiqingPOST&#39; not supported</code>.刺不刺激 (ﾉ)ﾟДﾟ( )</p>
<p>那 <code>ruiqingPOST</code>是个什么神仙方法??? 此时, 凭着多年开发(DEBUG)经验练就的敏感度, 我们大致可以猜出, <strong>上一次请求被截取剩下的消息。</strong></p>
<p>导致这种情况的原因就是开启了<code>Connection:keep-alive</code>, 如果使用<code>Connection:close</code>, 所产生的现象就是每一次的请求都被截断, 但不会产生解析混乱(如将上一次剩下的消息拼接到后续的请求消息中).</p>
<h3 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h3><h4 id="电子邮件的发送过程？"><a href="#电子邮件的发送过程？" class="headerlink" title="电子邮件的发送过程？"></a><strong>电子邮件的发送过程？</strong></h4><p>比如我的邮箱是“<a href="mailto:&#x64;&#x61;&#98;&#x61;&#x69;&#x40;&#99;&#115;&#x7a;&#x68;&#x69;&#x6e;&#x61;&#110;&#46;&#99;&#x6f;&#x6d;">&#x64;&#x61;&#98;&#x61;&#x69;&#x40;&#99;&#115;&#x7a;&#x68;&#x69;&#x6e;&#x61;&#110;&#46;&#99;&#x6f;&#x6d;</a>”，我要向“<a href="mailto:&#x78;&#x69;&#x61;&#111;&#x6d;&#x61;&#64;&#x71;&#113;&#x2e;&#99;&#x6f;&#x6d;">&#x78;&#x69;&#x61;&#111;&#x6d;&#x61;&#64;&#x71;&#113;&#x2e;&#99;&#x6f;&#x6d;</a>”发送邮件，整个过程可以简单分为下面几步：</p>
<ol>
<li>通过 <strong>SMTP</strong> 协议，我将我写好的邮件交给163邮箱服务器（邮局）。</li>
<li>163邮箱服务器发现我发送的邮箱是qq邮箱，然后它使用SMTP协议将我的邮件转发到 qq邮箱服务器。</li>
<li>qq邮箱服务器接收邮件之后就通知邮箱为“<a href="mailto:&#x78;&#x69;&#97;&#111;&#109;&#97;&#x40;&#113;&#x71;&#x2e;&#x63;&#111;&#x6d;">&#x78;&#x69;&#97;&#111;&#109;&#97;&#x40;&#113;&#x71;&#x2e;&#x63;&#111;&#x6d;</a>”的用户来收邮件，然后用户就通过 <strong>POP3&#x2F;IMAP</strong> 协议将邮件取出。</li>
</ol>
<h4 id="如何判断邮箱是真正存在的？"><a href="#如何判断邮箱是真正存在的？" class="headerlink" title="如何判断邮箱是真正存在的？"></a>如何判断邮箱是真正存在的？</h4><p>很多场景(比如邮件营销)下面我们需要判断我们要发送的邮箱地址是否真的存在，这个时候我们可以利用 SMTP 协议来检测：</p>
<ol>
<li>查找邮箱域名对应的 SMTP 服务器地址</li>
<li>尝试与服务器建立连接</li>
<li>连接成功后尝试向需要验证的邮箱发送邮件</li>
<li>根据返回结果判定邮箱地址的真实性</li>
</ol>
<h4 id="POP3协议"><a href="#POP3协议" class="headerlink" title="POP3协议"></a>POP3协议</h4><p>用于接受邮件，按三个阶段工作，特许，事务处理以及更新。</p>
<p>底层采用TCP进行连接。</p>
<h4 id="IMAP协议"><a href="#IMAP协议" class="headerlink" title="IMAP协议"></a>IMAP协议</h4><p>更加新一些的邮件访问协议。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h4 id="DNS-的查询过程"><a href="#DNS-的查询过程" class="headerlink" title="DNS 的查询过程"></a>DNS 的查询过程</h4><p>首先通过 URL 找到主机名。比如 <a target="_blank" rel="noopener" href="http://www.baidu.com,**根据这个去浏览器缓存里面找,如果没有就去本机的/">www.baidu.com，**根据这个去浏览器缓存里面找，如果没有就去本机的</a> host 的文件找，在没有就去访问本地域名服务器<strong>，询问能不能找到这个主机 IP 地址的缓存。 再没有就通过迭代的方法，找</strong>根域名服务器，顶级、权威，最后返回一个 ip 地址给 DNS 应用**。 当发送一个 DNS 请求的时候，如果本地域名服务器中没有的话，本地域名服务器就会代理的作用将请求转发到 DNS 服务器层次结构中。</p>
<h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220330100416720.png" alt="image-20220330100416720"></p>
<p>至此我们的讨论一直忽略了 DNS系统 的一个非常重要特色：DNS缓存(DNS caching) o实际上，为了改善时延性能并减 少在因特网上到处传输的DNS报文数量， DNS广泛使用了缓存技术。DNS缓存的原 理非常简单。在一个请求链中，当某DNS 服务器接收一个DNS回答(例如，包含某 主机名到IP地址的映射)时，它能将映射 缓存在本地存储器中。例如，在图2・18 中，每当本地DNS服务器dns. nyu. edu从 某个DNS服务器接收到一个回答，它能够 缓存包含在该回答中的任何信息。如果在 DNS服务器中缓存了一台主机名&#x2F;IP地址 对，另一个对相同主机名的查询到达该 DNS服务器时，该DNS服务器就能够提供 所要求的IP地址，即使它不是该主机名的权威服务器。由于主机和主机名与IP地址间的映射并不是永久的，DNS服务器在一段时间后(通常设置为两天)将丢弃缓存的信息。</p>
<p>举一个例子，假定主机apricot, nyu. edu向dns. nyu. edu查询主机名cnn. com的IP地址。 此后，假定过了几个小时，纽约大学的另外一台主机如kiwi. nyu. edu也向dns. nyu. edu查询 相同的主机名。因为有了缓存，该本地DNS服务器可以立即返回cnn. com的IP地址，而不 必查询任何其他DNS服务器。本地DNS服务器也能够缓存TLD服务器的IP地址，因而允 许本地DNS绕过查询链中的根DNS服务器。事实上，因为缓存，除了少数DNS查询以外，根服务器被绕过了。</p>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><h5 id="三次握手的概念"><a href="#三次握手的概念" class="headerlink" title="三次握手的概念"></a>三次握手的概念</h5><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329083907417.png" alt="image-20220329083907417"></p>
<p> 刚开始客户端处于 closed 的状态，服务端处于 listen 状态。然后<br>   1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN（c）。此时客户端处于 SYN_Send 状态。</p>
<p>   2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</p>
<p>   3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。</p>
<p>   4、服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。</p>
<h5 id="三次握手作用"><a href="#三次握手作用" class="headerlink" title="三次握手作用"></a>三次握手作用</h5><p> 1、确认双方的接受能力、发送能力是否正常。<br> 2、指定自己的初始化序列号，为后面的可靠传送做准备。<br> 3、如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。</p>
<p>TCP 建⽴连接时，<strong>通过三次握⼿能防⽌历史连接的建⽴</strong>，能减少双⽅不必要的资源开销，能帮助双⽅同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输，发送RSA请求报文关掉当前连接。</p>
<h5 id="seq的作用"><a href="#seq的作用" class="headerlink" title="seq的作用"></a>seq的作用</h5><p>seq表示本次发送数据的偏移量，seq可以防止乱序，防止数据重复。</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><h5 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h5><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329085636059.png" alt="image-20220329085636059"></p>
<p>1、第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。</p>
<p>2、第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。</p>
<p>3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</p>
<p>4、第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</p>
<p>5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p>
<h5 id="为什么不能是三次挥手？"><a href="#为什么不能是三次挥手？" class="headerlink" title="为什么不能是三次挥手？"></a>为什么不能是三次挥手？</h5><p>如果在第三次挥手中客户端回复ACK后，<strong>服务器的数据还没发完</strong>，<strong>但只有三挥手，服务器只能选择关闭连接，这样客户端的数据就会不完整，与TCP可靠链接初衷相违背</strong></p>
<h5 id="为什么最后还要等待TIME-WAIT"><a href="#为什么最后还要等待TIME-WAIT" class="headerlink" title="为什么最后还要等待TIME_WAIT"></a>为什么最后还要等待TIME_WAIT</h5><p>  这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。<br>  至于 TIME_WAIT 持续的时间至少是一个报文的来回时间，即2MSL(Maximum Segment  Lifetime)。MSL 指一个片段在网络中最大的存活时间，一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。</p>
<h5 id="服务器存在大量-TIME-WAIT的原因"><a href="#服务器存在大量-TIME-WAIT的原因" class="headerlink" title="服务器存在大量 TIME-WAIT的原因"></a>服务器存在大量 TIME-WAIT的原因</h5><p>如果服务器有处于 TIME-WAIT 状态的 TCP，则说明是由服务器⽅主动发起的断开请求，一般是爬虫服务器的原因，此时服务器为客户端，爬虫服务器为服务端，处于高并发短连接的情况，<strong>业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间</strong>，，比如取一个web页面，1秒钟的http短连接处理完业务，在关闭连接之后，这个业务用过的端口会停留在TIMEWAIT状态几分钟，而这几分钟，其他HTTP请求来临的时候是无法占用此端口的(占着茅坑不拉翔)。</p>
<h5 id="TIME-WAIT-过多有什么危害？"><a href="#TIME-WAIT-过多有什么危害？" class="headerlink" title="TIME_WAIT 过多有什么危害？"></a>TIME_WAIT 过多有什么危害？</h5><p>过多的 TIME-WAIT 状态主要的危害有两种：</p>
<ul>
<li>第⼀是内存资源占⽤； </li>
<li>第⼆是对端⼝资源的占⽤，⼀个 TCP 连接⾄少消耗⼀个本地端⼝；</li>
</ul>
<h5 id="如何优化TIME-WAIT"><a href="#如何优化TIME-WAIT" class="headerlink" title="如何优化TIME_WAIT?"></a>如何优化TIME_WAIT?</h5><ul>
<li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项； <ul>
<li>有⼀点需要注意的是，tcp_tw_reuse 功能只能⽤客户端（连接发起⽅），因为开启了该功能，在调⽤ connect() 函数时，内核会随机找⼀个 time_wait 状态超过 1 秒的连接给新的连接复⽤</li>
<li>net.ipv4.tcp_tw_reuse &#x3D; 1</li>
<li>由于引⼊了时间戳，我们在前⾯提到的 2MSL 问题就不复存在了，因为重复的数据包会因为时间戳过期被⾃然丢 弃。</li>
</ul>
</li>
<li>net.ipv4.tcp_max_tw_buckets <ul>
<li>这个值默认为 18000，当系统中处于 TIME_WAIT 的连接⼀旦超过这个值时，系统就会将后⾯的 TIME_WAIT 连接 状态重置。 这个⽅法过于暴⼒，⽽且治标不治本，带来的问题远⽐解决的问题多，不推荐使⽤。</li>
</ul>
</li>
<li>程序中使⽤ SO_LINGER ，应⽤强制使⽤ RST 关闭。</li>
</ul>
<h5 id="如果已经建⽴了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建⽴了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建⽴了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建⽴了连接，但是客户端突然出现故障了怎么办？</h5><p>TCP 有⼀个机制是保活机制。这个机制的原理是这样的： 定义⼀个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作⽤，每隔⼀个时间间 隔，发送⼀个探测报⽂，该探测报⽂包含的数据⾮常少，如果连续⼏个探测报⽂都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应⽤程序。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_keepalive_time=7200 </span><br><span class="line">net.ipv4.tcp_keepalive_intvl=75  </span><br><span class="line">net.ipv4.tcp_keepalive_probes=9</span><br></pre></td></tr></table></figure>

<ul>
<li>tcp_keepalive_time&#x3D;7200：表示保活时间是 7200 秒（2⼩时），也就 <strong>2 ⼩时内如果没有任何连接相关的活 动，则会启动保活机制</strong> </li>
<li>tcp_keepalive_intvl&#x3D;75：表示<strong>每次检测间隔 75 秒</strong>； </li>
<li>tcp_keepalive_probes&#x3D;9：<strong>表示检测 9 次⽆响应，认为对⽅是不可达的，从⽽中断本次的连接。</strong></li>
</ul>
<p>如果是服务器崩溃，服务器会发送RST报文让客户端断开连接。</p>
<h4 id="TCP被reset中断有哪些原因造成？"><a href="#TCP被reset中断有哪些原因造成？" class="headerlink" title="TCP被reset中断有哪些原因造成？"></a>TCP被reset中断有哪些原因造成？</h4><ul>
<li>客户端尝试与服务器未对外提供服务的端口建立TCP连接，服务器将会直接向客户端发送reset报文。</li>
<li>客户端和服务器的某一方在交互的过程中发生异常（如程序崩溃等），该方系统将向对端发送TCP reset报文，告之对方释放相关的TCP连接，如下图所示：</li>
<li>接收端收到TCP报文，但是发现该TCP的报文，并不在其已建立的TCP连接列表内，则其直接向对端发送reset报文。</li>
<li>在交互的双方中的某一方长期未收到来自对方的确认报文，则其在超出一定的重传次数或时间后，会主动向对端发送reset报文释放该TCP连接</li>
<li>有些应用开发者在设计应用系统时，会利用reset报文快速释放已经完成数据交互的TCP连接，以提高业务交互的效率</li>
</ul>
<h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><p>TCP是面向连接的，提供可靠性服务，以字节流的形式传输，传输速度慢，需要的资源多，首部资源占有多。</p>
<p>UDP是无连接的，不提供可靠性服务，以数据报文段形式传输，传输速度快，需要的资源少，首部占有资源少。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220808093337518.png" alt="image-20220808093337518"></p>
<h4 id="TCP和UDP的应用场景"><a href="#TCP和UDP的应用场景" class="headerlink" title="TCP和UDP的应用场景"></a>TCP和UDP的应用场景</h4><ul>
<li>TCP往往用于对网络质量要求高，传递数据要准确无误的应用上，如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议，像文件传输、邮件系统、金融领域</li>
<li>UDP用于对网络质量要求不高、传输速度要求快的应用上，如一些直播平台，语音交流应用</li>
</ul>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220531173501221.png" alt="image-20220531173501221"></p>
<h2 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h2><h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><h3 id="IPv4数据报格式"><a href="#IPv4数据报格式" class="headerlink" title="IPv4数据报格式"></a>IPv4数据报格式</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220313162307775.png" alt="image-20220313162307775"></p>
<ul>
<li>4比特版本号</li>
<li>4比特首部长度</li>
<li>8比特服务类型</li>
<li>16比特数据报长度</li>
<li>16比特标识、4比特标志、12比特片偏移</li>
<li>8比特寿命</li>
<li>8比特协议</li>
<li>16比特首部检验和</li>
<li>32比特源和32比特目的IP地址</li>
<li>选项</li>
<li>数据（有效载荷）</li>
</ul>
<h3 id="IPv4数据报分片-标识、标志、偏移量"><a href="#IPv4数据报分片-标识、标志、偏移量" class="headerlink" title="IPv4数据报分片(标识、标志、偏移量)"></a>IPv4数据报分片(标识、标志、偏移量)</h3><p>发送主机在为数据报设置源和目标地址的同时贴上标识号，发送主机通常将它发送的每个数据报的标识号加1，当分片时，片具有初始数据报的源地址、目的地址和标识号。</p>
<p>最后一个分片标志比特被设为了0，其他片标志比特被设为1,使用偏移字段指定该片在数据报的哪个位置。</p>
<h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>以通过 ARP 协议，求得下⼀跳的 MAC 地址。</p>
<p>简单地说，ARP 是借助 ARP 请求与 ARP 响应两种类型的包确定 MAC 地址的，</p>
<ul>
<li>主机会通过⼴播发送 ARP 请求，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。 </li>
<li>当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包⾥的内容，如果 ARP 请求包中的⽬标 IP 地 址与⾃⼰的 IP 地址⼀致，那么这个设备就将⾃⼰的 MAC 地址塞⼊ ARP 响应包返回给主机。</li>
</ul>
<p>操作系统通常会把第⼀次通过 ARP 获取的 MAC 地址缓存起来，以便下次直接从缓存中找到对应 IP 地址的 MAC 地址。</p>
<h3 id="RARP-协议"><a href="#RARP-协议" class="headerlink" title="RARP 协议"></a>RARP 协议</h3><p>ARP 协议是已知 IP 地址求 MAC 地址，那 RARP 协议正好相反，它是已知 MAC 地址求 IP 地址。例如将打印机服 务器等⼩型嵌⼊式设备接⼊到⽹络时就经常会⽤得到。</p>
<p>通常这需要架设⼀台 RARP 服务器，在这个服务器上注册设备的 MAC 地址及其 IP 地址。然后再将这个设备接⼊ 到⽹络，接着：</p>
<ul>
<li>该设备会发送⼀条「我的 MAC 地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。 </li>
<li>RARP 服务器接到这个消息后返回「MAC地址为 XXXX 的设备，IP地址为 XXXX」的信息给这个设备。</li>
</ul>
<h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p>ICMP 全称是 Internet Control Message Protocol，也就是互联⽹控制报⽂协议。</p>
<p>ICMP 主要的功能包括：确认 IP 包是否成功送达⽬标地址、报告发送过程中 IP 包被废弃的原因和改善⽹络设置 等。</p>
<p>在 IP 通信中如果某个 IP 包因为某种原因未能达到⽬标地址，那么这个具体的原因将由 ICMP 负责通知。</p>
<p>ICMP ⼤致可以分为两⼤类：</p>
<ol>
<li>⼀类是⽤于诊断的查询消息，也就是「查询报⽂类型」 </li>
<li>另⼀类是通知出错原因的错误消息，也就是「差错报⽂类型」</li>
</ol>
<h3 id="IGMP协议"><a href="#IGMP协议" class="headerlink" title="IGMP协议"></a>IGMP协议</h3><p>D 类地址，既然是组播，那就说明是只有⼀组的主机能收到数据包，不在⼀组 的主机不能收到数组包，怎么管理是否是在⼀组呢？那么，就需要 IGMP 协议了</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220716093807299.png" alt="image-20220716093807299"></p>
<ul>
<li>路由器会周期性发送⽬的地址为 224.0.0.1 （表示同⼀⽹段内所有主机和路由器） IGMP 常规查询报⽂。 </li>
<li>主机1 和 主机 3 收到这个查询，随后会启动「报告延迟计时器」，计时器的时间是随机的，通常是 0~10 秒， 计时器超时后主机就会发送 IGMP 成员关系报告报⽂（源 IP 地址为⾃⼰主机的 IP 地址，⽬的 IP 地址为组播 地址）。如果在定时器超时之前，收到同⼀个组内的其他主机发送的成员关系报告报⽂，则⾃⼰不再发送，这 样可以减少⽹络中多余的 IGMP 报⽂数量。 </li>
<li>路由器收到主机的成员关系报⽂后，就会在 IGMP 路由表中加⼊该组播组，后续⽹络中⼀旦该组播地址的数据 到达路由器，它会把数据包转发出去。</li>
</ul>
<h2 id="输入一个url的过程"><a href="#输入一个url的过程" class="headerlink" title="输入一个url的过程"></a>输入一个url的过程</h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220330100701382.png" alt="image-20220330100701382"></p>
<p>总体来说分为以下几个过程: </p>
<ol>
<li>DNS 解析 </li>
<li>TCP 连接 </li>
<li>SSL 握手 </li>
<li>发送 HTTP 请求 </li>
<li>服务器处理请求并返回 HTTP 报文 </li>
<li>浏览器解析渲染页面 </li>
<li>连接结束</li>
</ol>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断（interrupt）是计算机系统中的基本机制之一。即：在计算机运行过程中，当发生某个事件后，CPU 会停止当前程序流，转而去处理该事件，并在处理完毕后继续执行原程序流。</p>
<h4 id="为什么引入中断"><a href="#为什么引入中断" class="headerlink" title="为什么引入中断"></a>为什么引入中断</h4><p>中断机制的好处是 <strong>化主动为被动，避免 CPU 轮询等待某条件成立</strong>。如果没有中断机制，那么“某个条件成立”就需要 CPU 轮询判断，这样就会增加系统的开销。而使用中断机制，就可以在条件成立之后，向 CPU 发送中断事件，强制中断 CPU 执行程序，转而去执行中断处理程序。</p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>系统调用是一种软中断处理程序，用于让程序从用户态陷入内核态，以执行相应的操作。</p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul>
<li>1、程序从用户态陷入内核态</li>
<li>2、根据系统调用号，在系统调用表中查找对应的系统调用函数的内存地址，执行系统调用函数。</li>
<li>3、程序从内核态返回用户态</li>
</ul>
<h3 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h3><p>用户空间中的代码被限制了只能使用一个局部的内存空间，我们说这些程序在<strong>用户态</strong>（User Mode） 执行。<br>内核空间中的代码可以访问所有内存，我们称这些程序在<strong>内核态</strong>（Kernal Mode） 执行。</p>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><p>并发是指在一段时间内程序交替执行，就好像一直在运行一样，并行就是多个程序同时执行，一起行走</p>
<h3 id="进程pcb包括哪些信息？"><a href="#进程pcb包括哪些信息？" class="headerlink" title="进程pcb包括哪些信息？"></a>进程pcb包括哪些信息？</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220730152312793.png" alt="image-20220730152312793"></p>
<p>进程描述信息： </p>
<ul>
<li>进程标识符：标识各个进程，每个进程都有⼀个并且唯⼀的标识符； </li>
<li>⽤户标识符：进程归属的⽤户，⽤户标识符主要为共享和保护服务；</li>
</ul>
<p>进程控制和管理信息： </p>
<ul>
<li>进程当前状态，如 new、ready、running、waiting 或 blocked 等； </li>
<li>进程优先级：进程抢占 CPU 时的优先级；</li>
</ul>
<p>资源分配清单： </p>
<ul>
<li>有关内存地址空间或虚拟地址空间的信息，所打开⽂件的列表和所使⽤的 I&#x2F;O 设备信息。</li>
</ul>
<p>CPU 相关信息： </p>
<ul>
<li>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执⾏时，能从断点处继续执⾏。</li>
</ul>
<h3 id="进程的七状态模型"><a href="#进程的七状态模型" class="headerlink" title="进程的七状态模型"></a>进程的七状态模型</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220801153852073.png" alt="image-20220801153852073"></p>
<ul>
<li>运⾏状态（Runing）：该时刻进程占⽤ CPU； </li>
<li>就绪状态（Ready）：可运⾏，由于其他进程处于运⾏状态⽽暂时停⽌运⾏； </li>
<li>阻塞状态（Blocked）：该进程正在等待某⼀事件发⽣（如等待输⼊&#x2F;输出操作的完成）⽽ 暂时停⽌运⾏，这时，即使给它CPU控制权，它也⽆法运⾏；</li>
<li>创建状态（new）：进程正在被创建时的状态； </li>
<li>结束状态（Exit）：进程正在从系统中消失时的状态；</li>
<li>阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现； </li>
<li>就绪挂起状态：进程在外存（硬盘），但只要进⼊内存，即刻⽴刻运⾏；</li>
</ul>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p>进程：系统进行资源调度和分配的基本单位，进程间独享内存，一个系统至少一个进程；</p>
<p>线程：cpu进行资源调度和分配的基本单位，线程间共享进程的内存，一个进程至少一个线程，线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>
<h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p>是一种<strong>用户态的轻量级线程</strong>、协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切换回来的时候，回复先前保存的寄存器上下文和栈，<strong>没有内核切换开销所以非常快</strong>。</p>
<h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h3><ul>
<li><p><strong>1. 管道&#x2F;匿名管道(pipe)</strong></p>
<ul>
<li>半双工，用于父子进程的通信，只存在于内存中的，通信的数据是无格式的流并且大小受限，通信的方式是单向的。</li>
</ul>
</li>
<li><p><strong>2. 有名管道(FIFO)</strong></p>
<ul>
<li>有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li>
</ul>
</li>
<li><p><strong>3. 信号(Signal)</strong></p>
<ul>
<li>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态，是唯一具有异步通信机制。</li>
</ul>
</li>
<li><p><strong>4. 消息(Message)队列</strong></p>
<ul>
<li>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示，通信不及时，附件也有大小限制</li>
<li><strong>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销</strong>，，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</li>
</ul>
</li>
<li><p><strong>5. 共享内存(share memory)</strong></p>
<ul>
<li>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</li>
</ul>
</li>
<li><p><strong>6. 信号量(semaphore)</strong></p>
<ul>
<li>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。为了获得共享资源，进程需要执行下列操作：</li>
</ul>
</li>
<li><p><strong>7. 套接字(socket)</strong></p>
</li>
</ul>
<h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><ul>
<li><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>
<li><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li>
<li><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a><strong>什么是死锁？</strong></h4><p>多个进程可以竞争有限数量的资源。当一个进程申请资源时，如果这时没有可用资源，那么这个进程进入等待状态。有时，如果所申请的资源被其他等待进程占有，那么该等待进程有可能再也无法改变状态。这种情况称为 <strong>死锁</strong>。</p>
<h4 id="死锁的四个条件"><a href="#死锁的四个条件" class="headerlink" title="死锁的四个条件"></a>死锁的四个条件</h4><p>👨‍💻<strong>面试官</strong> ：<strong>产生死锁的四个必要条件是什么?</strong></p>
<p>如果系统中以下四个条件同时成立，那么就能引起死锁：</p>
<ul>
<li><strong>互斥</strong>：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</li>
<li><strong>占有并等待</strong>：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</li>
<li><strong>非抢占</strong>：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li>
<li><strong>循环等待</strong>：有一组等待进程 <code>&#123;P0, P1,..., Pn&#125;</code>， <code>P0</code> 等待的资源被 <code>P1</code> 占有，<code>P1</code> 等待的资源被 <code>P2</code> 占有，……，<code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有，<code>Pn</code> 等待的资源被 <code>P0</code> 占有。</li>
</ul>
<p>注意，只有四个条件同时成立时，死锁才会出现。</p>
<h4 id="死锁的解决方案"><a href="#死锁的解决方案" class="headerlink" title="死锁的解决方案"></a>死锁的解决方案</h4><ul>
<li><strong>预防</strong> 是采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间上都不满足。</li>
<li><strong>避免</strong>则是系统在分配资源时，根据资源的使用情况<strong>提前做出预测</strong>，从而<strong>避免死锁的发生</strong></li>
<li><strong>检测</strong>是指系统设有<strong>专门的机构</strong>，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</li>
<li><strong>解除</strong> 是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong>。</li>
</ul>
<h5 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h5><p>死锁四大必要条件上面都已经列出来了，很显然，只要破坏四个必要条件中的任何一个就能够预防死锁的发生。</p>
<p>破坏第一个条件 <strong>互斥条件</strong>：使得资源是可以同时访问的，这是种简单的方法，磁盘就可以用这种方法管理，但是我们要知道，有很多资源 <strong>往往是不能同时访问的</strong> ，所以这种做法在大多数的场合是行不通的。</p>
<p>破坏第三个条件 <strong>非抢占</strong> ：也就是说可以采用 <strong>剥夺式调度算法</strong>，但剥夺式调度方法目前一般仅适用于 <strong>主存资源</strong> 和 <strong>处理器资源</strong> 的分配，并不适用于所以的资源，会导致 <strong>资源利用率下降</strong>。</p>
<p>所以一般比较实用的 <strong>预防死锁的方法</strong>，是通过考虑破坏第二个条件和第四个条件。</p>
<p><strong>1、静态分配策略</strong></p>
<p>静态分配策略可以破坏死锁产生的第二个条件（占有并等待）。所谓静态分配策略，就是指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。进程要么占有所有的资源然后开始执行，要么不占有资源，不会出现占有一些资源等待一些资源的情况。</p>
<p>静态分配策略逻辑简单，实现也很容易，但这种策略 <strong>严重地降低了资源利用率</strong>，因为在每个进程所占有的资源中，有些资源是在比较靠后的执行时间里采用的，甚至有些资源是在额外的情况下才是用的，这样就可能造成了一个进程占有了一些 <strong>几乎不用的资源而使其他需要该资源的进程产生等待</strong> 的情况。</p>
<p><strong>2、层次分配策略</strong></p>
<p>层次分配策略破坏了产生死锁的第四个条件(循环等待)。在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一层的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略。</p>
<h5 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h5><p>上面提到的 <strong>破坏</strong> 死锁产生的四个必要条件之一就可以成功 <strong>预防系统发生死锁</strong> ，但是会导致 <strong>低效的进程运行</strong> 和 <strong>资源使用率</strong> 。而死锁的避免相反，它的角度是允许系统中<strong>同时存在四个必要条件</strong> ，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出 <strong>明智和合理的选择</strong> ，仍然可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。</p>
<p>我们将系统的状态分为 <strong>安全状态</strong> 和 <strong>不安全状态</strong> ，每当在未申请者分配资源前先测试系统状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。</p>
<blockquote>
<p>如果操作系统能够保证所有的进程在有限的时间内得到需要的全部资源，则称系统处于安全状态，否则说系统是不安全的。很显然，系统处于安全状态则不会发生死锁，系统若处于不安全状态则可能发生死锁。</p>
</blockquote>
<p>那么如何保证系统保持在安全状态呢？通过算法，其中最具有代表性的 <strong>避免死锁算法</strong> 就是 Dijkstra 的银行家算法，银行家算法用一句话表达就是：当一个进程申请使用资源的时候，<strong>银行家算法</strong> 通过先 <strong>试探</strong> 分配给该进程资源，然后通过 <strong>安全性算法</strong> 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 <strong>真的分配资源给该进程</strong>。</p>
<p>死锁的避免(银行家算法)改善解决了 <strong>资源使用率低的问题</strong> ，但是它要不断地检测每个进程对各类资源的占用和申请情况，以及做 <strong>安全性检查</strong> ，需要花费较多的时间。</p>
<h5 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h5><p>对资源的分配加以限制可以 <strong>预防和避免</strong> 死锁的发生，但是都不利于各进程对系统资源的<strong>充分共享</strong>。解决死锁问题的另一条途径是 <strong>死锁检测和解除</strong> (这里突然联想到了乐观锁和悲观锁，感觉死锁的检测和解除就像是 <strong>乐观锁</strong> ，分配资源时不去提前管会不会发生死锁了，等到真的死锁出现了再来解决嘛，而 <strong>死锁的预防和避免</strong> 更像是悲观锁，总是觉得死锁会出现，所以在分配资源的时候就很谨慎)。</p>
<p>这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 <strong>定时地运行一个 “死锁检测”</strong> 的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。</p>
<h5 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h5><ol>
<li><strong>立即结束所有进程的执行，重新启动操作系统</strong> ：这种方法简单，但以前所在的工作全部作废，损失很大。</li>
<li><strong>撤销涉及死锁的所有进程，解除死锁后继续运行</strong> ：这种方法能彻底打破<strong>死锁的循环等待</strong>条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。</li>
<li><strong>逐个撤销涉及死锁的进程，回收其资源直至死锁解除。</strong></li>
<li><strong>抢占资源</strong> ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。</li>
</ol>
<h3 id="孤儿线程和僵尸线程"><a href="#孤儿线程和僵尸线程" class="headerlink" title="孤儿线程和僵尸线程"></a>孤儿线程和僵尸线程</h3><p>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被 init 进程（进程号为1）所收养，并由 init 进程对它们完成状态收集工作<strong>。</strong></p>
<p>僵尸进程：一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。这个状态非常有用，因为允许其他线程检查进程返回的代码，并查看刚刚完成的进程是否正常执行。</p>
<h3 id="什么是临界区"><a href="#什么是临界区" class="headerlink" title="什么是临界区"></a>什么是临界区</h3><p><strong>临界区</strong>指的是一个访问共用资源（例如：共用设备或是共用存储器）的程序片段，而这些共用资源又无法同时被多个线程访问的特性</p>
<h3 id="父子进程的内存是拷贝还是共享？是怎么实现的？"><a href="#父子进程的内存是拷贝还是共享？是怎么实现的？" class="headerlink" title="父子进程的内存是拷贝还是共享？是怎么实现的？"></a>父子进程的内存是拷贝还是共享？是怎么实现的？</h3><p>采用共享的方式，使用写时复制技术，只有当有一个线程写的时候才会复制出新的内存，一开始的时候内核将代码段标记为只读，新子进程的进程级<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%A1%B5%E8%A1%A8&spm=1001.2101.3001.7020">页表</a>项都指向和父进程相同的物理页帧，内核会捕获所有父进程或子进程针对这些页面的修改企图(说明此时还没修改)并为将要修改的页面创建拷贝。系统将新的页面拷贝分配给被内核捕获的进程，还会对子进程的相应页表项做适当的调整，现在父子进程就可以分别修改各自的上述段，不再互相影响了。</p>
<h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><ol>
<li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li>
<li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>
</ol>
<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="散列函数发生冲突后的方法"><a href="#散列函数发生冲突后的方法" class="headerlink" title="散列函数发生冲突后的方法"></a>散列函数发生冲突后的方法</h2><ol>
<li>开放寻址法<ul>
<li>线性探测法，每次向下一位寻找</li>
<li>二次探测法，每次以 1^2, - 1^2, 2 ^ 2, -2^2进行探测</li>
<li>伪随机探测法加上一个伪随机数对数组长度进行取余</li>
</ul>
</li>
<li>链地址法</li>
</ol>
<h2 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h2><p>1、B+树是应文件系统所需而出的一种B-树的变型树，通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。</p>
<p>2、B是每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为null。B+是只有叶子节点存储data，叶子节点包含了这棵树的所有键值，叶子节点存储指向关键字记录的指针，结点中仅含有其子树中最大的关键字。</p>
<p>3、B+树有n个子树的结点中有n个关键字</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆的性质"><a href="#堆的性质" class="headerlink" title="堆的性质"></a>堆的性质</h3><ul>
<li>堆中某个节点的值总是不大于或不小于其父节点的值</li>
<li>堆总是一棵完全二叉树</li>
</ul>
<h3 id="堆调整"><a href="#堆调整" class="headerlink" title="堆调整"></a>堆调整</h3><p>小根堆</p>
<p>首先求出子两个子节点最小值的下标<br>然后用子节点最小值与根节点比较：</p>
<ol>
<li>如果根节点比最小值大，那么就不满足小根堆的定义，所以将子节点与根节点交换，并继续向下重复上面的程序，直到子节点的下表超过数组的大小</li>
<li>如果根节点比最小值小，因为左右子树都是小根堆所以，根节点就是数组的最小值，便不用调整，直接结束就行了。</li>
</ol>
<p>小根堆从下往上进行调整，保证每次父节点下面的左子树和右子树都是小根堆，大根堆从上往下调整</p>
<h2 id="八大排序"><a href="#八大排序" class="headerlink" title="八大排序"></a>八大排序</h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220731185057916.png" alt="image-20220731185057916"></p>
<p>冒泡，插入，基数，归并为稳定的算法。</p>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><p><strong>一、基本命令</strong></p>
<ol>
<li><p>重启：reboot -f</p>
</li>
<li><p>关机：poweroff</p>
</li>
<li><p>帮助：命令 –help</p>
</li>
</ol>
<p><strong>二、目录操作命令</strong></p>
<ol>
<li><p>目录切换：cd</p>
</li>
<li><p>目录查看：ls</p>
</li>
<li><p>创建目录：mkdir</p>
</li>
<li><p>删除目录或文件：rm -rf</p>
</li>
<li><p>拷贝目录：cp</p>
</li>
<li><p>查找文件：find</p>
</li>
</ol>
<p><strong>三、文件操作命令</strong></p>
<ol>
<li><p>新建文件：touch</p>
</li>
<li><p>修改文件：vim</p>
</li>
</ol>
<p><strong>四、压缩文件操作</strong></p>
<ol>
<li>打包：tar -cvf 打包压缩后文件名 待打包的文件</li>
</ol>
<p>(注：c：打包；v：显示运行过程；f：指定文件名）</p>
<ol start="2">
<li>解压：tar -xvf 待解压文件</li>
</ol>
<p>（注：x：解压）</p>
<p>tar -xvf 待解压文件 -C 解压位置</p>
<p>（注：-C：指定解压的位置）</p>
<p><strong>五、查找命令</strong></p>
<ol>
<li><p>grep</p>
</li>
<li><p>find</p>
</li>
</ol>
<p><strong>六、权限命令</strong></p>
<p>sudo 让普通用户临时使用root权限，只需输入自己账户的密码</p>
<p><strong>七、其他命令</strong></p>
<ol>
<li><p>查看当前目录路径：pwd</p>
</li>
<li><p>查看进程：ps -ef</p>
</li>
<li><p>结束进程：kill -9 pid</p>
</li>
</ol>
<p>（注：-9 强制；pid：进程号）</p>
<ol start="4">
<li>网络通信命令：</li>
</ol>
<p>ifconfig ：查看网卡信息</p>
<p>ping：查看与某台机器的连接情况</p>
<p>netstat -an：查看当前系统端口</p>
<ol start="5">
<li><p>切换用户：su </p>
</li>
<li><p>修改文件权限：chmod</p>
</li>
</ol>
<h2 id="测试网络连接的命令"><a href="#测试网络连接的命令" class="headerlink" title="测试网络连接的命令"></a>测试网络连接的命令</h2><ol>
<li>ping命令</li>
<li>talnet命令</li>
<li>ssh命令</li>
<li>curl命令</li>
<li>wget命令</li>
<li>tcping命令</li>
</ol>
<p>windows系统下可用的: 1&#x2F;2&#x2F;6<br>linu系统下可用的: 1&#x2F;2&#x2F;3&#x2F;4&#x2F;5&#x2F;6</p>
<h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><h2 id="如何从大量的-URL-中找出相同的-URL？"><a href="#如何从大量的-URL-中找出相同的-URL？" class="headerlink" title="如何从大量的 URL 中找出相同的 URL？"></a>如何从大量的 URL 中找出相同的 URL？</h2><h3 id="1-分治策略"><a href="#1-分治策略" class="headerlink" title="1. 分治策略"></a>1. 分治策略</h3><p>每个 URL 占 64B，那么 50 亿个 URL 占用的空间大小约为 320GB。</p>
<blockquote>
<p>5, 000, 000, 000 _ 64B ≈ 5GB _ 64 &#x3D; 320GB</p>
</blockquote>
<p>由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。对于这种类型的题目，一般采用<strong>分治策略</strong>，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。</p>
<p><strong>思路如下</strong>：</p>
<p>首先遍历文件 a，对遍历到的 URL 求 <code>hash(URL) % 1000</code> ，根据计算结果把遍历到的 URL 存储到 a0, a1, a2, …, a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, …, b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, …, a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。</p>
<p>接着遍历 ai( <code>i∈[0,999]</code> )，把 URL 存储到一个 HashSet 集合中。然后遍历 bi 中每个 URL，看在 HashSet 集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。</p>
<h3 id="2-前缀树"><a href="#2-前缀树" class="headerlink" title="2. 前缀树"></a>2. 前缀树</h3><p>一般而言，URL 的长度差距不会不大，而且前面几个字符，绝大部分相同。这种情况下，非常适合使用<strong>字典树</strong>（trie tree） 这种数据结构来进行存储，降低存储成本的同时，提高查询效率。</p>
<h3 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h3><h4 id="分治策略"><a href="#分治策略" class="headerlink" title="分治策略"></a>分治策略</h4><ol>
<li>分而治之，进行哈希取余；</li>
<li>对每个子文件进行 HashSet 统计。</li>
</ol>
<h4 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h4><ol>
<li>利用字符串的公共前缀来降低存储成本，提高查询效率。</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/13/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%96%B9%E6%B3%95/%E7%AE%97%E6%B3%95%E6%96%B9%E6%B3%95/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis"><span class="nav-number">1.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">Redis数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String"><span class="nav-number">1.1.1.</span> <span class="nav-text">String</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">内部实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List"><span class="nav-number">1.1.2.</span> <span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%95%E5%B1%82"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">底层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">应用场景的缺陷</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash"><span class="nav-number">1.1.3.</span> <span class="nav-text">Hash</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">底层实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set"><span class="nav-number">1.1.4.</span> <span class="nav-text">Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-1"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">内部实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Zset"><span class="nav-number">1.1.5.</span> <span class="nav-text">Zset</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-2"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">内部实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BitMap"><span class="nav-number">1.1.6.</span> <span class="nav-text">BitMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0-3"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">内部实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-5"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hyperloglog"><span class="nav-number">1.1.7.</span> <span class="nav-text">Hyperloglog</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-6"><span class="nav-number">1.1.7.1.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GEO"><span class="nav-number">1.1.8.</span> <span class="nav-text">GEO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-7"><span class="nav-number">1.1.8.1.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%B4%E6%BB%B4%E5%8F%AB%E8%BD%A6"><span class="nav-number">1.1.8.2.</span> <span class="nav-text">滴滴叫车</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stream"><span class="nav-number">1.1.9.</span> <span class="nav-text">Stream</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">Redis数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SDS-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.2.1.</span> <span class="nav-text">SDS(简单动态字符串)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SDS-%E4%B8%8E-C-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">SDS 与 C 字符串的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">1.2.2.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E7%BC%BA%E9%99%B7"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">链表的优势与缺陷</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="nav-number">1.2.3.</span> <span class="nav-text">压缩列表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">压缩列表结构设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%9A%84%E7%BC%BA%E9%99%B7%EF%BC%88%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0%EF%BC%89"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">压缩列表的缺陷（连锁更新）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8"><span class="nav-number">1.2.4.</span> <span class="nav-text">跳表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">跳表结构设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">跳表的查询过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8%E5%B1%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">跳表层数设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8%E6%80%8E%E4%B9%88%E7%BB%B4%E6%8C%81%E7%9B%B8%E9%82%BB%E4%B8%A4%E5%B1%82%E7%9A%84%E8%8A%82%E7%82%B9%E7%9A%84%E6%AF%94%E4%BE%8B%E4%B8%BA2-1%E5%91%A2%EF%BC%9F"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">跳表怎么维持相邻两层的节点的比例为2:1呢？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">1.2.5.</span> <span class="nav-text">哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">哈希表结构设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8rehash%EF%BC%88%E6%89%A9%E5%AE%B9%EF%BC%89"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">哈希表rehash（扩容）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rehash%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">rehash触发条件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84"><span class="nav-number">1.2.6.</span> <span class="nav-text">整数数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">整数集合结构设计</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#quicklist"><span class="nav-number">1.2.7.</span> <span class="nav-text">quicklist</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#quicklist-%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">quicklist 结构设计</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#listpack"><span class="nav-number">1.2.8.</span> <span class="nav-text">listpack</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#listpack-%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.2.8.1.</span> <span class="nav-text">listpack 结构设计</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-number">1.3.</span> <span class="nav-text">Redis数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.4.</span> <span class="nav-text">Redis五大数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.5.</span> <span class="nav-text">Redis的应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%92%8CMemcached%E7%9A%84%E7%9B%B8%E4%BC%BC%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="nav-number">1.6.</span> <span class="nav-text">Redis和Memcached的相似与区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E4%BC%BC"><span class="nav-number">1.6.1.</span> <span class="nav-text">相似</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB"><span class="nav-number">1.6.2.</span> <span class="nav-text">区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.7.</span> <span class="nav-text">Redis线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="nav-number">1.7.1.</span> <span class="nav-text">Redis 是单线程吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%BF%98%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="nav-number">1.7.2.</span> <span class="nav-text">Redis为什么单线程还那么快？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-6-0-%E4%B9%8B%E5%89%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-number">1.7.3.</span> <span class="nav-text">Redis 6.0 之前为什么使用单线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-6-0-%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-number">1.7.4.</span> <span class="nav-text">Redis 6.0 之后为什么引入了多线程？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%AF%BB%E5%86%99%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%AD%A3%E7%A1%AE%EF%BC%9F"><span class="nav-number">1.8.</span> <span class="nav-text">*Redis的多路复用是如何保证读写的顺序正确？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="nav-number">1.9.</span> <span class="nav-text">Redis过期策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E8%BF%87%E6%9C%9F%E7%9A%84%E7%B1%BB%E5%88%AB"><span class="nav-number">1.9.1.</span> <span class="nav-text">Redis过期的类别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E8%BF%87%E6%9C%9F"><span class="nav-number">1.9.2.</span> <span class="nav-text">Redis怎么判断过期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4%E7%9A%84%EF%BC%9F"><span class="nav-number">1.9.3.</span> <span class="nav-text">Redis 是怎么实现惰性删除的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4%E7%9A%84%EF%BC%9F"><span class="nav-number">1.9.4.</span> <span class="nav-text">Redis 是怎么实现定期删除的？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">1.10.</span> <span class="nav-text">Redis内存淘汰机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9-Redis-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="nav-number">1.10.1.</span> <span class="nav-text">如何修改 Redis 内存淘汰策略？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E9%87%8CLRU%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">1.10.2.</span> <span class="nav-text">Redis里LRU实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E9%87%8CLFU%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">1.10.3.</span> <span class="nav-text">Redis里LFU实现方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">1.11.</span> <span class="nav-text">Redis的同步机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E6%98%AF%E6%80%8E%E4%B9%88%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%EF%BC%9F%E6%9C%8D%E5%8A%A1%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E4%BA%A4%E4%BA%92%E7%9A%84%EF%BC%9F"><span class="nav-number">1.12.</span> <span class="nav-text">Redis是怎么持久化的？服务主从数据怎么交互的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5"><span class="nav-number">1.13.</span> <span class="nav-text">Redis持久化策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF"><span class="nav-number">1.13.1.</span> <span class="nav-text">AOF</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%85%88%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%86%8D%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E6%97%A5%E5%BF%97%E5%91%A2%EF%BC%9F"><span class="nav-number">1.13.1.1.</span> <span class="nav-text">为什么先执行命令，再把数据写入日志呢？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF-%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="nav-number">1.13.1.2.</span> <span class="nav-text">AOF 写回策略有几种？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF-%E6%97%A5%E5%BF%97%E8%BF%87%E5%A4%A7%EF%BC%8C%E4%BC%9A%E8%A7%A6%E5%8F%91%E4%BB%80%E4%B9%88%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-number">1.13.1.3.</span> <span class="nav-text">AOF 日志过大，会触发什么机制？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86"><span class="nav-number">1.13.1.4.</span> <span class="nav-text">重写机制原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF%E6%97%A5%E5%BF%97%E9%98%BB%E5%A1%9E"><span class="nav-number">1.13.1.5.</span> <span class="nav-text">AOF日志阻塞</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.13.1.5.1.</span> <span class="nav-text">解决方案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB"><span class="nav-number">1.13.2.</span> <span class="nav-text">RDB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%BF%AB%E7%85%A7%E6%97%B6%EF%BC%8C%E6%95%B0%E6%8D%AE%E8%83%BD%E8%A2%AB%E4%BF%AE%E6%94%B9%E5%90%97%EF%BC%9F"><span class="nav-number">1.13.2.1.</span> <span class="nav-text">执行快照时，数据能被修改吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB%E5%92%8CAOF%E7%BB%93%E5%90%88"><span class="nav-number">1.13.3.</span> <span class="nav-text">RDB和AOF结合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF%E5%92%8CRDB%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.13.4.</span> <span class="nav-text">AOF和RDB混合使用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF%E5%92%8CRDB%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.13.5.</span> <span class="nav-text">AOF和RDB的优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E5%92%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">1.14.</span> <span class="nav-text">Redis缓存穿透和缓存击穿和缓存雪崩</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">1.14.1.</span> <span class="nav-text">缓存穿透</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">1.14.1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8E%E6%9E%9C"><span class="nav-number">1.14.1.2.</span> <span class="nav-text">后果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%A0%E6%88%90%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.14.1.3.</span> <span class="nav-text">造成原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">1.14.1.4.</span> <span class="nav-text">解决方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.14.1.4.1.</span> <span class="nav-text">缓存空对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">1.14.1.4.2.</span> <span class="nav-text">布隆过滤器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%9E%E6%B3%95%E8%AF%B7%E6%B1%82%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-number">1.14.1.4.3.</span> <span class="nav-text">非法请求的限制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BA%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">1.14.1.4.4.</span> <span class="nav-text">缓存空对象和布隆过滤器的对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">1.14.2.</span> <span class="nav-text">缓存击穿</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="nav-number">1.14.2.0.1.</span> <span class="nav-text">解决方案：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">1.14.3.</span> <span class="nav-text">缓存雪崩</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9F"><span class="nav-number">1.14.3.1.</span> <span class="nav-text">有哪些解决办法？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">1.15.</span> <span class="nav-text">主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%8C%E6%AD%A5"><span class="nav-number">1.15.1.</span> <span class="nav-text">第一次同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%BB%BA%E7%AB%8B%E9%93%BE%E6%8E%A5%E3%80%81%E5%8D%8F%E5%95%86%E5%90%8C%E6%AD%A5"><span class="nav-number">1.15.1.1.</span> <span class="nav-text">第一阶段：建立链接、协商同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%EF%BC%9A%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E7%BB%99%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.15.1.2.</span> <span class="nav-text">第二阶段：主服务器同步数据给从服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%EF%BC%9A%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E6%96%B0%E5%86%99%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E7%BB%99%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.15.1.3.</span> <span class="nav-text">第三阶段：主服务器发送新写操作命令给从服务器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%93%E7%BD%91%E7%BB%9C%E6%96%AD%E5%BC%80%E5%8F%88%E6%81%A2%E5%A4%8D%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.15.2.</span> <span class="nav-text">当网络断开又恢复时发生了什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD-redis-%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9%E6%98%AF%E5%90%A6%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="nav-number">1.15.3.</span> <span class="nav-text">怎么判断 redis 某个节点是否正常工作？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%9E%B6%E6%9E%84%E4%B8%AD%EF%BC%8C%E8%BF%87%E6%9C%9Fkey%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-number">1.15.4.</span> <span class="nav-text">主从复制架构中，过期key如何处理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%AD%E4%B8%A4%E4%B8%AA-Buffer-replication-buffer-%E3%80%81repl-backlog-buffer-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.15.5.</span> <span class="nav-text">主从复制中两个 Buffer(replication buffer 、repl backlog buffer)有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%84%91%E8%A3%82%E6%83%85%E5%86%B5"><span class="nav-number">1.15.6.</span> <span class="nav-text">脑裂情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%84%91%E8%A3%82%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.15.7.</span> <span class="nav-text">脑裂的解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9D%91"><span class="nav-number">1.15.7.1.</span> <span class="nav-text">主从复制的坑</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6"><span class="nav-number">1.16.</span> <span class="nav-text">哨兵机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%BB%E8%8A%82%E7%82%B9%E7%9C%9F%E7%9A%84%E6%95%85%E9%9A%9C%E4%BA%86%EF%BC%9F"><span class="nav-number">1.16.1.</span> <span class="nav-text">如何判断主节点真的故障了？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%AE%A2%E8%A7%82%E8%8A%82%E7%82%B9%E4%B8%8B%E7%BA%BF"><span class="nav-number">1.16.2.</span> <span class="nav-text">主客观节点下线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="nav-number">1.16.3.</span> <span class="nav-text">主从故障转移</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4%E4%B8%80%EF%BC%9A%E9%80%89%E5%87%BA%E6%96%B0%E4%B8%BB%E8%8A%82%E7%82%B9"><span class="nav-number">1.16.3.1.</span> <span class="nav-text">步骤一：选出新主节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4%E4%BA%8C%EF%BC%9A%E5%B0%86%E4%BB%8E%E8%8A%82%E7%82%B9%E6%8C%87%E5%90%91%E6%96%B0%E4%B8%BB%E8%8A%82%E7%82%B9"><span class="nav-number">1.16.3.2.</span> <span class="nav-text">步骤二：将从节点指向新主节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4%E4%B8%89%EF%BC%9A%E9%80%9A%E7%9F%A5%E5%AE%A2%E6%88%B7%E7%9A%84%E4%B8%BB%E8%8A%82%E7%82%B9%E5%B7%B2%E6%9B%B4%E6%8D%A2"><span class="nav-number">1.16.3.3.</span> <span class="nav-text">步骤三：通知客户的主节点已更换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4%E5%9B%9B%EF%BC%9A%E5%B0%86%E6%97%A7%E4%B8%BB%E8%8A%82%E7%82%B9%E5%8F%98%E4%B8%BA%E4%BB%8E%E8%8A%82%E7%82%B9"><span class="nav-number">1.16.3.4.</span> <span class="nav-text">步骤四：将旧主节点变为从节点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">1.17.</span> <span class="nav-text">数据库和缓存一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Cache-Aside-Pattern%EF%BC%88%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="nav-number">1.17.1.</span> <span class="nav-text">Cache Aside Pattern（旁路缓存模式）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Read-x2F-Write-Through-Pattern%EF%BC%88%E8%AF%BB%E5%86%99%E7%A9%BF%E9%80%8F%EF%BC%89"><span class="nav-number">1.17.2.</span> <span class="nav-text">Read&#x2F;Write Through Pattern（读写穿透）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Write-Behind-Pattern%EF%BC%88%E5%BC%82%E6%AD%A5%E7%BC%93%E5%AD%98%E5%86%99%E5%85%A5%EF%BC%89"><span class="nav-number">1.17.3.</span> <span class="nav-text">Write Behind Pattern（异步缓存写入）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A1%86%E6%9E%B6"><span class="nav-number">2.</span> <span class="nav-text">框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Mybatis"><span class="nav-number">2.1.</span> <span class="nav-text">Mybatis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mybatis%EF%BC%8C%E4%BB%96%E6%98%AF%E6%80%8E%E4%B9%88%E9%98%B2%E6%AD%A2sql%E6%B3%A8%E5%85%A5%E7%9A%84"><span class="nav-number">2.1.1.</span> <span class="nav-text">mybatis，他是怎么防止sql注入的</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring"><span class="nav-number">2.2.</span> <span class="nav-text">Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IOC%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.1.</span> <span class="nav-text">IOC基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOP%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.2.</span> <span class="nav-text">AOP基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">2.2.3.</span> <span class="nav-text">Spring事务失效的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#autowired-%E5%92%8C-resource%E5%8C%BA%E5%88%AB"><span class="nav-number">2.2.4.</span> <span class="nav-text">@autowired 和@resource区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Autowired%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">2.2.5.</span> <span class="nav-text">@Autowired有多个接口实现怎么办</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC"><span class="nav-number">2.3.</span> <span class="nav-text">SpringMVC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringMVC%E6%B5%81%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86"><span class="nav-number">2.3.1.</span> <span class="nav-text">SpringMVC流程和原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%86Spring%E8%BF%98%E8%A6%81%E6%9C%89SpringBoot%EF%BC%9F"><span class="nav-number">2.4.</span> <span class="nav-text">为什么有了Spring还要有SpringBoot？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">2.5.</span> <span class="nav-text">SpringBoot自动装配的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringBoot%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="nav-number">2.6.</span> <span class="nav-text">SpringBoot注解有哪几种类型？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringBootApplication%E6%B3%A8%E8%A7%A3"><span class="nav-number">2.7.</span> <span class="nav-text">SpringBootApplication注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSpringCloud"><span class="nav-number">2.8.</span> <span class="nav-text">什么是SpringCloud</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="nav-number">2.9.</span> <span class="nav-text">SpringBoot自动装配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="nav-number">2.9.0.1.</span> <span class="nav-text">什么是SpringBoot自动装配</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JUC"><span class="nav-number">3.</span> <span class="nav-text">JUC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3"><span class="nav-number">3.1.</span> <span class="nav-text">线程相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">3.1.1.</span> <span class="nav-text">创建多线程的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">3.1.2.</span> <span class="nav-text">线程的几种状态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized"><span class="nav-number">3.2.</span> <span class="nav-text">synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">3.2.1.</span> <span class="nav-text">轻量级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E8%86%A8%E8%83%80"><span class="nav-number">3.2.2.</span> <span class="nav-text">锁膨胀</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.3.</span> <span class="nav-text">修饰方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized%E5%92%8CReentrantLock"><span class="nav-number">3.2.4.</span> <span class="nav-text">synchronized和ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E5%90%8C%E7%82%B9"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">共同点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB-1"><span class="nav-number">3.2.4.2.</span> <span class="nav-text">区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-number">3.2.5.</span> <span class="nav-text">线程不安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">3.2.6.</span> <span class="nav-text">可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="nav-number">3.2.7.</span> <span class="nav-text">有序性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#run-%E5%92%8Cstart-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.</span> <span class="nav-text">run()和start()的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#notify%E5%92%8Cnotifyall%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.4.</span> <span class="nav-text">notify和notifyall的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait-vs-sleep"><span class="nav-number">3.5.</span> <span class="nav-text">wait vs sleep</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep"><span class="nav-number">3.5.1.</span> <span class="nav-text">sleep</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Runnable-%E5%92%8C-Callable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">3.6.</span> <span class="nav-text">Runnable 和 Callable 有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait-notify"><span class="nav-number">3.7.</span> <span class="nav-text">wait notify</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lock%E5%92%8Csynchronized%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.8.</span> <span class="nav-text">lock和synchronized的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="nav-number">3.9.</span> <span class="nav-text">Java中断机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3"><span class="nav-number">3.10.</span> <span class="nav-text">线程池相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="nav-number">3.10.1.</span> <span class="nav-text">线程池执行原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">3.10.2.</span> <span class="nav-text">线程池的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9F%BA%E6%9C%AC%E5%8F%82%E6%95%B0"><span class="nav-number">3.10.3.</span> <span class="nav-text">线程池基本参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">3.10.4.</span> <span class="nav-text">常见的线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#newFixedThreadPool"><span class="nav-number">3.10.4.1.</span> <span class="nav-text">newFixedThreadPool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newCachedThreadPool"><span class="nav-number">3.10.4.2.</span> <span class="nav-text">newCachedThreadPool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newSingleThreadExecutor"><span class="nav-number">3.10.4.3.</span> <span class="nav-text">newSingleThreadExecutor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newScheduledThreadPool"><span class="nav-number">3.10.4.4.</span> <span class="nav-text">newScheduledThreadPool</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E7%9A%84%E4%B8%83%E5%A4%A7%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-number">3.10.5.</span> <span class="nav-text">Java的七大阻塞队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%87%8C%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.10.6.</span> <span class="nav-text">线程池里的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#execute-vs-submit"><span class="nav-number">3.10.6.1.</span> <span class="nav-text">execute() vs submit()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shutdown-vs-shutdownNow"><span class="nav-number">3.10.6.2.</span> <span class="nav-text">shutdown() vs shutdownNow()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#isTerminated-vs-isShutdown"><span class="nav-number">3.10.6.3.</span> <span class="nav-text">isTerminated() vs isShutdown()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%A7%E5%B0%8F%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE"><span class="nav-number">3.10.7.</span> <span class="nav-text">线程池大小如何设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9A%E5%88%9B%E5%BB%BA%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%80%E5%AE%9A%E4%BC%9A%E7%AB%8B%E5%8D%B3%E5%88%9B%E5%BB%BA%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="nav-number">3.10.8.</span> <span class="nav-text">线程池刚创建的时候一定会立即创建核心线程吗？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">3.11.</span> <span class="nav-text">ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8"><span class="nav-number">3.11.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">3.11.2.</span> <span class="nav-text">实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88key%E4%BD%BF%E7%94%A8%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="nav-number">3.11.3.</span> <span class="nav-text">为什么key使用弱引用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%BC%E7%9A%84%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%E6%97%B6%E6%9C%BA"><span class="nav-number">3.11.4.</span> <span class="nav-text">值的内存释放时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E6%83%B3%E8%A6%81%E5%85%B1%E4%BA%ABthreadlocal%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.11.5.</span> <span class="nav-text">如果线程之间想要共享threadlocal，怎么实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.12.</span> <span class="nav-text">乐观锁和悲观锁的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="nav-number">3.13.</span> <span class="nav-text">什么是线程安全和线程不安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">3.13.1.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8-1"><span class="nav-number">3.13.2.</span> <span class="nav-text">线程不安全</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JUC-1"><span class="nav-number">3.14.</span> <span class="nav-text">JUC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS%E5%8E%9F%E7%90%86"><span class="nav-number">3.14.1.</span> <span class="nav-text">CAS原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS%E5%8E%9F%E7%90%86"><span class="nav-number">3.14.2.</span> <span class="nav-text">AQS原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock%E5%8E%9F%E7%90%86"><span class="nav-number">3.14.3.</span> <span class="nav-text">ReentrantLock原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E9%94%81%E5%8E%9F%E7%90%86"><span class="nav-number">3.14.3.1.</span> <span class="nav-text">加锁原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E9%94%81%E5%8E%9F%E7%90%86"><span class="nav-number">3.14.3.2.</span> <span class="nav-text">解锁原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E9%94%81%E7%AB%9E%E4%BA%89%E6%88%90%E5%8A%9F%E6%B5%81%E7%A8%8B"><span class="nav-number">3.14.3.2.1.</span> <span class="nav-text">解锁竞争成功流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E9%94%81%E7%AB%9E%E4%BA%89%E5%A4%B1%E8%B4%A5%E6%B5%81%E7%A8%8B"><span class="nav-number">3.14.3.2.2.</span> <span class="nav-text">解锁竞争失败流程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E5%8E%9F%E7%90%86"><span class="nav-number">3.14.3.3.</span> <span class="nav-text">可重入原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E6%89%93%E6%96%AD%E5%8E%9F%E7%90%86"><span class="nav-number">3.14.3.4.</span> <span class="nav-text">可打断原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E6%89%93%E6%96%AD%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.14.3.4.1.</span> <span class="nav-text">不可打断模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E6%89%93%E6%96%AD%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.14.3.4.2.</span> <span class="nav-text">可打断模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">3.14.3.5.</span> <span class="nav-text">公平锁实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">3.14.3.6.</span> <span class="nav-text">条件变量实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#await%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">3.14.3.6.1.</span> <span class="nav-text">await实现原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#signal%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="nav-number">3.14.3.6.2.</span> <span class="nav-text">signal实现流程</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM"><span class="nav-number">4.</span> <span class="nav-text">JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="nav-number">4.1.</span> <span class="nav-text">内存区域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E6%B0%B8%E4%B9%85%E4%BB%A3%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">4.1.1.</span> <span class="nav-text">方法区和永久代的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="nav-number">4.1.2.</span> <span class="nav-text">对象的创建过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">4.1.3.</span> <span class="nav-text">内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">指针碰撞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">空闲列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TLAB"><span class="nav-number">4.1.3.3.</span> <span class="nav-text">TLAB</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">4.1.4.</span> <span class="nav-text">对象访问定位的两种方式？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">4.1.4.1.</span> <span class="nav-text">优缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">4.2.</span> <span class="nav-text">垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%88%A4%E6%96%AD%E7%AE%97%E6%B3%95"><span class="nav-number">4.2.1.</span> <span class="nav-text">垃圾判断算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA"><span class="nav-number">4.2.2.</span> <span class="nav-text">分代收集理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC-Roots"><span class="nav-number">4.2.3.</span> <span class="nav-text">GC Roots</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAGC-Roots"><span class="nav-number">4.2.3.1.</span> <span class="nav-text">哪些可以作为GC Roots</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-number">4.2.3.2.</span> <span class="nav-text">Java中的引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B9%E8%8A%82%E7%82%B9%E6%9E%9A%E4%B8%BE"><span class="nav-number">4.2.3.3.</span> <span class="nav-text">根节点枚举</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9"><span class="nav-number">4.2.3.4.</span> <span class="nav-text">安全点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="nav-number">4.2.3.4.1.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%89%8D%E8%B7%91%E5%88%B0%E5%AE%89%E5%85%A8%E7%82%B9%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">4.2.3.4.1.1.</span> <span class="nav-text">垃圾回收前跑到安全点的方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="nav-number">4.2.3.5.</span> <span class="nav-text">安全区域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B0%E5%BF%86%E9%9B%86%E5%92%8C%E5%8D%A1%E8%A1%A8"><span class="nav-number">4.2.3.6.</span> <span class="nav-text">记忆集和卡表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="nav-number">4.2.3.7.</span> <span class="nav-text">写屏障</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%AA%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98"><span class="nav-number">4.2.3.7.1.</span> <span class="nav-text">伪共享问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E8%BE%BE%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%80%E5%AE%9A%E4%BC%9A%E8%A2%AB%E5%9B%9E%E6%94%B6%E5%90%97"><span class="nav-number">4.2.3.8.</span> <span class="nav-text">不可达的对象一定会被回收吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0"><span class="nav-number">4.2.3.9.</span> <span class="nav-text">三色标记</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E5%BC%95%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.2.3.10.</span> <span class="nav-text">并发标记引来的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="nav-number">4.2.3.11.</span> <span class="nav-text">解决方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">4.2.4.</span> <span class="nav-text">垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E6%B3%95"><span class="nav-number">4.2.4.1.</span> <span class="nav-text">标记清除法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E6%B3%95"><span class="nav-number">4.2.4.2.</span> <span class="nav-text">标记整理法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6%E6%B3%95"><span class="nav-number">4.2.4.3.</span> <span class="nav-text">标记复制法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%9F"><span class="nav-number">4.2.5.</span> <span class="nav-text">如何回收方法区？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A2%AB%E6%A0%87%E8%AE%B0%E4%B8%BA%E5%9E%83%E5%9C%BE%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%80%E5%AE%9A%E4%BC%9A%E8%A2%AB%E5%9B%9E%E6%94%B6%E5%90%97%EF%BC%9F"><span class="nav-number">4.2.6.</span> <span class="nav-text">被标记为垃圾的对象一定会被回收吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E4%B8%8B%E4%BD%A0%E7%94%A8%E8%BF%87%E7%9A%84-JVM-%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7%EF%BC%9F"><span class="nav-number">4.2.7.</span> <span class="nav-text">说下你用过的 JVM 监控工具？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E4%BC%9A%E5%AF%B9%E6%B0%B8%E4%B9%85%E4%BB%A3%E8%BF%9B%E8%A1%8C%E5%9B%9E%E6%94%B6%E5%90%97%EF%BC%9F"><span class="nav-number">4.2.8.</span> <span class="nav-text">JVM会对永久代进行回收吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">4.2.9.</span> <span class="nav-text">常见的垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Serial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.2.9.1.</span> <span class="nav-text">Serial收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.2.9.2.</span> <span class="nav-text">ParNew收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.2.9.3.</span> <span class="nav-text">Parallel Scavenge收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.2.9.4.</span> <span class="nav-text">Serial Old收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.2.9.5.</span> <span class="nav-text">Parallel Old收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.2.9.6.</span> <span class="nav-text">CMS收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Garbage-First%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.2.9.7.</span> <span class="nav-text">Garbage First收集器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK%E9%BB%98%E8%AE%A4%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">4.2.10.</span> <span class="nav-text">JDK默认的垃圾回收器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-number">4.2.11.</span> <span class="nav-text">内存泄漏和内存溢出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">4.2.11.1.</span> <span class="nav-text">什么是内存溢出和内存泄漏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%92%8C%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E5%85%B3%E7%B3%BB%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.11.2.</span> <span class="nav-text">内存溢出和内存泄露的关系以及区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">4.2.11.3.</span> <span class="nav-text">内存泄漏的情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">4.2.11.4.</span> <span class="nav-text">内存溢出的情况</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8C%BA%E5%9F%9F"><span class="nav-number">4.2.12.</span> <span class="nav-text">内存分配区域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%A7%A6%E5%8F%91Young-GC%EF%BC%9F"><span class="nav-number">4.2.12.1.</span> <span class="nav-text">什么时候会触发Young GC？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%A7%A6%E5%8F%91Full-GC"><span class="nav-number">4.2.12.2.</span> <span class="nav-text">什么时候会触发Full GC?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89suivivor%E5%8C%BA%EF%BC%9F"><span class="nav-number">4.2.12.3.</span> <span class="nav-text">为什么要有suivivor区？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E7%BD%AE%E4%B8%A4%E4%B8%AASurvivor%E5%8C%BA"><span class="nav-number">4.2.12.4.</span> <span class="nav-text">为什么要设置两个Survivor区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#survivor%E6%BB%A1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">4.2.12.5.</span> <span class="nav-text">survivor满了怎么办</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%AF%B9%E8%B1%A1%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">4.2.12.6.</span> <span class="nav-text">什么时候对象进入老年代</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9B%B8%E5%85%B3"><span class="nav-number">4.3.</span> <span class="nav-text">类加载相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">4.3.1.</span> <span class="nav-text">类的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">4.3.2.</span> <span class="nav-text">类加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5"><span class="nav-number">4.3.2.2.</span> <span class="nav-text">连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.3.2.3.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F"><span class="nav-number">4.3.3.</span> <span class="nav-text">有几种类加载器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.3.4.</span> <span class="nav-text">双亲委派模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.3.5.</span> <span class="nav-text">双亲委派的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">4.3.6.</span> <span class="nav-text">打破双亲委派机制的例子</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%93%E7%A0%B4"><span class="nav-number">4.3.6.1.</span> <span class="nav-text">一、第一次打破</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%89%93%E7%A0%B4"><span class="nav-number">4.3.6.2.</span> <span class="nav-text">二、第二次打破</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%89%93%E7%A0%B4"><span class="nav-number">4.3.6.3.</span> <span class="nav-text">三、第三次打破</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">4.3.7.</span> <span class="nav-text">如何自定义类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%BD%E4%B8%8D%E8%83%BD%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AAjava-lang-String"><span class="nav-number">4.3.8.</span> <span class="nav-text">能不能自己写一个java.lang.String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final"><span class="nav-number">4.3.9.</span> <span class="nav-text">final</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL"><span class="nav-number">5.</span> <span class="nav-text">MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">5.1.</span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="nav-number">5.1.1.</span> <span class="nav-text">索引分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">5.1.2.</span> <span class="nav-text">索引的好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95%E5%92%8C%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.3.</span> <span class="nav-text">B+树索引和哈希索引的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql%E6%98%AF%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E5%93%AA%E4%B8%AA%E7%B4%A2%E5%BC%95%E7%9A%84"><span class="nav-number">5.1.4.</span> <span class="nav-text">mysql是如何确定哪个索引的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E7%9A%84%EF%BC%9F"><span class="nav-number">5.1.5.</span> <span class="nav-text">联合索引是怎么存储的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-%E6%A0%91%E9%AB%98%E5%BA%A6%E8%AE%A1%E7%AE%97"><span class="nav-number">5.1.6.</span> <span class="nav-text">B+树高度计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8%E4%BA%86%E7%B4%A2%E5%BC%95"><span class="nav-number">5.1.7.</span> <span class="nav-text">是否使用了索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyISAM%E5%92%8CInnoDB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.2.</span> <span class="nav-text">MyISAM和InnoDB的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">5.3.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="nav-number">5.3.1.</span> <span class="nav-text">事务的特性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">5.3.2.</span> <span class="nav-text">事务的隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E4%BA%8B%E5%8A%A1%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">5.3.3.</span> <span class="nav-text">大事务引发的问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL-int%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="nav-number">5.4.</span> <span class="nav-text">MySQL int类型有几种？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#char%E5%92%8Cvarchar%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.5.</span> <span class="nav-text">char和varchar的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="nav-number">5.6.</span> <span class="nav-text">MySQL分库分表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95-1"><span class="nav-number">5.7.</span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">5.7.1.</span> <span class="nav-text">索引失效的情况</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="nav-number">5.8.</span> <span class="nav-text">执行计划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E5%BA%94%E5%8F%82%E6%95%B0"><span class="nav-number">5.8.1.</span> <span class="nav-text">对应参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">5.9.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="nav-number">5.9.1.</span> <span class="nav-text">全局锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="nav-number">5.9.2.</span> <span class="nav-text">表级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E9%94%81"><span class="nav-number">5.9.2.1.</span> <span class="nav-text">表锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81"><span class="nav-number">5.9.2.2.</span> <span class="nav-text">元数据锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="nav-number">5.9.2.3.</span> <span class="nav-text">意向锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AUTO-INC%E9%94%81%EF%BC%88%E8%87%AA%E5%A2%9E%E9%94%81%EF%BC%89"><span class="nav-number">5.9.2.4.</span> <span class="nav-text">AUTO-INC锁（自增锁）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="nav-number">5.9.3.</span> <span class="nav-text">行级锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.9.3.1.</span> <span class="nav-text">锁类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E9%94%81"><span class="nav-number">5.9.3.1.1.</span> <span class="nav-text">记录锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%B4%E9%9A%99%E9%94%81"><span class="nav-number">5.9.3.1.2.</span> <span class="nav-text">间隙锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%B4%E9%94%AE%E9%94%81"><span class="nav-number">5.9.3.1.3.</span> <span class="nav-text">临键锁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.9.3.2.</span> <span class="nav-text">唯一索引等值查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.9.3.3.</span> <span class="nav-text">唯一索引范围查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%EF%BC%9A"><span class="nav-number">5.9.3.4.</span> <span class="nav-text">非唯一索引等值查询：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%92%8C%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E7%9A%84%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%8A%A0%E9%94%81%E8%A7%84%E5%88%99%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84%E5%9C%A8%E4%BA%8E%EF%BC%9A"><span class="nav-number">5.9.3.5.</span> <span class="nav-text">非唯一索引和主键索引的范围查询的加锁规则不同之处在于：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="nav-number">6.</span> <span class="nav-text">Java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98"><span class="nav-number">6.1.</span> <span class="nav-text">基础问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="nav-number">6.1.1.</span> <span class="nav-text">Java语言的特点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Java%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%85%B1%E5%AD%98%EF%BC%9F"><span class="nav-number">6.1.2.</span> <span class="nav-text">为什么说Java编译与解释共存？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">6.1.3.</span> <span class="nav-text">深拷贝和浅拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB-2"><span class="nav-number">6.1.3.1.</span> <span class="nav-text">区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">6.1.3.2.</span> <span class="nav-text">具体应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.1.4.</span> <span class="nav-text">Java和C++的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="nav-number">6.1.5.</span> <span class="nav-text">什么是序列化？什么是反序列化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM-vs-JDK-vs-JRE"><span class="nav-number">6.1.6.</span> <span class="nav-text">JVM vs JDK vs JRE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%85%AB%E5%A4%A7%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.1.7.</span> <span class="nav-text">Java八大基础类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.1.8.</span> <span class="nav-text">成员变量与局部变量的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83-HashSet%E3%80%81LinkedHashSet-%E5%92%8C-TreeSet-%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">6.1.9.</span> <span class="nav-text">比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO"><span class="nav-number">6.2.</span> <span class="nav-text">IO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO%E3%80%81NIO%E3%80%81BIO"><span class="nav-number">6.2.1.</span> <span class="nav-text">BIO、NIO、BIO?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">6.2.2.</span> <span class="nav-text">字节流和字符流的区别？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object%E7%B1%BB%E4%B8%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">6.3.</span> <span class="nav-text">Object类下的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.4.</span> <span class="nav-text">接口和抽象类的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">6.5.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.6.</span> <span class="nav-text">重载和重写的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB"><span class="nav-number">6.7.</span> <span class="nav-text">不可变类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="nav-number">6.7.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">6.7.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">6.7.3.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#int%E5%92%8CInteger%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.8.</span> <span class="nav-text">int和Integer的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%ADint%E5%92%8CInteger%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%EF%BC%9F"><span class="nav-number">6.8.1.</span> <span class="nav-text">怎么判断int和Integer是否相等？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%9E%8B%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80"><span class="nav-number">6.9.</span> <span class="nav-text">编译型和解释型语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.10.</span> <span class="nav-text">面向对象和面向过程的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">6.11.</span> <span class="nav-text">Java三大特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">6.12.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">6.12.1.</span> <span class="nav-text">实现多态的必要条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">6.12.2.</span> <span class="nav-text">多态底层原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String%E7%B1%BB"><span class="nav-number">6.13.</span> <span class="nav-text">String类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String%EF%BC%8CStringBuilder%E5%92%8CStringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.13.1.</span> <span class="nav-text">String，StringBuilder和StringBuffer的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">6.13.2.</span> <span class="nav-text">String常用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BE%E7%BD%AE%E4%B8%BAfinal%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.13.3.</span> <span class="nav-text">String为什么设置为final类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E5%BA%95%E5%B1%82%E7%94%A8%E4%BB%80%E4%B9%88%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="nav-number">6.13.4.</span> <span class="nav-text">String底层用什么存储数据？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashCode"><span class="nav-number">6.13.5.</span> <span class="nav-text">hashCode()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97hashCode-%E7%9A%84%EF%BC%9F"><span class="nav-number">6.13.5.1.</span> <span class="nav-text">String怎么计算hashCode()的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashCode-%E5%AD%98%E5%82%A8%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="nav-number">6.13.5.2.</span> <span class="nav-text">hashCode()存储在哪里？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.13.6.</span> <span class="nav-text">String、StringBuffer、StringBuilder的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#x3D-x3D-%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.14.</span> <span class="nav-text">&#x3D;&#x3D; 和 equals()的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals%E8%BF%98%E8%A6%81%E9%87%8D%E5%86%99hashCode"><span class="nav-number">6.15.</span> <span class="nav-text">为什么重写equals还要重写hashCode()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">6.16.</span> <span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Exception%E5%92%8CErroer%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">6.16.1.</span> <span class="nav-text">Exception和Erroer有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%8F%97%E6%A3%80%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="nav-number">6.16.2.</span> <span class="nav-text">常见受检时异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%9D%9E%E5%8F%97%E6%A3%80%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="nav-number">6.16.3.</span> <span class="nav-text">常见非受检时异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">6.17.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="nav-number">6.17.1.</span> <span class="nav-text">Java 的泛型是如何工作的 ? 什么是类型擦除 ?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%E4%B8%AD%E7%9A%84%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6%E5%92%8C%E9%9D%9E%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">6.17.2.</span> <span class="nav-text">什么是泛型中的限定通配符和非限定通配符 ?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">6.18.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E5%8E%9F%E7%90%86"><span class="nav-number">6.18.1.</span> <span class="nav-text">反射原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="nav-number">6.18.2.</span> <span class="nav-text">什么是反射？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">6.18.3.</span> <span class="nav-text">反射的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">6.18.4.</span> <span class="nav-text">反射的缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">6.18.5.</span> <span class="nav-text">反射的应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">6.19.</span> <span class="nav-text">final关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97%E7%94%A8%E4%BA%8E%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%9A"><span class="nav-number">6.19.1.</span> <span class="nav-text">final关键字用于修饰成员变量：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection"><span class="nav-number">6.20.</span> <span class="nav-text">Collection</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E8%AF%A6%E6%83%85"><span class="nav-number">6.20.1.</span> <span class="nav-text">集合类详情</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList%E5%92%8CLinkedList%E5%8C%BA%E5%88%AB"><span class="nav-number">6.20.2.</span> <span class="nav-text">ArrayList和LinkedList区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fail-fast%E6%9C%BA%E5%88%B6"><span class="nav-number">6.20.3.</span> <span class="nav-text">fail-fast机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E7%B1%BB%E5%88%AB"><span class="nav-number">6.20.4.</span> <span class="nav-text">异常的类别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap"><span class="nav-number">6.20.5.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C1-7%E5%92%8C1-8%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="nav-number">6.20.5.1.</span> <span class="nav-text">底层数据结构，1.7和1.8有何不同？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E5%8C%96%E4%B8%8E%E9%80%80%E5%8C%96"><span class="nav-number">6.20.5.2.</span> <span class="nav-text">树化与退化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%A1%E7%AE%97"><span class="nav-number">6.20.5.3.</span> <span class="nav-text">索引计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#put-%E4%B8%8E%E6%89%A9%E5%AE%B9"><span class="nav-number">6.20.5.4.</span> <span class="nav-text">put 与扩容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%90%97%EF%BC%9F"><span class="nav-number">6.20.5.5.</span> <span class="nav-text">HashMap线程安全吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A9%E5%AE%B9%E6%AD%BB%E9%93%BE%EF%BC%881-7-%E4%BC%9A%E5%AD%98%E5%9C%A8%EF%BC%89"><span class="nav-number">6.20.5.5.1.</span> <span class="nav-text">扩容死链（1.7 会存在）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%94%99%E4%B9%B1%EF%BC%881-7%EF%BC%8C1-8-%E9%83%BD%E4%BC%9A%E5%AD%98%E5%9C%A8%EF%BC%89"><span class="nav-number">6.20.5.5.2.</span> <span class="nav-text">数据错乱（1.7，1.8 都会存在）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Map%E6%A1%B6%E4%B8%AD%E4%B8%AA%E6%95%B0%E8%B6%85%E8%BF%878%E6%89%8D%E8%BD%AC%E4%B8%BA%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="nav-number">6.20.5.6.</span> <span class="nav-text">为什么Map桶中个数超过8才转为红黑树？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hashtable-vs-ConcurrentHashMap"><span class="nav-number">6.20.6.</span> <span class="nav-text">Hashtable vs ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap-1-7"><span class="nav-number">6.20.6.1.</span> <span class="nav-text">ConcurrentHashMap 1.7</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap-1-8"><span class="nav-number">6.20.6.2.</span> <span class="nav-text">ConcurrentHashMap 1.8</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">6.21.</span> <span class="nav-text">动态代理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MQ"><span class="nav-number">7.</span> <span class="nav-text">MQ</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">8.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#OSI%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%92%8CTCP-x2F-IP%E5%9B%9B%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number">8.1.</span> <span class="nav-text">OSI七层协议和TCP&#x2F;IP四层协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">8.2.</span> <span class="nav-text">应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP"><span class="nav-number">8.2.1.</span> <span class="nav-text">HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">8.2.1.1.</span> <span class="nav-text">http请求报文和响应报文包含什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS"><span class="nav-number">8.2.1.2.</span> <span class="nav-text">HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.2.1.2.1.</span> <span class="nav-text">HTTP和HTTPS的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTPS%E7%9A%84%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="nav-number">8.2.1.2.2.</span> <span class="nav-text">HTTPS的通信流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">8.2.1.2.3.</span> <span class="nav-text">数字证书的工作流程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cookie%E5%92%8CSession"><span class="nav-number">8.2.1.3.</span> <span class="nav-text">Cookie和Session</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%BA%E5%88%AB-3"><span class="nav-number">8.2.1.3.1.</span> <span class="nav-text">区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%A8%E6%B3%95"><span class="nav-number">8.2.1.3.2.</span> <span class="nav-text">用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A6%81%E6%AD%A2%E4%BA%86Cokkie%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">8.2.1.3.3.</span> <span class="nav-text">禁止了Cokkie怎么办</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%88%86%E5%B8%83%E5%BC%8FSession%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">8.2.1.3.4.</span> <span class="nav-text">如何解决分布式Session问题？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">8.2.1.3.5.</span> <span class="nav-text">如何解决跨域问题？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GET%E3%80%81POST%E3%80%81PUT%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.2.1.4.</span> <span class="nav-text">GET、POST、PUT的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%93%8D%E5%BA%94%E7%A0%81"><span class="nav-number">8.2.1.5.</span> <span class="nav-text">常见的响应码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1XX-%E4%BF%A1%E6%81%AF"><span class="nav-number">8.2.1.5.1.</span> <span class="nav-text">1XX 信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2XX-%E6%88%90%E5%8A%9F"><span class="nav-number">8.2.1.5.2.</span> <span class="nav-text">2XX 成功</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3XX-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">8.2.1.5.3.</span> <span class="nav-text">3XX 重定向</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4XX-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF"><span class="nav-number">8.2.1.5.4.</span> <span class="nav-text">4XX 客户端错误</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5XX-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF"><span class="nav-number">8.2.1.5.5.</span> <span class="nav-text">5XX 服务器错误</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Content-length%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">8.2.1.6.</span> <span class="nav-text">Content-length引发的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Content-Length-gt-%E5%AE%9E%E9%99%85%E9%95%BF%E5%BA%A6"><span class="nav-number">8.2.1.7.</span> <span class="nav-text">Content-Length&gt;实际长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Content-Length-lt-%E5%AE%9E%E9%99%85%E9%95%BF%E5%BA%A6"><span class="nav-number">8.2.1.8.</span> <span class="nav-text">Content-Length &lt; 实际长度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SMTP%E5%8D%8F%E8%AE%AE"><span class="nav-number">8.2.2.</span> <span class="nav-text">SMTP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9A%84%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-number">8.2.2.1.</span> <span class="nav-text">电子邮件的发送过程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E9%82%AE%E7%AE%B1%E6%98%AF%E7%9C%9F%E6%AD%A3%E5%AD%98%E5%9C%A8%E7%9A%84%EF%BC%9F"><span class="nav-number">8.2.2.2.</span> <span class="nav-text">如何判断邮箱是真正存在的？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#POP3%E5%8D%8F%E8%AE%AE"><span class="nav-number">8.2.2.3.</span> <span class="nav-text">POP3协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IMAP%E5%8D%8F%E8%AE%AE"><span class="nav-number">8.2.2.4.</span> <span class="nav-text">IMAP协议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS"><span class="nav-number">8.2.3.</span> <span class="nav-text">DNS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS-%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="nav-number">8.2.3.1.</span> <span class="nav-text">DNS 的查询过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS%E7%BC%93%E5%AD%98"><span class="nav-number">8.2.3.2.</span> <span class="nav-text">DNS缓存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82"><span class="nav-number">8.3.</span> <span class="nav-text">运输层</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP"><span class="nav-number">8.3.1.</span> <span class="nav-text">TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">8.3.1.1.</span> <span class="nav-text">三次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">8.3.1.1.1.</span> <span class="nav-text">三次握手的概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BD%9C%E7%94%A8"><span class="nav-number">8.3.1.1.2.</span> <span class="nav-text">三次握手作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#seq%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">8.3.1.1.3.</span> <span class="nav-text">seq的作用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">8.3.1.2.</span> <span class="nav-text">四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%AB%E4%B9%89"><span class="nav-number">8.3.1.2.1.</span> <span class="nav-text">含义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="nav-number">8.3.1.2.2.</span> <span class="nav-text">为什么不能是三次挥手？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%80%E5%90%8E%E8%BF%98%E8%A6%81%E7%AD%89%E5%BE%85TIME-WAIT"><span class="nav-number">8.3.1.2.3.</span> <span class="nav-text">为什么最后还要等待TIME_WAIT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AD%98%E5%9C%A8%E5%A4%A7%E9%87%8F-TIME-WAIT%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">8.3.1.2.4.</span> <span class="nav-text">服务器存在大量 TIME-WAIT的原因</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TIME-WAIT-%E8%BF%87%E5%A4%9A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3%EF%BC%9F"><span class="nav-number">8.3.1.2.5.</span> <span class="nav-text">TIME_WAIT 过多有什么危害？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96TIME-WAIT"><span class="nav-number">8.3.1.2.6.</span> <span class="nav-text">如何优化TIME_WAIT?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E2%BD%B4%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AA%81%E7%84%B6%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">8.3.1.2.7.</span> <span class="nav-text">如果已经建⽴了连接，但是客户端突然出现故障了怎么办？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E8%A2%ABreset%E4%B8%AD%E6%96%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%9B%A0%E9%80%A0%E6%88%90%EF%BC%9F"><span class="nav-number">8.3.1.3.</span> <span class="nav-text">TCP被reset中断有哪些原因造成？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.3.1.4.</span> <span class="nav-text">TCP和UDP的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">8.3.1.5.</span> <span class="nav-text">TCP和UDP的应用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number">8.4.</span> <span class="nav-text">网络层协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IP"><span class="nav-number">8.4.1.</span> <span class="nav-text">IP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="nav-number">8.4.2.</span> <span class="nav-text">IPv4数据报格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87-%E6%A0%87%E8%AF%86%E3%80%81%E6%A0%87%E5%BF%97%E3%80%81%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="nav-number">8.4.3.</span> <span class="nav-text">IPv4数据报分片(标识、标志、偏移量)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARP%E5%8D%8F%E8%AE%AE"><span class="nav-number">8.4.4.</span> <span class="nav-text">ARP协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RARP-%E5%8D%8F%E8%AE%AE"><span class="nav-number">8.4.5.</span> <span class="nav-text">RARP 协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ICMP%E5%8D%8F%E8%AE%AE"><span class="nav-number">8.4.6.</span> <span class="nav-text">ICMP协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IGMP%E5%8D%8F%E8%AE%AE"><span class="nav-number">8.4.7.</span> <span class="nav-text">IGMP协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AAurl%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">8.5.</span> <span class="nav-text">输入一个url的过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">9.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="nav-number">9.1.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD"><span class="nav-number">9.1.1.</span> <span class="nav-text">中断</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5%E4%B8%AD%E6%96%AD"><span class="nav-number">9.1.1.1.</span> <span class="nav-text">为什么引入中断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">9.1.2.</span> <span class="nav-text">系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B"><span class="nav-number">9.1.2.1.</span> <span class="nav-text">流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81"><span class="nav-number">9.1.3.</span> <span class="nav-text">用户态和内核态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">9.2.</span> <span class="nav-text">进程和线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="nav-number">9.2.1.</span> <span class="nav-text">并发和并行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8Bpcb%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E4%BF%A1%E6%81%AF%EF%BC%9F"><span class="nav-number">9.2.2.</span> <span class="nav-text">进程pcb包括哪些信息？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="nav-number">9.2.3.</span> <span class="nav-text">进程的七状态模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">9.2.4.</span> <span class="nav-text">进程和线程的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B"><span class="nav-number">9.2.4.1.</span> <span class="nav-text">协程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">9.2.5.</span> <span class="nav-text">进程间的通信方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">9.2.6.</span> <span class="nav-text">进程调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">9.2.7.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-number">9.2.7.1.</span> <span class="nav-text">什么是死锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%9D%A1%E4%BB%B6"><span class="nav-number">9.2.7.2.</span> <span class="nav-text">死锁的四个条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">9.2.7.3.</span> <span class="nav-text">死锁的解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2"><span class="nav-number">9.2.7.3.1.</span> <span class="nav-text">死锁的预防</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%81%BF%E5%85%8D"><span class="nav-number">9.2.7.3.2.</span> <span class="nav-text">死锁的避免</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="nav-number">9.2.7.3.3.</span> <span class="nav-text">死锁的检测</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E9%99%A4"><span class="nav-number">9.2.7.3.4.</span> <span class="nav-text">死锁的解除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A4%E5%84%BF%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E7%BA%BF%E7%A8%8B"><span class="nav-number">9.2.8.</span> <span class="nav-text">孤儿线程和僵尸线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="nav-number">9.2.9.</span> <span class="nav-text">什么是临界区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%98%AF%E6%8B%B7%E8%B4%9D%E8%BF%98%E6%98%AF%E5%85%B1%E4%BA%AB%EF%BC%9F%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-number">9.2.10.</span> <span class="nav-text">父子进程的内存是拷贝还是共享？是怎么实现的？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="nav-number">9.3.</span> <span class="nav-text">局部性原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="nav-number">10.</span> <span class="nav-text">数据结构与算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E5%8F%91%E7%94%9F%E5%86%B2%E7%AA%81%E5%90%8E%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">10.1.</span> <span class="nav-text">散列函数发生冲突后的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">10.2.</span> <span class="nav-text">B树和B+树的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">10.3.</span> <span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-number">10.3.1.</span> <span class="nav-text">堆的性质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E8%B0%83%E6%95%B4"><span class="nav-number">10.3.2.</span> <span class="nav-text">堆调整</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F"><span class="nav-number">10.4.</span> <span class="nav-text">八大排序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux"><span class="nav-number">11.</span> <span class="nav-text">Linux</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">11.1.</span> <span class="nav-text">Linux常用命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="nav-number">11.2.</span> <span class="nav-text">测试网络连接的命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="nav-number">12.</span> <span class="nav-text">系统设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BB%8E%E5%A4%A7%E9%87%8F%E7%9A%84-URL-%E4%B8%AD%E6%89%BE%E5%87%BA%E7%9B%B8%E5%90%8C%E7%9A%84-URL%EF%BC%9F"><span class="nav-number">12.1.</span> <span class="nav-text">如何从大量的 URL 中找出相同的 URL？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5"><span class="nav-number">12.1.1.</span> <span class="nav-text">1. 分治策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="nav-number">12.1.2.</span> <span class="nav-text">2. 前缀树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="nav-number">12.1.3.</span> <span class="nav-text">方法总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5"><span class="nav-number">12.1.3.1.</span> <span class="nav-text">分治策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E6%A0%91"><span class="nav-number">12.1.3.2.</span> <span class="nav-text">前缀树</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
