<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Java内存区域 虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都 会同步创建一个栈帧[1]（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、ch">
<meta property="og:type" content="article">
<meta property="og:title" content="akurisu">
<meta property="og:url" content="http://example.com/2022/04/06/JVM/index.html">
<meta property="og:site_name" content="akurisu">
<meta property="og:description" content="Java内存区域 虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都 会同步创建一个栈帧[1]（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、ch">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220315164232268.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831170457337.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831170512418.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220316081701537.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831173118634.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220316082300452.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220317143558133.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220317143547828.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220317143612879.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210901112157901.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210901121032813.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210901122228916.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220316085947530.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220316090003045.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831211008162.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831211641241.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831212125813.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213622704.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213640110.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213657861.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213708776.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213724858.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213737669.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213804315.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213815371.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213826017.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215016566.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215033510.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215105280.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215146276.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215158311.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215846876.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215904073.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215919493.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831220004062.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220316113515282.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220316113853294.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220316183823997.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220317101838367.png">
<meta property="og:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220317105643388.png">
<meta property="article:published_time" content="2022-04-06T07:16:01.665Z">
<meta property="article:modified_time" content="2022-04-06T07:24:59.210Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220315164232268.png">

<link rel="canonical" href="http://example.com/2022/04/06/JVM/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | akurisu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">akurisu</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/06/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-06 15:16:01 / 修改时间：15:24:59" itemprop="dateCreated datePublished" datetime="2022-04-06T15:16:01+08:00">2022-04-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <ul>
<li><ul>
<li></li>
</ul>
</li>
</ul>
<h3 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h3><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220315164232268.png" alt="image-20220315164232268"></p>
<p><strong>虚拟机栈</strong>描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都 会同步创建一个栈帧[1]（Stack Frame）用于<strong>存储局部变量表、操作数栈、动态连接、方法出口</strong>等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、 float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始 地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress<br>类型（指向了一条字节码指令的地址）。</p>
<p>Java<strong>堆</strong>是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例。</p>
<p><strong>方法区（Method Area）</strong>与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>
<p>类加载会在方法区内加载，虚拟机栈包含了局部变量表和对象引用类型(stu,args),本地方法栈包含一些本地方法，而Hotspot虚拟机将本地方法栈合并到虚拟机栈中，解释器将Java字节码转换成机器码，对同一行代码反复解释，对于频繁执行的代码（热点代码），即时编译器发现热点代码将热点代码缓存，下次调用便会从缓存中读取。</p>
<h3 id="哪些区域会产生内存溢出"><a href="#哪些区域会产生内存溢出" class="headerlink" title="哪些区域会产生内存溢出"></a>哪些区域会产生内存溢出</h3><h4 id="产生OutOfMemoryError的情况"><a href="#产生OutOfMemoryError的情况" class="headerlink" title="产生OutOfMemoryError的情况"></a>产生OutOfMemoryError的情况</h4><ol>
<li>堆内存耗尽会出现<strong>OutOfMemoryError</strong></li>
<li>方法区内存耗尽-加载的类越来越多，很多框架都会动态的产生类，此时会产生OutOfMemoryError</li>
<li>​    虚拟机栈累积，每个线程最多占用1M内存，<strong>线程个数</strong>越来越多而又长时间不销毁，(<strong>在创建线程申请内存时就无法获得足够内</strong>存)，则会产生OutOfMemoryError</li>
</ol>
<h4 id="产生StackOverFlowError的情况"><a href="#产生StackOverFlowError的情况" class="headerlink" title="产生StackOverFlowError的情况"></a>产生StackOverFlowError的情况</h4><ol>
<li>​    HotSpot虚拟机不支持动态扩展，所以当<strong>线程内部方法</strong>调用次数过多时，虚拟机栈只会产生<strong>StackOverFlowError</strong>，而不会产生OutOfMemoryError</li>
</ol>
<h3 id="方法区与永久代、元空间的关系"><a href="#方法区与永久代、元空间的关系" class="headerlink" title="方法区与永久代、元空间的关系"></a>方法区与永久代、元空间的关系</h3><ul>
<li><strong>方法区</strong>是 JVM 规范中定义的一块内存区域，用来存储类元数据、方法字节码、即时编译器需要的信息等</li>
<li><strong>永久代</strong>是 Hotspot 虚拟机对 JVM 规范的实现（1.8 之前）</li>
<li><strong>元空间</strong>是 Hotspot 虚拟机对 JVM 规范的另一种实现（1.8 以后），使用本地内存作为这些信息的存储空间</li>
</ul>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831170457337.png" alt="image-20210831170457337"></p>
<p>从这张图学到三点</p>
<ul>
<li>当第一次用到某个类是，由类加载器将 class 文件的类元信息读入，并存储于元空间</li>
<li>X，Y 的类元信息是存储于元空间中，无法直接访问</li>
<li>可以用 X.class，Y.class 间接访问类元信息，它们俩属于 java 对象，我们的代码中可以使用</li>
</ul>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831170512418.png" alt="image-20210831170512418"></p>
<p>从这张图可以学到</p>
<ul>
<li>堆内存中：当一个<strong>类加载器对象</strong>，这个类加载器对象加载的所有<strong>类对象</strong>，这些类对象对应的所有<strong>实例对象</strong>都没人引用时，GC 时就会对它们占用的对内存进行释放</li>
<li>元空间中：内存释放<strong>以类加载器为单位</strong>，当堆中类加载器内存释放时，对应的元空间中的类元信息也会释放</li>
</ul>
<h3 id="Java虚拟机参数"><a href="#Java虚拟机参数" class="headerlink" title="Java虚拟机参数"></a>Java虚拟机参数</h3><p>-Xss  控制每个虚拟机栈的内存，Linux默认为1m</p>
<p><strong>堆内存，按大小设置</strong></p>
<p>-Xmx Java虚拟机最大内存是多少</p>
<p>-Xms Java虚拟机最小内存数</p>
<p>-Xmn 虚拟机新生代的占的内存</p>
<p>-XX:SurvivorRatio 伊甸园区和from部分的占比</p>
<p>-XX:NewRatio 控制新生代的占比</p>
<p>新生代分为伊甸园区和from区和to 区，Survivor区是from和to占的大小</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220316081701537.png" alt="image-20220316081701537"></p>
<p><strong>元空间内存设置</strong></p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831173118634.png" alt="image-20210831173118634"></p>
<p>解释：</p>
<ul>
<li>class space 存储类的基本信息，最大值受 -XX:CompressedClassSpaceSize 控制</li>
<li>non-class space 存储除类的基本信息以外的其它信息（如方法字节码、注解等）</li>
<li>class space 和 non-class space 总大小受 -XX:MaxMetaspaceSize 控制</li>
</ul>
<p>注意：</p>
<ul>
<li>这里 -XX:CompressedClassSpaceSize 这段空间还与是否开启了指针压缩有关，这里暂不深入展开，可以简单认为指针压缩默认开启</li>
</ul>
<p><strong>代码缓存内存设置</strong></p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220316082300452.png" alt="image-20220316082300452"></p>
<p>解释：</p>
<ul>
<li>如果 -XX:ReservedCodeCacheSize &lt; 240m，所有优化机器代码不加区分存在一起</li>
<li>否则，分成三个区域（图中笔误 mthod 拼写错误，少一个 e）<ul>
<li>non-nmethods - JVM 自己用的代码</li>
<li>profiled nmethods - 部分优化的机器码</li>
<li>non-profiled nmethods - 完全优化的机器码</li>
</ul>
</li>
</ul>
<h3 id="Java垃圾回收器"><a href="#Java垃圾回收器" class="headerlink" title="Java垃圾回收器"></a>Java垃圾回收器</h3><h4 id="Java的四种引用"><a href="#Java的四种引用" class="headerlink" title="Java的四种引用"></a>Java的四种引用</h4><p>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为<strong>强引用（Strongly Re-ference）、软 引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）</strong>4种，这4种引用强 度依次逐渐减弱。</p>
<ul>
<li>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object  obj&#x3D;new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回 收掉被引用的对象。</li>
</ul>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220317143558133.png" alt="image-20220317143558133"></p>
<ul>
<li><p>软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，<strong>在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。</strong>在JDK 1.2版之后提供了SoftReference类来实现软引用。</p>
<p>SoftReference a&#x3D;new SoftReference(new A); 软引用自身内存不会释放，软引用需要配合引用队列来释放，典型例子是反射数据</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220317143547828.png" alt="image-20220317143547828"></p>
</li>
<li><p>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。<strong>当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</strong>在JDK 1.2版之后提供了WeakReference类来实现弱引用。</p>
</li>
</ul>
<p>​       WeakReference a&#x3D;new WeakReference(new A);弱引用自身需要配合队列来释放，典型例子是ThreadLocalMap中的Entry对象</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220317143612879.png" alt="image-20220317143612879"></p>
<ul>
<li><p>虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。<strong>为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</strong>在JDK 1.2版之后提供<br>了PhantomReference类来实现虚引用。</p>
<p>PhantomReference a&#x3D;new PhantomReference(new A());必须配合引用队列一起使用，当虚引用的对象被回收时，会将虚引用对象入队，由Reference Handler线程释放其关联的外部资源，典型例子是Cleaner释放DirectByteBuffer占用的直接内存。</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210901112157901.png" alt="image-20210901112157901"></p>
</li>
</ul>
<h4 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h4><p>任何一个对象finalize方法都只会被系统调用一次，如果对象面临下一次回收，它的finalize方法不会再次执行。建议使用trl-finally方式代替finalize()</p>
<ul>
<li>它是 Object 中的一个方法，如果子类重写它，垃圾回收时此方法会被调用，可以在其中进行资源释放和清理工作</li>
<li>将资源释放和清理放在 finalize 方法中非常不好，非常影响性能，严重时甚至会引起 OOM，从 Java9 开始就被标注为 @Deprecated，不建议被使用了</li>
</ul>
<p><strong>finalize 原理</strong></p>
<ol>
<li>对 finalize 方法进行处理的核心逻辑位于 java.lang.ref.Finalizer 类中，它包含了名为 unfinalized 的静态变量（双向链表结构），Finalizer 也可被视为另一种引用对象（地位与软、弱、虚相当，只是不对外，无法直接使用）</li>
<li>当重写了 finalize 方法的对象，在构造方法调用之时，JVM 都会将其包装成一个 Finalizer 对象，并加入 unfinalized 链表中</li>
</ol>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210901121032813.png" alt="image-20210901121032813"></p>
<ol start="3">
<li>Finalizer 类中还有另一个重要的静态变量，即 ReferenceQueue 引用队列，刚开始它是空的。当狗对象可以被当作垃圾回收时，就会把这些狗对象对应的 Finalizer 对象加入此引用队列</li>
<li>但此时 Dog 对象还没法被立刻回收，因为 unfinalized -&gt; Finalizer 这一引用链还在引用它嘛，为的是【先别着急回收啊，等我调完 finalize 方法，再回收】</li>
<li>FinalizerThread 线程会从 ReferenceQueue 中逐一取出每个 Finalizer 对象，把它们从链表断开并真正调用 finallize 方法</li>
</ol>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210901122228916.png" alt="image-20210901122228916"></p>
<ol start="6">
<li>由于整个 Finalizer 对象已经从 unfinalized 链表中断开，这样没谁能引用到它和狗对象，所以下次 gc 时就被回收了</li>
</ol>
<p><strong>finalize 缺点</strong></p>
<ul>
<li>无法保证资源释放：FinalizerThread 是守护线程，代码很有可能没来得及执行完，线程就结束了，造成资源没有正确释放。</li>
<li>无法判断是否发生错误：执行 finalize 方法时，会吞掉任意异常（Throwable）</li>
<li>内存释放不及时：重写了 finalize 方法的对象在第一次被 gc 时，并不能及时释放它占用的内存，因为要等着 FinalizerThread 调用完 finalize，把它从 unfinalized 队列移除后，第二次 gc 时才能真正释放内存</li>
<li>可以想象gc本就因为内存不足引起，finalize调用又很慢(两个队列的移除操作，都是串行执行的，用来释放连接类的资源也应该不快)，不能及时释放内存，对象释放不及时就会逐渐移入老年代，老年代垃圾积累过多容易引起full gc，full gc后释放速度如果仍然跟不上创建新对象的速度，就会OOM。</li>
<li>有的文章提到【Finalizer 线程会和我们的主线程进行竞争，不过由于它的优先级较低，获取到的CPU时间较少，因此它永远也赶不上主线程的步伐】这个显然是错误的，FinalizerThread 的优先级较普通线程更高，原因应该是 finalize 串行执行慢等原因综合导致</li>
</ul>
<h4 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h4><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220316085947530.png" alt="image-20220316085947530"></p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220316090003045.png" alt="image-20220316090003045"></p>
<h4 id="JVM垃圾回收算法"><a href="#JVM垃圾回收算法" class="headerlink" title="JVM垃圾回收算法"></a>JVM垃圾回收算法</h4><p><strong>三种垃圾回收算法</strong></p>
<p>标记清除法</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831211008162.png" alt="image-20210831211008162"></p>
<p>解释：</p>
<ol>
<li>找到 GC Root 对象，即那些一定不会被回收的对象，如正执行方法内局部变量引用的对象、静态变量引用的对象</li>
<li>标记阶段：沿着 GC Root 对象的引用链找，直接或间接引用到的对象加上标记</li>
<li>清除阶段：释放未加标记的对象占用的内存</li>
</ol>
<p>要点：</p>
<ul>
<li>标记速度与存活对象线性关系</li>
<li>清除速度与内存大小线性关系</li>
<li>缺点是会产生内存碎片</li>
</ul>
<p>标记整理法</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831211641241.png" alt="image-20210831211641241"></p>
<p>解释：</p>
<ol>
<li>前面的标记阶段、清理阶段与标记清除法类似</li>
<li>多了一步整理的动作，将存活对象向一端移动，可以避免内存碎片产生</li>
</ol>
<p>特点：</p>
<ul>
<li><p>标记速度与存活对象线性关系</p>
</li>
<li><p>清除与整理速度与内存大小成线性关系</p>
</li>
<li><p>缺点是性能上较慢</p>
</li>
</ul>
<p>标记复制法</p>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831212125813.png" alt="image-20210831212125813"></p>
<p>解释：</p>
<ol>
<li>将整个内存分成两个大小相等的区域，from 和 to，其中 to 总是处于空闲，from 存储新创建的对象</li>
<li>标记阶段与前面的算法类似</li>
<li>在找出存活对象后，会将它们从 from 复制到 to 区域，复制的过程中自然完成了碎片整理</li>
<li>复制完成后，交换 from 和 to 的位置即可</li>
</ol>
<p>特点：</p>
<ul>
<li>标记与复制速度与存活对象成线性关系</li>
<li>缺点是会占用成倍的空间</li>
</ul>
<h4 id="GC-与分代回收算法"><a href="#GC-与分代回收算法" class="headerlink" title="GC 与分代回收算法"></a>GC 与分代回收算法</h4><p>GC 的目的在于实现无用对象内存自动释放，减少内存碎片、加快分配速度</p>
<p>GC 要点：</p>
<ul>
<li>回收区域是<strong>堆内存</strong>，不包括虚拟机栈</li>
<li>判断无用对象，使用<strong>可达性分析算法</strong>，<strong>三色标记法</strong>标记存活对象，回收未标记对象</li>
<li>GC 具体的实现称为<strong>垃圾回收器</strong></li>
<li>GC 大都采用了<strong>分代回收思想</strong><ul>
<li>理论依据是大部分对象朝生夕灭，用完立刻就可以回收，另有少部分对象会长时间存活，每次很难回收</li>
<li>根据这两类对象的特性将回收区域分为<strong>新生代</strong>和<strong>老年代</strong>，新生代采用标记复制法、老年代一般采用标记整理法</li>
</ul>
</li>
<li>根据 GC 的规模可以分成 <strong>Minor GC</strong>，<strong>Mixed GC</strong>，<strong>Full GC</strong><ul>
<li><p>Minor GC 发生在新生代的垃圾回收，暂停时间短</p>
</li>
<li><p>Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有</p>
</li>
<li><p>Full GC 新生代 + 老年代完整垃圾回收，暂停时间长，<strong>应尽力避免</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a><strong>分代回收</strong></h5><ol>
<li>伊甸园 eden，最初对象都分配到这里，与幸存区 survivor（分成 from 和 to）合称新生代，</li>
</ol>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213622704.png" alt="image-20210831213622704"></p>
<ol start="2">
<li>当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象</li>
</ol>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213640110.png" alt="image-20210831213640110"></p>
<ol start="3">
<li>将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放</li>
</ol>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213657861.png" alt="image-20210831213657861"></p>
<ol start="4">
<li>将 from 和 to 交换位置</li>
</ol>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213708776.png" alt="image-20210831213708776"></p>
<ol start="5">
<li>经过一段时间后伊甸园的内存又出现不足</li>
</ol>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213724858.png" alt="image-20210831213724858"></p>
<ol start="6">
<li>标记伊甸园与 from（现阶段没有）的存活对象</li>
</ol>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213737669.png" alt="image-20210831213737669"></p>
<ol start="7">
<li>将存活对象采用复制算法复制到 to 中</li>
</ol>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213804315.png" alt="image-20210831213804315"></p>
<ol start="8">
<li>复制完毕后，伊甸园和 from 内存都得到释放</li>
</ol>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213815371.png" alt="image-20210831213815371"></p>
<ol start="9">
<li>将 from 和 to 交换位置</li>
</ol>
<p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831213826017.png" alt="image-20210831213826017"></p>
<ol start="10">
<li>老年代 old，当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）</li>
</ol>
<h4 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h4><p>即用三种颜色记录对象的标记状态</p>
<ul>
<li>黑色 – 已标记</li>
<li>灰色 – 标记中</li>
<li>白色 – 还未标记</li>
</ul>
<ol>
<li>起始的三个对象还未处理完成，用灰色表示</li>
</ol>
<img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215016566.png" alt="image-20210831215016566" style="zoom:50%;" />

<ol start="2">
<li>该对象的引用已经处理完成，用黑色表示，黑色引用的对象变为灰色</li>
</ol>
<img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215033510.png" alt="image-20210831215033510" style="zoom:50%;" />

<ol start="3">
<li>依次类推</li>
</ol>
<img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215105280.png" alt="image-20210831215105280" style="zoom:50%;" />

<ol start="4">
<li>沿着引用链都标记了一遍</li>
</ol>
<img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215146276.png" alt="image-20210831215146276" style="zoom:50%;" />

<ol start="5">
<li>最后为标记的白色对象，即为垃圾</li>
</ol>
<img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215158311.png" alt="image-20210831215158311" style="zoom:50%;" />

<h4 id="并发漏标问题"><a href="#并发漏标问题" class="headerlink" title="并发漏标问题"></a>并发漏标问题</h4><p>比较先进的垃圾回收器都支持<strong>并发标记</strong>，即在标记过程中，用户线程仍然能工作。但这样带来一个新的问题，如果用户线程修改了对象引用，那么就存在漏标问题。例如：</p>
<p>1.黑色的多了一条引用而黑色不能使得连接的白色变为灰色状态</p>
<ol>
<li>如图所示标记工作尚未完成</li>
</ol>
<img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215846876.png" alt="image-20210831215846876" style="zoom:50%;" />

<ol start="2">
<li>用户线程同时在工作，断开了第一层 3、4 两个对象之间的引用，这时对于正在处理 3 号对象的垃圾回收线程来讲，它会将 4 号对象当做是白色垃圾</li>
</ol>
<img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215904073.png" alt="image-20210831215904073" style="zoom:50%;" />

<ol start="3">
<li>但如果其他用户线程又建立了 2、4 两个对象的引用，这时因为 2 号对象是黑色已处理对象了，因此垃圾回收线程不会察觉到这个引用关系的变化，从而产生了漏标</li>
</ol>
<img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831215919493.png" alt="image-20210831215919493" style="zoom:50%;" />

<ol start="4">
<li>如果用户线程让黑色对象引用了一个新增对象，一样会存在漏标问题</li>
</ol>
<img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20210831220004062.png" alt="image-20210831220004062" style="zoom:50%;" />

<p>因此对于<strong>并发标记</strong>而言，必须解决漏标问题，也就是要记录标记过程中的变化。有两种解决方法：</p>
<ol>
<li>Incremental Update 增量更新法，CMS 垃圾回收器采用<ul>
<li>思路是拦截每次赋值动作，只要赋值发生，被赋值的对象就会被记录下来，在重新标记阶段再确认一遍</li>
</ul>
</li>
<li>Snapshot At The Beginning，SATB 原始快照法，G1 垃圾回收器采用<ul>
<li>思路也是拦截每次赋值动作，不过记录的对象不同，也需要在重新标记阶段对这些对象二次处理</li>
<li>新加对象会被记录</li>
<li>被删除引用关系的对象也被记录</li>
</ul>
</li>
</ol>
<h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><h5 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h5><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220316113515282.png" alt="image-20220316113515282"></p>
<p>迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的默认新生 代收集器，有着优于其他收集器的地方，那就是简单而高效（与其他收集器的单线程相比），对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）[1]最小的</p>
<h5 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h5><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220316113853294.png" alt="image-20220316113853294"></p>
<h5 id="垃圾回收器-Parallel-GC"><a href="#垃圾回收器-Parallel-GC" class="headerlink" title="垃圾回收器 - Parallel GC"></a><strong>垃圾回收器 - Parallel GC</strong></h5><ul>
<li><p>eden 内存不足发生 Minor GC，采用标记复制算法，需要暂停用户线程</p>
</li>
<li><p>old 内存不足发生 Full GC，采用标记整理算法，需要暂停用户线程</p>
</li>
<li><p><strong>注重吞吐量</strong></p>
</li>
</ul>
<p><strong>垃圾回收器 - ConcurrentMarkSweep GC</strong></p>
<ul>
<li><p>它是工作在 old 老年代，支持<strong>并发标记</strong>的一款回收器，采用<strong>并发清除</strong>算法</p>
<ul>
<li>并发标记时不需暂停用户线程</li>
<li>重新标记时仍需暂停用户线程</li>
</ul>
</li>
<li><p>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</p>
</li>
<li><p><strong>注重响应时间</strong></p>
</li>
</ul>
<h5 id="垃圾回收器-G1-GC"><a href="#垃圾回收器-G1-GC" class="headerlink" title="垃圾回收器 - G1 GC"></a>垃圾回收器 - G1 GC</h5><ul>
<li><strong>响应时间与吞吐量兼顾</strong></li>
<li>划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous，其中 humongous 专为大对象准备</li>
<li>分成三个阶段：新生代回收、并发标记、混合收集</li>
<li>如果并发失败（即回收速度赶不上创建新对象速度），会触发 Full GC</li>
</ul>
<p>-XX:G1HeapRegionSize 设定区域大小</p>
<h3 id="面试题：项目什么情况下会内存溢出，怎么解决的"><a href="#面试题：项目什么情况下会内存溢出，怎么解决的" class="headerlink" title="面试题：项目什么情况下会内存溢出，怎么解决的"></a>面试题：项目什么情况下会内存溢出，怎么解决的</h3><p><strong>典型情况</strong></p>
<ul>
<li>误用线程池导致的内存溢出<ul>
<li>参考 day03.TestOomThreadPool</li>
</ul>
</li>
<li>查询数据量太大导致的内存溢出<ul>
<li>参考 day03.TestOomTooManyObject</li>
</ul>
</li>
<li>动态生成类导致的内存溢出<ul>
<li>参考 day03.TestOomTooManyClass</li>
</ul>
</li>
</ul>
<h3 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h3><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220316183823997.png" alt="image-20220316183823997"></p>
<h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><ol>
<li><p>加载</p>
<ol>
<li><p>将类的字节码载入方法区，并创建类.class 对象</p>
</li>
<li><p>如果此类的父类没有加载，先加载父类</p>
</li>
<li><p>加载是懒惰执行</p>
</li>
</ol>
</li>
<li><p>链接</p>
<ol>
<li>验证 – 验证类是否符合 Class 规范，合法性、安全性检查</li>
<li>准备 – 为 static 变量分配空间，设置默认值</li>
<li>解析 – 将常量池的符号引用解析为直接引用</li>
</ol>
</li>
<li><p>初始化</p>
<ol>
<li>静态代码块、static 修饰的变量赋值、static final 修饰的引用类型变量赋值，会被合并成一个 <code>&lt;cinit&gt;</code> 方法，在初始化时被调用</li>
<li>static final 修饰的基本类型变量赋值，在链接阶段就已完成</li>
<li>初始化是懒惰执行</li>
</ol>
</li>
</ol>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220317101838367.png" alt="image-20220317101838367"></p>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p><img src="http://r9wfwrw6c.hb-bkt.clouddn.com/JVM.assets/image-20220317105643388.png" alt="image-20220317105643388"></p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 首先，检查请求的类是否已经被加载过了 </span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name); </span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123; </span><br><span class="line">                c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">             &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                c = findBootstrapClassOrNull(name);</span><br><span class="line">             &#125;        </span><br><span class="line">             &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; </span><br><span class="line">             <span class="comment">// 如果父类加载器抛出ClassNotFoundException </span></span><br><span class="line">             <span class="comment">// 说明父类加载器无法完成加载请求</span></span><br><span class="line">             &#125; </span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 在父类加载器无法加载时 </span></span><br><span class="line">            <span class="comment">// 再调用本身的findClass方法来进行类加载 </span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">             &#125;</span><br><span class="line">     &#125; </span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123; </span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所谓的双亲委派，就是指优先委派上级类加载器进行加载，如果上级类加载器</p>
<ul>
<li>能找到这个类，由上级加载，加载后该类也对下级加载器可见</li>
<li>找不到这个类，则下级类加载器才有资格执行加载</li>
</ul>
<p>双亲委派的目的有两点</p>
<ol>
<li><p>让上级类加载器中的类对下级共享（反之不行），即能让你的类能依赖到 jdk 提供的核心类</p>
</li>
<li><p>让类的加载有优先次序，保证核心类优先加载</p>
</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/04/06/JUC%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/04/06/MQ/" rel="next" title="">
       <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="nav-number">1.</span> <span class="nav-text">Java内存区域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%9F%9F%E4%BC%9A%E4%BA%A7%E7%94%9F%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-number">2.</span> <span class="nav-text">哪些区域会产生内存溢出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A7%E7%94%9FOutOfMemoryError%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">2.1.</span> <span class="nav-text">产生OutOfMemoryError的情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%A7%E7%94%9FStackOverFlowError%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">2.2.</span> <span class="nav-text">产生StackOverFlowError的情况</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E4%B8%8E%E6%B0%B8%E4%B9%85%E4%BB%A3%E3%80%81%E5%85%83%E7%A9%BA%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">3.</span> <span class="nav-text">方法区与永久代、元空间的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%82%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">Java虚拟机参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text">Java垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="nav-number">5.1.</span> <span class="nav-text">Java的四种引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finalize%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">finalize方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA"><span class="nav-number">5.3.</span> <span class="nav-text">分代收集理论</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">5.4.</span> <span class="nav-text">JVM垃圾回收算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GC-%E4%B8%8E%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">5.5.</span> <span class="nav-text">GC 与分代回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="nav-number">5.5.1.</span> <span class="nav-text">分代回收</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0"><span class="nav-number">5.6.</span> <span class="nav-text">三色标记</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%BC%8F%E6%A0%87%E9%97%AE%E9%A2%98"><span class="nav-number">5.7.</span> <span class="nav-text">并发漏标问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">5.8.</span> <span class="nav-text">垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Serial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">5.8.1.</span> <span class="nav-text">Serial收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">5.8.2.</span> <span class="nav-text">ParNew收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-Parallel-GC"><span class="nav-number">5.8.3.</span> <span class="nav-text">垃圾回收器 - Parallel GC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-G1-GC"><span class="nav-number">5.8.4.</span> <span class="nav-text">垃圾回收器 - G1 GC</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E9%A1%B9%E7%9B%AE%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84"><span class="nav-number">6.</span> <span class="nav-text">面试题：项目什么情况下会内存溢出，怎么解决的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">7.</span> <span class="nav-text">虚拟机类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">7.1.</span> <span class="nav-text">类的生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">7.2.</span> <span class="nav-text">类加载过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">7.3.</span> <span class="nav-text">类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.4.</span> <span class="nav-text">双亲委派模型</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
