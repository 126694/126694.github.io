<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="OSI七层网络体系 TCP&#x2F;IP网络体系  应用层 传输层 网络层 网络接口层  应用层协议HTTPHTTP报文头下面提供了一个典型的HTTP请求报文:  12345GET &#x2F;somedir&#x2F;page・html HTTP&#x2F;1.1 Host: www・someschool•edu Connection: close User-agent: Mozilla&#x2F;5•0Accept-langua">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="http://example.com/2022/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="akurisu">
<meta property="og:description" content="OSI七层网络体系 TCP&#x2F;IP网络体系  应用层 传输层 网络层 网络接口层  应用层协议HTTPHTTP报文头下面提供了一个典型的HTTP请求报文:  12345GET &#x2F;somedir&#x2F;page・html HTTP&#x2F;1.1 Host: www・someschool•edu Connection: close User-agent: Mozilla&#x2F;5•0Accept-langua">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220313185712942.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220313185422470.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329122500251.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329125857983.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329131132781.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220330093509369.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220330100416720.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329083907417.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329085636059.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329093110364.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329094335339.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329100939294.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329101247891.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329115402388.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220314105352113.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329120555130.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220324202652206.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/tcp-vs-udp.jpg">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220313162307775.png">
<meta property="og:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220330100701382.png">
<meta property="article:published_time" content="2022-03-01T15:47:44.000Z">
<meta property="article:modified_time" content="2022-04-21T05:48:46.109Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220313185712942.png">

<link rel="canonical" href="http://example.com/2022/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机网络 | akurisu</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">akurisu</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="akurisu">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-01 23:47:44" itemprop="dateCreated datePublished" datetime="2022-03-01T23:47:44+08:00">2022-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-21 13:48:46" itemprop="dateModified" datetime="2022-04-21T13:48:46+08:00">2022-04-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">Java知识</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<h3 id="OSI七层网络体系"><a href="#OSI七层网络体系" class="headerlink" title="OSI七层网络体系"></a>OSI七层网络体系</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220313185712942.png" alt="image-20220313185712942"></p>
<h3 id="TCP-x2F-IP网络体系"><a href="#TCP-x2F-IP网络体系" class="headerlink" title="TCP&#x2F;IP网络体系"></a>TCP&#x2F;IP网络体系</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220313185422470.png" alt="image-20220313185422470"></p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层</li>
</ol>
<h1 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP报文头"><a href="#HTTP报文头" class="headerlink" title="HTTP报文头"></a>HTTP报文头</h3><p>下面提供了一个典型的HTTP请求报文: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /somedir/page・html HTTP/1.1 </span><br><span class="line">Host: www・someschool•edu </span><br><span class="line">Connection: close </span><br><span class="line">User-agent: Mozilla/5•0</span><br><span class="line">Accept-language: fr</span><br></pre></td></tr></table></figure>

<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329122500251.png" alt="image-20220329122500251"></p>
<p>http 报文头分为两种，一种是请求报文头和响应报文头 包含一下几个部分：<strong>请求行，首部行和实体体</strong>。其中请求行包含了这个请求的方法：有 GET、  POST、PUT、HEAD、DELETE。还包含了 URL 字段和 HTTP 的版本。实体体中，<strong>如果使用的是 get 方法，那么实体体就为空，如果使用的是 post 方法，那么响应的文本内容就会放在实体体中。</strong>HEAD 方法类似于 GET 方法，但是发送一个 HEAD 请求是不会返回请求的对象的。一般用于调试。PUT 方法时允许用户上传对象到指定的 web 服务器上的指定路径。DELETE 就是删除 web 服务器上的对象。首部行里面的信息。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329125857983.png" alt="image-20220329125857983"></p>
<p>我们仔细看一下这个响应报文。它有三个部分：一个初始状态行（status line） , 6个 首部行（headerline）,然后是实体体（entity body）o。</p>
<h3 id="Http常见响应码"><a href="#Http常见响应码" class="headerlink" title="Http常见响应码"></a>Http常见响应码</h3><h4 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h4><ul>
<li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li>
</ul>
<h4 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="#2XX 成功"></a><a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html#_2xx-%E6%88%90%E5%8A%9F">#</a>2XX 成功</h4><ul>
<li><strong>200 OK</strong>   请求成功，信息在返回的响应报文中。</li>
<li><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li>
<li><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li>
</ul>
<h4 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="#3XX 重定向"></a><a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html#_3xx-%E9%87%8D%E5%AE%9A%E5%90%91">#</a>3XX 重定向</h4><ul>
<li><strong>301 Moved Permanently</strong> ：永久性重定向</li>
<li><strong>302 Found</strong> ：临时性重定向</li>
<li><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li>
<li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li>
<li><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li>
<li><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li>
</ul>
<h4 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="#4XX 客户端错误"></a><a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html#_4xx-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF">#</a>4XX 客户端错误</h4><ul>
<li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li>
<li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li>
<li><strong>403 Forbidden</strong> ：请求被拒绝。</li>
<li><strong>404 Not Found</strong>：被请求的文档不在服务器上</li>
</ul>
<h4 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="#5XX 服务器错误"></a><a target="_blank" rel="noopener" href="https://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/HTTP/HTTP.html#_5xx-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF">#</a>5XX 服务器错误</h4><ul>
<li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li>
<li><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</li>
<li><strong>505 HTTP Version Not Supported</strong>：服务器不支持请求报文使用的HTTP协议版本。</li>
</ul>
<h3 id="HTTP-x2F-1-0vsHTTP-x2F-1-1vsHTTP-x2F-2-0"><a href="#HTTP-x2F-1-0vsHTTP-x2F-1-1vsHTTP-x2F-2-0" class="headerlink" title="HTTP&#x2F;1.0vsHTTP&#x2F;1.1vsHTTP&#x2F;2.0"></a>HTTP&#x2F;1.0vsHTTP&#x2F;1.1vsHTTP&#x2F;2.0</h3><h4 id="HTTP-x2F-1-0"><a href="#HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h4><p>HTTP&#x2F;1.0中浏览器与服务器<strong>只保持短暂的连接，连接无法复用</strong>。也就是说每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p>
<p>我们知道TCP连接的建立需要三次握手，是很耗费时间的一个过程。所以，<strong>HTTP&#x2F;1.0版本的性能比较差</strong>。</p>
<blockquote>
<p>HTTP1.0 其实也可以强制开启长链接，例如接受<code>Connection: keep-alive</code> 这个字段，但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p>
</blockquote>
<h4 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h4><p>为了解决HTTP&#x2F;1.0存在的缺陷，HTTP&#x2F;1.1于1999年诞生。相比较于HTTP&#x2F;1.0来说，最主要的改进就是引入了持久连接。所谓的持久连接即<strong>TCP连接默认不关闭，可以被多个请求复用</strong>。</p>
<p>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。或者客户端在最后一个请求时，主动告诉服务端要关闭连接。H<strong>TTP&#x2F;1.1版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</strong></p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329131132781.png" alt="image-20220329131132781"></p>
<h4 id="HTTP-x2F-2-0"><a href="#HTTP-x2F-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h4><p>  HTTP&#x2F;2.0主要基于 SPDY 协议。HTTP&#x2F;2 为了解决HTTP&#x2F;1.1中仍然存在的效率问题，HTTP&#x2F;2 采用了<strong>多路复用</strong>。即在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。能这样做有一个前提，就是HTTP&#x2F;2进行了<strong>二进制分帧</strong>，即 HTTP&#x2F;2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码。</p>
<p>  除此之外，还有一些其他的优化，比如<strong>做Header压缩、服务端推送</strong>等。</p>
<p>  <strong>Header压缩</strong>就是压缩老板和员工之间的对话。</p>
<p>  <strong>服务端推送</strong>就是员工事先把一些老板可能询问的事情提现发送到老板的手机（缓存）上。这样老板想要知道的时候就可以直接读取短信（缓存）了。</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>  HTTPS 是在 HTTP 的基础上增加了 <strong>SSL 或 TLS 安全协议</strong>（TLS 不支持数字证书），让 HTTP 先 和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行 通信。</p>
<p>   SSL 和 TLS 这两个协议可以加密处理数据（采用混合加密技术）防止数据被监听、验证通信方身份 （通过数字证书认证通信方是自己的服务器）以及数据完整性保护（防止传输的内容被中间人冒充 或者篡改），也就是说 HTTPS 使用了隧道进行通信。隧道：使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。 </p>
<p>  通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p>
<h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220330093509369.png" alt="image-20220330093509369"></p>
<p>1、 客户端发送自己支持的加密规则给服务器，代表告诉服务器要进行连接了；</p>
<p>2、 服务器从中选出一套加密算法和 hash 算法以及自己的身份信息（地址等）以证书的形式发送给浏览器，证书中包含<strong>服务器信息，加密公钥，证书的办法机构；</strong></p>
<p>3、客户端收到网站的证书之后要做下面的事情：</p>
<ul>
<li>验证证书的合法性；</li>
<li>如果验证通过证书，浏览器会生成一串随机数<strong>密钥</strong>，并用证书中的公钥进行加密；</li>
<li>用约定好的 hash 算法计算握手消息，然后用生成的密钥进行加密，然后一起发送给服务器。</li>
</ul>
<p>4、服务器接收到客户端传送来的信息，要做下面的事情：</p>
<ul>
<li>4.1 用私钥解析出密钥，用密钥解析握手消息，验证 hash 值是否和浏览器发来的一致；</li>
<li>4.2 使用密钥加密消息；</li>
</ul>
<p>5、如果计算法 hash 值一致，握手成功。</p>
<h4 id="对称式加密"><a href="#对称式加密" class="headerlink" title="对称式加密"></a>对称式加密</h4><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p>
<ul>
<li>优点：运算速度快； </li>
<li>缺点：无法安全地将密钥传输给通信方。</li>
</ul>
<h4 id="非对称式加密"><a href="#非对称式加密" class="headerlink" title="非对称式加密"></a>非对称式加密</h4><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p>
<p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。 </p>
<p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此<strong>通信发送方使用其私有密钥进行签名</strong>，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p>
<ul>
<li>优点：可以更安全地将公开密钥传输给通信发送方； </li>
<li>缺点：运算速度慢</li>
</ul>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="DNS-的查询过程"><a href="#DNS-的查询过程" class="headerlink" title="DNS 的查询过程"></a>DNS 的查询过程</h3><p>首先通过 URL 找到主机名。比如 <a target="_blank" rel="noopener" href="http://www.baidu.com,**根据这个去浏览器缓存里面找,如果没有就去本机的/">www.baidu.com，**根据这个去浏览器缓存里面找，如果没有就去本机的</a> host 的文件找，在没有就去访问本地域名服务器<strong>，询问能不能找到这个主机 IP 地址的缓存。 再没有就通过迭代的方法，找</strong>根域名服务器，顶级、权威，最后返回一个 ip 地址给 DNS 应用**。 当发送一个 DNS 请求的时候，如果本地域名服务器中没有的话，本地域名服务器就会代理的作用将请求转发到 DNS 服务器层次结构中。</p>
<h3 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220330100416720.png" alt="image-20220330100416720"></p>
<p>至此我们的讨论一直忽略了 DNS系统 的一个非常重要特色：DNS缓存(DNS caching) o实际上，为了改善时延性能并减 少在因特网上到处传输的DNS报文数量， DNS广泛使用了缓存技术。DNS缓存的原 理非常简单。在一个请求链中，当某DNS 服务器接收一个DNS回答(例如，包含某 主机名到IP地址的映射)时，它能将映射 缓存在本地存储器中。例如，在图2・18 中，每当本地DNS服务器dns. nyu. edu从 某个DNS服务器接收到一个回答，它能够 缓存包含在该回答中的任何信息。如果在 DNS服务器中缓存了一台主机名&#x2F;IP地址 对，另一个对相同主机名的查询到达该 DNS服务器时，该DNS服务器就能够提供 所要求的IP地址，即使它不是该主机名的权威服务器。由于主机和主机名与IP地址间的映射并不是永久的，DNS服务器在一段时间后(通常设置为两天)将丢弃缓存的信息。</p>
<p>举一个例子，假定主机apricot, nyu. edu向dns. nyu. edu查询主机名cnn. com的IP地址。 此后，假定过了几个小时，纽约大学的另外一台主机如kiwi. nyu. edu也向dns. nyu. edu查询 相同的主机名。因为有了缓存，该本地DNS服务器可以立即返回cnn. com的IP地址，而不 必查询任何其他DNS服务器。本地DNS服务器也能够缓存TLD服务器的IP地址，因而允 许本地DNS绕过查询链中的根DNS服务器。事实上，因为缓存，除了少数DNS查询以外，根服务器被绕过了。</p>
<p>http 请求都有哪些？</p>
<ul>
<li>GET 获取资源，服务端返回报文实体主体部分。  </li>
<li>HEAD 与 GET 类似，但是服务端不返回报文实体主体部分。 </li>
<li>POST 传输实体主体 </li>
<li>PUT 上传文件，存在安全性问题，一般不建议使用 </li>
<li>PATCH 对资源进行部分修改 </li>
<li>DELETE 删除文件，与 PUT 功能相反，并且同样不带验证机制 </li>
<li>OPTIONS 查询指定的 URL 能够支持的方法，会返回 Allow：GET，POST，HEAD 这样的内容。 </li>
<li>CONNECT 要求在与代理服务器通信时建立隧道 </li>
<li>TRACE 追踪路径，服务器会将通信路径返回给客户端，通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）</li>
</ul>
<h1 id="运输层协议"><a href="#运输层协议" class="headerlink" title="运输层协议"></a>运输层协议</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><h4 id="三次握手的概念"><a href="#三次握手的概念" class="headerlink" title="三次握手的概念"></a>三次握手的概念</h4><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329083907417.png" alt="image-20220329083907417"></p>
<p> 刚开始客户端处于 closed 的状态，服务端处于 listen 状态。然后<br>   1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN（c）。此时客户端处于 SYN_Send 状态。</p>
<p>   2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</p>
<p>   3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。</p>
<p>   4、服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接。</p>
<h4 id="三次握手作用"><a href="#三次握手作用" class="headerlink" title="三次握手作用"></a>三次握手作用</h4><p> 1、确认双方的接受能力、发送能力是否正常。<br> 2、指定自己的初始化序列号，为后面的可靠传送做准备。<br> 3、如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成到。</p>
<h4 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h4><ul>
<li>当进行第一次握手，网络不好可能会堵塞，所以连接的请求并没有到达服务器端；</li>
<li>但是tcp连接有超时重传的机制，所以再一次发送请求，这时候服务器端接收到了你的请求，他也会返回一个请求给你，这是第二次握手；</li>
<li>但是这时候网络环境突然又好了起来，那个堵塞的请求到达了服务器端，服务器端又给你回了一个请求，但是你又不想给服务器发送请求，这时候服务器的资源会进行占用等待你的请求，为了不使服务器的资源继续占用，你又必须发送一个请求给服务器；所以要进行3次握手</li>
</ul>
<h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329085636059.png" alt="image-20220329085636059"></p>
<p>1、第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。</p>
<p>2、第二次握手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。</p>
<p>3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</p>
<p>4、第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态</p>
<p>5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p>
<h4 id="为什么最后还要等待TIME-WAIT"><a href="#为什么最后还要等待TIME-WAIT" class="headerlink" title="为什么最后还要等待TIME_WAIT"></a>为什么最后还要等待TIME_WAIT</h4><p>  这其中的原因就是，要确保服务器是否已经收到了我们的 ACK 报文，如果没有收到的话，服务器会重新发 FIN 报文给客户端，客户端再次收到 ACK 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文。<br>  至于 TIME_WAIT 持续的时间至少是一个报文的来回时间，即2MSL(Maximum Segment  Lifetime)。MSL 指一个片段在网络中最大的存活时间，一般会设置一个计时，如果过了这个计时没有再次收到 FIN 报文，则代表对方成功就是 ACK 报文，此时处于 CLOSED 状态。</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>  窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP  确认报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗 口大小，从而控制发送速率。</p>
<p>   发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且 已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。 </p>
<p>  接收方只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节序号为 {31,   34, 35}，其中 {31}按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个 字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329093110364.png" alt="image-20220329093110364"></p>
<p>  TCP 链接的每一侧主机都为该 TCP 链接设置了接收缓存。当 TCP 链接收到正确、按续的字节后，它就将数据放入接收缓存。相关联的应用进程就会从该缓存中读取数据，不是数据一道道就立 马读取数据。当发送送方发的太快了，太多了，很容易使接收方缓存溢出。这个时候就需要流量控制来解决。他是一个速度匹配的服务。</p>
<p>  TCP通过让发送方维护一个称为接收窗口(receive window)的变量来提供流量控制，接收窗口用于给发送方一个指示一一该接收方还有多少可用的缓存空间。因为 TCP是全双工通信，在连接两端的发送方都各自维护一个接收窗口。主机B通过把当前的rwnd值放入它发给主机A的报文段接收窗口字段中，通知主机A它在该连接的缓存中还有多少可用空间。当主机B的接收窗口为0时，主机A继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认。最终缓存将开始清空，并且确认报文里将包含一个非0的rwnd 值。</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>  TCP 主要通过四个算法来进行拥塞控制：<strong>慢开始、拥塞避免、快重传、快恢复。</strong> 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞 窗口只是一状态变量，实际决定发送方能发送多少数据的是发送方窗口</p>
<p>为了便于讨论，做如下假设： </p>
<ul>
<li>接收方有足够大的接收缓存，因此不会发生流量控制； </li>
<li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li>
</ul>
<p>​    <img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329094335339.png" alt="image-20220329094335339"></p>
<h4 id="慢开始与拥塞避免"><a href="#慢开始与拥塞避免" class="headerlink" title="慢开始与拥塞避免"></a>慢开始与拥塞避免</h4><p>  发送的最初执行慢开始，令 cwnd &#x3D; 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … </p>
<p>  注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的 速度增长速度过快，网络拥塞的可能性也就更高。<strong>设置一个慢开始门限 ssthresh，当 cwnd &gt;&#x3D; ssthresh  时，进入拥塞避免，每个轮次只将 cwnd 加 1。</strong></p>
<p>  如果出现了超时（即发送方没有接收到接收方传过来的确认报文），则令 <strong>ssthresh &#x3D; cwnd &#x2F; 2</strong>，然后 重新执行慢开始。 </p>
<p>  注意：拥塞避免并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增 长，使网络比较不容易出现拥塞。</p>
<h4 id="快重传与快恢复"><a href="#快重传与快恢复" class="headerlink" title="快重传与快恢复"></a>快重传与快恢复</h4><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329100939294.png" alt="image-20220329100939294"></p>
<p>  所谓快重传，就是使发送方尽早知道发生了个别报文段丢失，尽快重传，而不是等待重传计时器超 时再重传。</p>
<p>   在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认（所以才会有了下边连续 3 次重复确认 M2）。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确 认。 </p>
<p>  在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 <strong>cwnd &#x3D;ssthresh &#x3D; cwnd  &#x2F; 2</strong> ，注意到此时直接进入拥塞避免。 </p>
<p>  <strong>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1， 而快恢复 cwnd 设定为 ssthresh。</strong></p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329101247891.png" alt="image-20220329101247891"></p>
<h3 id="TCP报文头格式"><a href="#TCP报文头格式" class="headerlink" title="TCP报文头格式"></a>TCP报文头格式</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329115402388.png" alt="image-20220329115402388"></p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220314105352113.png" alt="image-20220314105352113"></p>
<p><strong>序号</strong>：TCP 的序号是数据流中的字节数，不是分组的序号。表示该报文段数据字段首字节的序号。</p>
<p> <strong>确认号</strong>：TCP 使用累积确认，确认号是第一个未收到的字节序号，表示希望接收到的下一个字节。</p>
<p> <strong>首部长度</strong>：通常选项字段为空，所以一般 TCP 首部的长度是 <strong>20</strong> <strong>字节</strong>。</p>
<p> <strong>选项字段</strong>(可选与变长的)：用于发送方与接收方协商 MSS(最大报文段长)，或在高速网络环境下用作窗口</p>
<p>调节因子。</p>
<p> <strong>标志字段</strong></p>
<p> <strong>ACK</strong>：指示确认字段中的值是有效的</p>
<p> <strong>RST,SYN,FIN</strong>：连接建立与拆除</p>
<p> <strong>PSH</strong>：指示接收方应立即将数据交给上层</p>
<p> <strong>URG</strong>：报文段中存在着(被发送方的上层实体置位)“紧急”的数据</p>
<p> <strong>接收窗口</strong>：用于流量控制（表示接收方还有多少可用的缓存空间）。</p>
<p> TCP RFC 并没有规定失序到达的分组应该如何处理，而是交给程序员。可以选择丢弃或保留。如果发生超时，TCP <strong>只重传第一个已发送而未确认的分组</strong>，超时时间间隔会设置为原来的</p>
<h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220329120555130.png" alt="image-20220329120555130"></p>
<p>  UDP 在传送数据之前不需要先建立连接（无连接），远地主机在收到 UDP 报文后，不需要给出任 何确认。一般用于即时通信，因为偶尔丢失包也没有影响，比如： QQ 语音、 QQ 视频 、直播等 等。</p>
<p>  TCP 不提供广播或多播服务。</p>
<p>  TCP 要提供可靠的，面向连接的运输服务（TCP 的面向连接体现在 TCP 在传递数据之前，会有三 次握手来建立连接，在数据传完后，会断开连接用来节约系统资源，可靠性体现在数据传递时，有 JIANG J Q: 699046690 报文确认、滑动窗口、超时重传、拥塞控制机制），这一系列操作增加了许多开销。这不仅使 TCP 首部增大很多，还要占用许多处理机资源。TCP 一般用于需要可靠传输的场景，比如：文件传输、 发送邮件、远程登录（包括了文件传输）等场景。</p>
<p> 总的来说： </p>
<ol>
<li>TCP 面向连接，UDP 无连接。 </li>
<li>TCP 可靠传输，UDP 不可靠传输。 </li>
<li>TCP 传输慢，UDP 传输快。 </li>
<li>TCP 所需资源多（比如：超时重传功能需要先缓存已发送的数据），UDP 所需资源少。 </li>
<li>TCP 首部字节多（因为有 ACK，SYN，FIN 等字段以及滑动窗口等），UPD 首部字节少。</li>
</ol>
<h3 id="TCP粘包和拆包"><a href="#TCP粘包和拆包" class="headerlink" title="TCP粘包和拆包"></a>TCP粘包和拆包</h3><p>由于TCP传输协议面向流的，<strong>没有消息保护边界</strong>。一方发送的多个报文可能会被合并成一个大的报文进行传输，这就是粘包；也可能发送的一个报文，可能会被拆分成多个小报文，这就是拆包。</p>
<p>发生TCP粘包、拆包主要是以下原因：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）应用程序写入数据大于套接字缓冲区大小，会发生拆包；</span><br><span class="line">（2）应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发送粘包；</span><br><span class="line">（3）进行MSS（最大报文长度）大小的TCP分段，当TCP报文长度——TCP header长度&gt;MSS  的时候会发生拆包；</span><br><span class="line">（4）接收方法不及时读取套接字缓冲区数据，这将发生粘包。</span><br></pre></td></tr></table></figure>

<p> <strong>UDP会不会产生粘包问题呢？</strong></p>
<p> TCP为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的（保护消息边界：指传输协议把数据当做一条独立的消息在网上传输，接收端一次只能接受一条独立的消息）。UDP则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。</p>
<p> 举个例子：有三个数据包，大小分别为2k、4k、6k，如果采用UDP发送的话，不管接受方的接收缓存有多大，我们必须要进行至少三次以上的发送才能把数据包发送完，但是使用TCP协议发送的话，我们只需要接受方的接收缓存有12k的大小，就可以一次把这3个数据包全部发送完毕。</p>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220324202652206.png" alt="image-20220324202652206"></p>
<h3 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h3><ol>
<li><p>应用数据被分割成 TCP 认为最适合发送的数据块。</p>
</li>
<li><p>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</p>
</li>
<li><p><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p>
</li>
<li><p>TCP 的接收端会丢弃重复的数据。</p>
</li>
<li><p><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</p>
<p>在连接双方都维护一个接收窗口，主机B为该连接分配了一个接收缓存，用RcvBuffer表示大小，rwnd&#x3D;RcvBuffer-LastByteRcvd+LastbyteRead</p>
<p>，主机B把当前rwnd放到发给主机A的报文段接收窗口中，通知主机A该连接缓存还有多少空间，将未确认的数量控制在rwnd以内就可以保证主机A不会使主机B的接收缓存溢出。</p>
</li>
<li><p><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<ul>
<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li>
<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送放的 cwnd 加 1.</li>
<li><strong>快重传与快恢复：</strong> 在 TCP&#x2F;IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>
</ul>
</li>
<li><p><strong>ARQ 协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p>
</li>
<li><p><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段</p>
</li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="TCP和UDP有如下区别："><a href="#TCP和UDP有如下区别：" class="headerlink" title="TCP和UDP有如下区别："></a>TCP和UDP有如下区别：</h3><ol>
<li>连接：TCP面向连接的传输层协议，即传输数据之前必须先建立好连接；UDP无连接。</li>
<li>服务对象：TCP点对点的两点间服务，即一条TCP连接只能有两个端点；UDP支持一对一，一对多，多对一，多对多的交互通信。</li>
<li>可靠性：TCP可靠交付：无差错，不丢失，不重复，按序到达；UDP尽最大努力交付，不保证可靠交付。</li>
<li>拥塞控制&#x2F;流量控制：有拥塞控制和流量控制保证数据传输的安全性；UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。</li>
<li>报文长度：TCP动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的；UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。</li>
<li>首部开销：TCP首部开销大，首部20个字节；UDP首部开销小，8字节（源端口，目的端口，数据长度，校验和）。</li>
<li>适用场景（由特性决定）：数据完整性需让位于通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。</li>
</ol>
<p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/tcp-vs-udp.jpg" alt="TCP、UDP协议的区别"></p>
<h3 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议"></a>ARQ 协议</h3><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p>
<h4 id="停止等待-ARQ-协议"><a href="#停止等待-ARQ-协议" class="headerlink" title="#停止等待 ARQ 协议"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/cs-basics/network/other-network-questions.html#%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85-arq-%E5%8D%8F%E8%AE%AE">#</a>停止等待 ARQ 协议</h4><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。</p>
<p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h3 id="IPv4数据报格式"><a href="#IPv4数据报格式" class="headerlink" title="IPv4数据报格式"></a>IPv4数据报格式</h3><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220313162307775.png" alt="image-20220313162307775"></p>
<ul>
<li>4比特版本号</li>
<li>4比特首部长度</li>
<li>8比特服务类型</li>
<li>16比特数据报长度</li>
<li>16比特标识、4比特标志、12比特片偏移</li>
<li>8比特寿命</li>
<li>8比特协议</li>
<li>16比特首部检验和</li>
<li>32比特源和32比特目的IP地址</li>
<li>选项</li>
<li>数据（有效载荷）</li>
</ul>
<h3 id="IPv4数据报分片-标识、标志、偏移量"><a href="#IPv4数据报分片-标识、标志、偏移量" class="headerlink" title="IPv4数据报分片(标识、标志、偏移量)"></a>IPv4数据报分片(标识、标志、偏移量)</h3><p>发送主机在为数据报设置源和目标地址的同时贴上标识号，发送主机通常将它发送的每个数据报的标识号加1，当分片时，片具有初始数据报的源地址、目的地址和标识号。</p>
<p>最后一个分片标志比特被设为了0，其他片标志比特被设为1,使用偏移字段指定该片在数据报的哪个位置。</p>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="打开一个网页，整个过程会使用哪些协议（过程有-6-个）"><a href="#打开一个网页，整个过程会使用哪些协议（过程有-6-个）" class="headerlink" title="打开一个网页，整个过程会使用哪些协议（过程有 6 个）"></a>打开一个网页，整个过程会使用哪些协议（过程有 6 个）</h2><p><img src="https://akurisu-blog.oss-cn-beijing.aliyuncs.com/blog/image-20220330100701382.png" alt="image-20220330100701382"></p>
<p>总体来说分为以下几个过程: 1.</p>
<ol>
<li>DNS 解析 </li>
<li>TCP 连接 </li>
<li>SSL 握手 </li>
<li>发送 HTTP 请求 </li>
<li>服务器处理请求并返回 HTTP 报文 </li>
<li>浏览器解析渲染页面 </li>
<li>连接结束</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2022/03/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="next" title="操作系统">
      操作系统 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#OSI%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB"><span class="nav-number">1.</span> <span class="nav-text">OSI七层网络体系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-x2F-IP%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB"><span class="nav-number">2.</span> <span class="nav-text">TCP&#x2F;IP网络体系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number"></span> <span class="nav-text">应用层协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP"><span class="nav-number"></span> <span class="nav-text">HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E6%8A%A5%E6%96%87%E5%A4%B4"><span class="nav-number">1.</span> <span class="nav-text">HTTP报文头</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Http%E5%B8%B8%E8%A7%81%E5%93%8D%E5%BA%94%E7%A0%81"><span class="nav-number">2.</span> <span class="nav-text">Http常见响应码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1XX-%E4%BF%A1%E6%81%AF"><span class="nav-number">2.1.</span> <span class="nav-text">1XX 信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2XX-%E6%88%90%E5%8A%9F"><span class="nav-number">2.2.</span> <span class="nav-text">2XX 成功</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3XX-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">2.3.</span> <span class="nav-text">3XX 重定向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4XX-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF"><span class="nav-number">2.4.</span> <span class="nav-text">4XX 客户端错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5XX-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF"><span class="nav-number">2.5.</span> <span class="nav-text">5XX 服务器错误</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-x2F-1-0vsHTTP-x2F-1-1vsHTTP-x2F-2-0"><span class="nav-number">3.</span> <span class="nav-text">HTTP&#x2F;1.0vsHTTP&#x2F;1.1vsHTTP&#x2F;2.0</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-x2F-1-0"><span class="nav-number">3.1.</span> <span class="nav-text">HTTP&#x2F;1.0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-x2F-1-1"><span class="nav-number">3.2.</span> <span class="nav-text">HTTP&#x2F;1.1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-x2F-2-0"><span class="nav-number">3.3.</span> <span class="nav-text">HTTP&#x2F;2.0</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS"><span class="nav-number">4.</span> <span class="nav-text">HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">4.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="nav-number">4.2.</span> <span class="nav-text">工作过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E5%BC%8F%E5%8A%A0%E5%AF%86"><span class="nav-number">4.3.</span> <span class="nav-text">对称式加密</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%BC%8F%E5%8A%A0%E5%AF%86"><span class="nav-number">4.4.</span> <span class="nav-text">非对称式加密</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DNS"><span class="nav-number"></span> <span class="nav-text">DNS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS-%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">DNS 的查询过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS%E7%BC%93%E5%AD%98"><span class="nav-number">2.</span> <span class="nav-text">DNS缓存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE"><span class="nav-number"></span> <span class="nav-text">运输层协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP"><span class="nav-number"></span> <span class="nav-text">TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">1.</span> <span class="nav-text">TCP三次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">三次握手的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BD%9C%E7%94%A8"><span class="nav-number">1.2.</span> <span class="nav-text">三次握手作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">1.3.</span> <span class="nav-text">为什么需要三次握手</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">2.</span> <span class="nav-text">TCP四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AB%E4%B9%89"><span class="nav-number">2.1.</span> <span class="nav-text">含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%80%E5%90%8E%E8%BF%98%E8%A6%81%E7%AD%89%E5%BE%85TIME-WAIT"><span class="nav-number">2.2.</span> <span class="nav-text">为什么最后还要等待TIME_WAIT</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="nav-number">3.</span> <span class="nav-text">滑动窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">4.</span> <span class="nav-text">流量控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">5.</span> <span class="nav-text">拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%85%A2%E5%BC%80%E5%A7%8B%E4%B8%8E%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="nav-number">5.1.</span> <span class="nav-text">慢开始与拥塞避免</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%87%8D%E4%BC%A0%E4%B8%8E%E5%BF%AB%E6%81%A2%E5%A4%8D"><span class="nav-number">5.2.</span> <span class="nav-text">快重传与快恢复</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E6%8A%A5%E6%96%87%E5%A4%B4%E6%A0%BC%E5%BC%8F"><span class="nav-number">6.</span> <span class="nav-text">TCP报文头格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.</span> <span class="nav-text">TCP和UDP的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85"><span class="nav-number">8.</span> <span class="nav-text">TCP粘包和拆包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-number">9.</span> <span class="nav-text">TCP 协议如何保证可靠传输</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">10.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%92%8CUDP%E6%9C%89%E5%A6%82%E4%B8%8B%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="nav-number">11.</span> <span class="nav-text">TCP和UDP有如下区别：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARQ-%E5%8D%8F%E8%AE%AE"><span class="nav-number">12.</span> <span class="nav-text">ARQ 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85-ARQ-%E5%8D%8F%E8%AE%AE"><span class="nav-number">12.1.</span> <span class="nav-text">停止等待 ARQ 协议</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP"><span class="nav-number"></span> <span class="nav-text">IP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">IPv4数据报格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87-%E6%A0%87%E8%AF%86%E3%80%81%E6%A0%87%E5%BF%97%E3%80%81%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="nav-number">2.</span> <span class="nav-text">IPv4数据报分片(标识、标志、偏移量)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number"></span> <span class="nav-text">面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5%EF%BC%8C%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%93%AA%E4%BA%9B%E5%8D%8F%E8%AE%AE%EF%BC%88%E8%BF%87%E7%A8%8B%E6%9C%89-6-%E4%B8%AA%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">打开一个网页，整个过程会使用哪些协议（过程有 6 个）</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
